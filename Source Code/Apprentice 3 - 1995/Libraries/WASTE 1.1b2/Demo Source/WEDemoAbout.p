unit WEDemoAbout;{ WASTE DEMO PROJECT: }{ About Boxes }{ Copyright © 1993-1995 Marco Piovanelli }{ All Rights Reserved }interface	uses		WEDemoIntf;	procedure DoAboutBox (dialogID: Integer);implementation	uses		DialogUtils;	const{ dialog item numbers }		kItemTextPane = 3;	var{ static variables }		sBoxPainter: UserItemUPP;	function WETextBox (textResID: Integer;									{const} var bounds: Rect;									alignment: Integer): OSErr;		label			1;		var			hWE: WEHandle;			longBounds: LongRect;			hText: Handle;			hStyles: Handle;			saveTextState, saveStylesState: SignedByte;			err: OSErr;	begin		hWE := nil;		hText := nil;		hStyles := nil;{ create a new WE instance }		WERectToLongRect(bounds, longBounds);		err := WENew(longBounds, longBounds, 0, hWE);		if (err <> noErr) then			goto 1;{ set the alignment style }		WESetAlignment(alignment, hWE);{ load the styl resource and make it unpurgeable }		hStyles := GetResource(kTypeStyles, textResID);		err := ResError;		if (err <> noErr) then			goto 1;		saveStylesState := HGetState(hStyles);		HNoPurge(hStyles);{ load the TEXT resource and lock it }		hText := GetResource(kTypeText, textResID);		err := ResError;		if (err <> noErr) then			goto 1;		saveTextState := HGetState(hText);		HLockHi(hText);{ insert the text }		err := WEInsert(hText^, GetHandleSize(hText), StScrpHandle(hStyles), nil, hWE);		if (err <> noErr) then			goto 1;{ clear result code }		err := noErr;1:{ clean up }		if (hText <> nil) then			HSetState(hText, saveTextState);		if (hStyles <> nil) then			HSetState(hStyles, saveStylesState);		WEDispose(hWE);{ return result code }		WETextBox := err;	end;  { WETextBox }	procedure DrawUserItem (dialog: DialogPtr;									item: Integer);		var			r: Rect;	begin{ draw the text, centered, in the item rect }		GetDialogItemRect(dialog, item, r);		if (WETextBox(GetWRefCon(dialog), r, weCenter) <> noErr) then			;	end;  { DrawUserItem }	procedure DoAboutBox (dialogID: Integer);		var			aboutBox: DialogPtr;			itemHit: Integer;	begin{ get about box }		aboutBox := GetNewDialog(dialogID, nil, WindowPtr(-1));		if (aboutBox = nil) then			Exit(DoAboutBox);{ install a user item drawing procedure for the text pane }		if (sBoxPainter = nil) then			sBoxPainter := NewUserItemProc(@DrawUserItem);		SetDialogItemProc(aboutBox, kItemTextPane, sBoxPainter);{ store ID of TEXT/styl pair (= ID of dialog template) in dialog refCon }		SetWRefCon(aboutBox, dialogID);{ put up the dialog }{$IFC NOT UNDEFINED THINK_PASCAL}		SetCursor(arrow);{$ELSEC}		SetCursor(qd.arrow);{$ENDC}		ShowWindow(aboutBox);		SetPort(aboutBox);{ wait for a click }		ModalDialog(GetMyStandardDialogFilter, itemHit);{ bring down the dialog }		DisposeDialog(aboutBox);	end;  { DoAboutBox }end.