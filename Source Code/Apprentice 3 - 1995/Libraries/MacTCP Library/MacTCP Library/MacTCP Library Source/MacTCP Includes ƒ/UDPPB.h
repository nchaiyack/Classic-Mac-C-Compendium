/* 	UDPPB.h		C definitions of parameter block entries needed for UDP calls	Copyright Apple Computer, Inc. 1988-91 	All rights reserved			Modifications by Dave Nebinger (dnebing@andy.bgsu.edu), 01/30/94.	Brought up to universal header style 050895*/#pragma once#ifndef __H_UDPPB__#define __H_UDPPB__#ifndef __TYPES__#include <Types.h>/*	#include <ConditionalMacros.h>									*//*	#include <MixedMode.h>										*//*		#include <Traps.h>										*/#endif/* First some constants */#define kUDPCreate		20#define kUDPRead		21#define kUDPBfrReturn	22#define kUDPWrite		23#define kUDPRelease		24#define kUDPMaxMTUSize	25#define kUDPStatus		26#define kUDPMultiCreate	27#define kUDPMultiSend	28#define kUDPMultiRead	29#define kUDPCtlMax		29/* Now some enums */enum UDPEventCode {	UDPDataArrival = 1,	UDPICMPReceived,	lastUDPEvent = 32767};/* Now the type definitions */typedef enum UDPEventCode UDPEventCode;typedef ushort udp_port;typedef struct UDPCreatePB UDPCreatePB,* UDPCreatePBPtr,** UDPCreatePBHdl;typedef struct UDPSendPB UDPSendPB,* UDPSendPBPtr,** UDPSendPBHdl;typedef struct UDPReceivePB UDPReceivePB,* UDPReceivePBPtr,** UDPReceivePBHdl;typedef struct UDPMTUPB UDPMTUPB,* UDPMTUPBPtr,** UDPMTUPBHdl;typedef struct UDPiopb UDPiopb,* UDPiopbPtr,** UDPiopbHdl;/* Now the proc pointers */typedef pascal void (*UDPNotifyProcPtr)(StreamPtr udpStream,ushort eventCode,Ptr userDataPtr,		ICMPReportPtr icmpMsg);typedef void (*UDPIOCompletionProcPtr)(UDPiopbPtr iopb);#if USESROUTINEDESCRIPTORS	enum {		uppUDPNotifyProcInfo=kPascalStackBased			| STACK_ROUTINE_PARAMETER(1,SIZE_CODE(sizeof(StreamPtr)))			| STACK_ROUTINE_PARAMETER(2,SIZE_CODE(sizeof(ushort)))			| STACK_ROUTINE_PARAMETER(3,SIZE_CODE(sizeof(Ptr)))			| STACK_ROUTINE_PARAMETER(4,SIZE_CODE(sizeof(ICMPReportPtr))),		uppUDPIOCompletionProcInfo=kCStackBased			| STACK_ROUTINE_PARAMETER(1,SIZE_CODE(sizeof(UDPiopbPtr)))	};		typedef UniversalProcPtr UDPNotifyUPP;	typedef UniversalProcPtr UDPIOCompletionUPP;		#define CallUDPNotifyProc(routine,stream,event,data,mesg)\		CallUniversalProc((UniversalProcPtr)routine,uppUDPNotifyProcInfo,(stream),(event),(data),(mesg))	#define NewUDPNotifyProc(routine)\		(UDPNotifyUPP)NewRoutineDescriptor((ProcPtr)(routine),uppUDPNotifyProcInfo,GetCurrentISA())		#define CallUDPIOCompletionProc(routine,iopb)\		CallUniversalProc((UniversalProcPtr)routine,uppUDPIOCompletionProcInfo,(iopb))	#define NewUDPIOCompletionProc(routine)\		(UDPIOCompletionUPP)NewRoutineDescriptor((ProcPtr)(routine),uppUDPIOCompletionProcInfo,GetCurrentISA())#else	typedef UDPNotifyProcPtr UDPNotifyUPP;	typedef UDPIOCompletionProcPtr UDPIOCompletionUPP;		#define CallUDPNotifyProc(routine,stream,event,data,mesg)\		(*(routine))((stream),(event),(data),(mesg))	#define NewUDPNotifyProc(routine)\		(UDPNotifyUPP)(routine)		#define CallUDPIOCompletionProc(routine,iopb)\		(*(routine))((iopb))	#define NewUDPIOCompletionProc(routine)\		(UDPIOCompletionUPP)(routine)#endif// these two macros will expand correctly for either case#define DisposeUDPNotifyProc(routine)\	DisposeRoutineDescriptor((UniversalProcPtr)routine)#define DisposeUDPIOCompletionProc(routine)\	DisposeRoutineDescriptor((UniversalProcPtr)routine)/* Now the structures */#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct UDPCreatePB {			/* for create and release calls */	Ptr 				rcvBuff;	ulong				rcvBuffLen;	UDPNotifyUPP		notifyProc;	udp_port			localPort;	Ptr				userDataPtr;	udp_port			endingPort;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct UDPSendPB {	ushort			reserved;	ip_addr			remoteHost;	udp_port			remotePort;	wdsEntryPtr		wdsPtr;	Boolean			checkSum;		ushort			sendLength;	Ptr				userDataPtr;	udp_port			localPort;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct UDPReceivePB {		/* for receive and buffer return calls */	ushort			timeOut;	ip_addr			remoteHost;	udp_port			remotePort;	Ptr 				rcvBuff;	ushort			rcvBuffLen;	ushort			secondTimeStamp;	Ptr		 		userDataPtr;	ip_addr			destHost;		/* only for use with multi rcv */	udp_port			destPort;		/* only for use with multi rcv */};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct UDPMTUPB {	ushort 			mtuSize;	ip_addr			remoteHost;	Ptr				userDataPtr;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct UDPiopb {	char 					fill12[12];	UDPIOCompletionProcPtr	ioCompletion;	short 				ioResult;	char 					*ioNamePtr;			short 				ioVRefNum;			short				ioCRefNum;				short 				csCode;	StreamPtr		 	udpStream;					union {		UDPCreatePB		create;		UDPSendPB		send;		UDPReceivePB		receive;		UDPMTUPB		mtu;	} csParam;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif/* And finally the prototypes */#ifdef __cplusplusextern "C" {#endif#ifdef __cplusplus}#endif#endif /* __H_UDPPB__ */************************************************}{*															*}{* LLDoDraw													*}{*															*}{*  -> theList		pointer to LList						*}{*  -> dodraw		1=changes to LList are displayed as 	*}{*					they occur, 0=list will not be 			*}{*					updated until drawing is turned back on	*}{*  -> drawNow		1=draw list items that need drawing		*}{*					immediately, 0=do not draw now (call	*}{*					LLUpdate to force the list to redraw).	*}{*					Note: drawNow is ignored if dodraw = 0.	*}{*															*}{* Turns list drawing normally performed by other LList 	*}{* Manager functions on or off.								*}{*															*}{************************************************************}	procedure LLDoDraw (theList: LListPtr; dodraw: integer; drawNow: integer);{************************************************************}{*															*}{* LLGetCell												*}{*															*}{*  -> theList		pointer to LList						*}{*  -> row			pointer to list row						*}{*  -> colNum		column number of cell in row			*}{*					(column numbers start at 0)				*}{* <-> dataLen		on entry size in bytes of buffer at		*}{*					data, on return actual length of data	*}{*					transferred								*}{*  -> data			pointer to buffer, on return this 		*}{*					buffer contains the data from the cell	*}{*															*}{* Get a copy of a cell's data.								*}{*															*}{************************************************************}	procedure LLGetCell (theList: LListPtr; row: LRowPtr; colNum: integer; var dataLen: integer; data: Ptr);{************************************************************}{*															*}{* LLGetSelect		returns true if a selected row is 		*}{*					found, false if not						*}{*															*}{*  -> theList		pointer to LList						*}{* <-> row			pointer to list row	pointer				*}{*					on entry pointer to a row to test		*}{*					first, on return pointer to a selected	*}{*					row if a selected row was found			*}{*  -> advanceit	1=examine one row,0=keep looking		*}{*															*}{* Queries if a row is selected; gets the next selected		*}{* row if advanceit = true. Note that in searching for all	*}{* selections in a list, you will need to advance row		*}{* (use LLNextRow) after a selection is found.				*}{*															*}{************************************************************}	function LLGetSelect (theList: LListPtr; var row: LRowPtr; advanceit: integer): integer;{************************************************************}{*															*}{* LLNew			returns a pointer to a new LList		*}{*					(returns NULL if there's not enough 	*}{*					memory)									*}{*															*}{*  -> view			pointer to list display	rectangle in	*}{*					local coordinates						*}{*  -> window		pointer to window where list resides	*}{*  -> rowHeight	height of a row in pixels				*}{*					(if you change LList.height after the	*}{*					LLNew call you also need to recalcualte	*}{*					LList.numOfVisRows)						*}{*  -> numOfColumns	number of columns in the list			*}{*					(5 columns would be numbered 0 thru 4)	*}{*  -> hasScroll	1=list has vertical scroll bar, 		*}{*					0=no scroll bar							*}{*  -> selFlags		determines how selection of rows is 	*}{*					processed in LLClick calls				*}{*					See Values for selFlags above.			*}{*															*}{* Allocates and initializes a LList record.				*}{*															*}{************************************************************}	function LLNew (var view: Rect; window: WindowPtr; rowHeight: integer; numOfColumns: integer; hasScroll: integer; selFlags: integer): LListPtr;{************************************************************}{*															*}{* LLNextRow		returns a pointer to next row			*}{*					returns NULL if no next row				*}{*															*}{*  -> theList		pointer to LList						*}{*  -> row			pointer to a row						*}{*															*}{* Returns a pointer to the row after row. Pass NULL for	*}{* row and LLNextRow will return a pointer to the first		*}{* row in the list.											*}{*															*}{************************************************************}	function LLNextRow (theList: LListPtr; row: LRowPtr): LRowPtr;{************************************************************}{*															*}{* LLPrevRow		returns a pointer to previous row		*}{*					returns NULL if no previous row			*}{*															*}{*  -> theList		pointer to LList						*}{*  -> row			pointer to a row						*}{*															*}{* Returns a pointer to the row before row. Pass NULL for	*}{* row and LLPrevRow will return a pointer to the last		*}{* row in the list.											*}{*															*}{************************************************************}	function LLPrevRow (theList: LListPtr; row: LRowPtr): LRowPtr;{************************************************************}{*															*}{* LLRect													*}{*															*}{*  -> theList		pointer to LList						*}{*  -> row			pointer to a row						*}{*  -> colFirst		first column to contain rectangle		*}{*  -> colLast		last column to contain rectangle		*}{* <-  theRect		local coordindates of rectangle that	*}{*					encloses the specified row and columns	*}{*															*}{* Obtains the local coordinates of the rectangle that		*}{* encloses the specified row and column(s).				*}{*															*}{************************************************************}	procedure LLRect (theList: LListPtr; row: LRowPtr; colFirst: integer; colLast: integer; var theRect: Rect);{************************************************************}{*															*}{* LLScroll													*}{*															*}{*  -> theList		pointer to LList						*}{*  -> rows			<0 scroll list down specific number of	*}{*					rows, >0 scroll list up specific 		*}{*					number of rows							*}{*															*}{* Scrolls the list a specific number of rows relative		*}{* to the current displayed rows.							*}{*															*}{************************************************************}	procedure LLScroll (theList: LListPtr; rows: integer);{************************************************************}{*															*}{* LLScrollToRow											*}{*															*}{*  -> theList		pointer to LList						*}{*  -> row			pointer to a row						*}{*															*}{* Scrolls the list so that row is the first row displayed.	*}{* If row is NULL the list scrolls to the bottom.			*}{*															*}{************************************************************}	procedure LLScrollToRow (theList: LListPtr; row: LRowPtr);{************************************************************}{*															*}{* LLSearch			returns 1 if data is found, 0 if not	*}{*															*}{*  -> theList		pointer to LList						*}{* <-> row			pointer to pointer to list row			*}{*					on entry row to start search at or NULL	*}{*					to start search at first row, on return	*}{*					row where data was found if found		*}{* <-  colFound		on return pointer to column number of	*}{*					row where data was found, if found		*}{*  -> colFirst		colFirst and colLast define the range	*}{*  -> colLast		of columns to search in					*}{*  -> data			pointer to buffer containing data to	*}{*					search for								*}{*  -> dataLen		length of buffer						*}{*  -> ignoreCase	1 = comparison is case-insensitive,		*}{*					0 = comparison is case-sensitive		*}{*															*}{* Searches all columns of all rows beginning at *row 		*}{* for data. 												*}{*															*}{************************************************************}	function LLSearch (theList: LListPtr; var row: LRowPtr; var colFound: integer; colFirst: integer; colLast: integer; data: Ptr; dataLen: integer; ignoreCase: integer): integer;{************************************************************}{*															*}{* LLSetCell												*}{*															*}{*  -> theList		pointer to LList						*}{*  -> row			pointer to list row						*}{*  -> colNum		column number of cell in row that will 	*}{*					receive data (col. nums. start at 0)	*}{*  -> dataLen		length of buffer						*}{*  -> data			pointer to buffer containing data to	*}{*					be placed in the cell					*}{*															*}{* Stores a copy of data into a cell.						*}{* (If there's not enough memory to copy data into this		*}{* cell, the cell will be empty.)							*}{* To clear a cell, pass 0 and nil for dataLen and data.	*}{*															*}{************************************************************}	procedure LLSetCell (theList: LListPtr; row: LRowPtr; colNum: integer; dataLen: integer; data: Ptr);{************************************************************}{*															*}{* LLSetSelect												*}{*															*}{*  -> theList		pointer to LList						*}{*  -> row			pointer to list row	to select or		*}{*					deselect								*}{*  -> setit		1=select, 0=deselect					*}{*															*}{* Selects or deselects a cell.								*}{*															*}{************************************************************}	procedure LLSetSelect (theList: LListPtr; row: LRowPtr; setit: integer);{************************************************************}{*															*}{* LLSize													*}{*															*}{*  -> theList		pointer to LList						*}{*  -> listWidth	new width								*}{*  -> listHeight	new height								*}{*															*}{* Cha gKAHLhe siz  /*	LogLibComponent.h		Public Header file for user interaction with the LogLib Component.	*/// ensure that this header is only included once...#pragma once// make doubly-sure...#ifndef __H_LogLibComponent__#define __H_LogLibComponent__// include the Components.h file#ifndef __COMPONENTS__#include <Components.h>#endif/*	In the universal headers the definition for ComponentCallNow has been changed so that the equal sign	is no longer needed.  This kludge will allow the file  oFrom: dnebing@andy.bgsu.edu (Dave Nebinger)Subject: Log file routinesHere's a nice little, tiny, documented chunk of code for handlingthe creation and use of log files in your project.  It works greatfor those hard to debug items like bg-apps, inits, etc.There are actually two different items here.  The first is a bugfixfor the LogLib library that came out earlier.  The second item isnew.  It is a component which implements the logging functions.For those of you that don't know what a component     ‚   ‚   f–gQHh ZY[X3P2mZ[2 àm–° KMacTCP.h    TEXTSPM   d        TEXTSPM   d                    ©ra    èlxÿÄ5˜™boot}³¨(_°`©’Ùl°?©š?©˜Æ5sğÿæ+K`† PrŠ&ò`}VZMLÆÅhq¦ L #U»(nÿüN^NuNV  /(n `UVZMLu89cÿÎ\›pTŒM2 p&0        
 	Genevai   H 	Geneva                             ) ¢B . 4Ì`¬Ì  Â  Â  o     ÿÿÿÿÿÿ  @                     ‚   ‚   f-Ş¤%v    f ETAB   EFNT   &MPSR  2ìÿÿ        ëÿÿ       íÿÿ   -ÙÈ'ÿÿ   b-ÙÔhowing how to usethe co