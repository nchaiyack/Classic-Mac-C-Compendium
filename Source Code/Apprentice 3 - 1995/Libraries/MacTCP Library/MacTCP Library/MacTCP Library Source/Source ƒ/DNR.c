/*	DNR.c		C routines to implement the domain name resolving functions.		Some portions © Apple Computer.		01/30/94 dn - Created.	*/#ifndef __H_MacTCP__#include <MacTCP.h>#endif#include <Strings.h>Handle			gMacDNRcode=(Handle)0L;				// the DNR code resource’s handleUniversalProcPtr	gMacDNRentry=(UniversalProcPtr)0L;	// the DNR code entry point/* Local Constants */#define _kDefaultHostFilename "\pHosts"/* Local Prototypes */OSErr BuildHostFile(StringPtr filename,short vRefNum,long dirId);/*	OpenResolver		Makes the resolver available for the other DNR routines.  This routine must be called before any of	the other DNR routines.*/OSErr OpenResolver(StringPtr fileName){	short	vRefNum;	short	refnum;	long		dirID;	short	fRef;	OSErr	rc;		// is the resolver already there?		if (gMacDNRentry)		return noErr;	// open the MacTCP driver to get DNR resources	refnum = (short)OpenTheDNR();	// Ignore any errors because the resource may be installed in the system file (Mac 512k's).		// load the DNR resource package	gMacDNRcode = GetIndResource('dnrp', 1);	if (gMacDNRcode==(Handle)0){		rc=ResError();		return rc;	}		DetachResource(gMacDNRcode);	if (refnum != -1){ // i.e. if it's not the system folder...		CloseWD(refnum);		CloseResFile(refnum);	}		// lock the DNR resource since it cannot be relocated while opened	mMoveHHi(gMacDNRcode);	mHLock(gMacDNRcode);		gMacDNRentry = (UniversalProcPtr)*gMacDNRcode;		if (fileName!=(StringPtr)0){		if (fileName[0]==0){			// then we were passed an empty string			// pretend it is the null string (because it is in reality)						fileName=(StringPtr)0;		}	}		// if the filename is null...	if (fileName==(StringPtr)0){		/*			Then the resolver is going to try to use the hosts file in the system			folder.  We will check to see if it is there; if not, we are going to create			it...		*/				GetSystemFolder(&vRefNum, &dirID);				// try to open the file...		rc = HOpen(vRefNum,dirID,_kDefaultHostFilename,fsRdPerm,&fRef);				switch (rc) {			case noErr:	// the file exists...				FSClose(fRef);				break;			case fnfErr:	// the file doesn't exist, create one...				BuildHostFile(_kDefaultHostFilename,vRefNum,dirID);				break;		}	}		// convert the name to a C string temporarily...	if (fileName!=(StringPtr)NULL)		p2cstr(fileName);		// ask the DNR resource to open the resolver	rc = CallOpenResolverProc((OpenResolverUPP)gMacDNRentry,OPENRESOLVER,(char*)fileName);		// quick convert the name back...	if (fileName!=(StringPtr)NULL)		c2pstr((char*)fileName);		if (rc != noErr) {		mHUnlock(gMacDNRcode);			// problem with open resolver, flush DNR resource		mDisposeHandle(gMacDNRcode);		gMacDNRcode = NULL;		gMacDNRentry = NULL;		return dnrNoResolver;			// signal failure of DNR	}	return noErr;}/*	CloseResolver		Closes the resolver.  Do not make any more resolver calls unless the resolver is opened again.*/OSErr CloseResolver(){	if (gMacDNRentry ==(UniversalProcPtr)NULL)		return dnrNoResolver;	// call CloseResolver function in DNR	CallCloseResolverProc((CloseResolverUPP)gMacDNRentry,CLOSERESOLVER);	// release the DNR code resource	mHUnlock(gMacDNRcode);	mDisposeHandle(gMacDNRcode);	gMacDNRcode = (Handle)NULL;	gMacDNRentry = (UniversalProcPtr)NULL;		return noErr;}/*	StrToAddr		Converts a host name string to an address.  (ASYNCHRONOUS CALL)*/OSErr StrToAddr(char* hostName,HostInfoPtr host,HostInfoUPP hiproc,char* userDataPtr){	if (gMacDNRentry == (UniversalProcPtr)0)		return dnrNoResolver;		return CallStrToAddrProc((StrToAddrUPP)gMacDNRentry,STRTOADDR,hostName,host,hiproc,userDataPtr);}/*	AddrToStr		Convert an address to it's string equivalent.  (SYNCHRONOUS CALL)*/OSErr AddrToStr(ip_addr addr, char* str){	if (gMacDNRentry == (UniversalProcPtr)0)		return dnrNoResolver;		CallAddrToStrProc((AddrToStrUPP)gMacDNRentry,ADDRTOSTR,addr,str);		return noErr;}/*	EnumCache		Enumerates through the cache of addresses internal to the resolver. (ASYNCHRONOUS CALL)*/OSErr EnumCache(EnumUPP eproc,char* userDataPtr){	if (gMacDNRentry==(UniversalProcPtr)0)		return dnrNoResolver;		return CallEnumCacheProc((EnumCacheUPP)gMacDNRentry,ENUMCACHE,eproc,userDataPtr);}/*	AddrToName		Convert an address to it's name equivalent. (ASYNCHRONOUS CALL)*/OSErr AddrToName(ip_addr addr,HostInfoPtr host,HostInfoUPP hiproc,char* userDataPtr){	if (gMacDNRentry==(UniversalProcPtr)0)		return dnrNoResolver;		return CallAddrToNameProc((AddrToNameUPP)gMacDNRentry,ADDRTONAME,addr,host,hiproc,userDataPtr);}/*	HInfo		Get Host Information. (cpu type and os type) (ASYNCHRONOUS CALL)*/OSErr HInfo(char* hostName,ReturnPtr ret,ReturnRecUPP rproc,char* userDataPtr){	if (gMacDNRentry==(UniversalProcPtr)0)		return dnrNoResolver;		return CallHInfoProc((HInfoUPP)gMacDNRentry,HINFO,hostName,ret,rproc,userDataPtr);}/*	MXInfo		Get Host Mailer Info.  (postmaster's mail address) (ASYNCHRONOUS CALL)*/OSErr MXInfo(char* hostName,ReturnPtr ret,ReturnRecUPP rproc,char* userDataPtr){	if (gMacDNRentry==(UniversalProcPtr)0)		return dnrNoResolver;		return CallMXInfoProc((MXInfoUPP)gMacDNRentry,MXINFO,hostName,ret,rproc,userDataPtr);}/*	OpenTheDNR		Opens the resource file containing the DNR.*/OSErr OpenTheDNR(){	short	refnum;	short	vRefNum;	long		dirID;		// first search Control Panels for MacTCP 1.1 or greater	GetCPanelFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP('cdev', 'ztcp', vRefNum, dirID);	if (refnum != fnfErr)		return refnum;		// next search System Folder for MacTCP 1.0.x	GetSystemFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP('cdev', 'mtcp', vRefNum, dirID);	if (refnum != fnfErr)		return refnum;	// finally, search Control Panels for MacTCP 1.0.x	GetCPanelFolder(&vRefNum, &dirID);	refnum = SearchFolderForDNRP('cdev', 'mtcp', vRefNum, dirID);	if (refnum != fnfErr)		return refnum;		return fnfErr;}/*	SearchFolderForDNRP		Search a designated folder for a file with the given type/creator and containing the 'dnrp' resource.*/OSErr SearchFolderForDNRP(OSType targetType,OSType targetCreator,short vRefNum, long dirID){	HParamBlockRec	fi;	Str255			filename;	short			refnum;		// initialize our search mechanism	fi.fileParam.ioCompletion = nil;	fi.fileParam.ioNamePtr = filename;	fi.fileParam.ioVRefNum = vRefNum;	fi.fileParam.ioDirID = dirID;	fi.fileParam.ioFDirIndex = 1;		// keep looking till we run out of files	while (PBHGetFInfo(&fi, false) == noErr) {			// scan the folder for files that match our type & creator		if (fi.fileParam.ioFlFndrInfo.fdType == targetType &&		    fi.fileParam.ioFlFndrInfo.fdCreator == targetCreator) {			// type/creator match, look for the resource			refnum = HOpenResFile(vRefNum, dirID, filename, fsRdPerm);			if (GetIndResource('dnrp', 1) == NULL)				CloseResFile(refnum);			else				return refnum;		}		// no match or no resource, try next file in folder		fi.fileParam.ioFDirIndex++;		fi.fileParam.ioDirID = dirID;				// PBHGetFInfo() clobbers ioDirID	}	return fnfErr;									// nothing found}/*	BuildHostFile		This function will create a host file and copy the information stored from the resources into 	the new host file.	*/OSErr BuildHostFile(StringPtr filename,short vRefNum,long dirId){	OSErr err;	Handle tH;	short fref;	long len;		// first try to create the file...	err=HCreate(vRefNum, dirId,filename,kHostFileCreatorType,'TEXT');		if (err!=noErr)		return err;		// the file has been created...		// now try to get the text resource...	tH=GetResource('TEXT',30004);		if (tH==(Handle)0L)		return ResError();		HLock(tH);		len=SizeResource(tH);		// Got the text, open the file	err=HOpenDF(vRefNum,dirId,filename,fsWrPerm,&fref);		if (err!=noErr)		goto ExitFromBuildHostFile;		// got the file, write the text...	err=FSWrite(fref,&len,*tH);		// all done...	FSClose(fref);	ExitFromBuildHostFile:	HUnlock(tH);		ReleaseResource(tH);		return err;}              ˇˇˇˇˇˇˇˇ©µ8      EkCPLU   CPlusLib :
                 ˇˇˇˇˇˇˇˇ´åñ      u,MAIN   main.cp  ´3CÂ´3CÂ´3CÂ      D∂MACH  MacHeaders++   ´åí∫´åí∫´åí∫  $   u,SIMP   SimpleWindowClass.h  ´åïÿ´åïÿ´åïÿ     u,LINK   LinkedLists.h 
                 ˇˇˇˇˇˇˇˇ´}=    &   u,SIMP   SimpleWindowClass.cp r ´3CÂ´3CÂ´3CÂ      D∂MACH  MacHeaders++ l ´åí∫´åí∫´åí∫  $   u,SIMP   SimpleWindowClass.h 
                 ˇˇˇˇˇˇˇˇ´åñÏ   0   u,COMP   ComparisonList<WindowClass>.cp   ´3CÂ´3CÂ´3CÂ      D∂MACH  MacHeaders++ t ´åî©´åî©´åî©      u,LINK   LinkedLists.cp W ´åïÿ´åïÿ´åïÿ     u,LINK   LinkedLists.h  ´åí∫´åí∫´åí∫  $   u,SIMP   SimpleWindowClass.h                   ˇˇˇˇˇˇˇˇ©Â:è      E=MACT   MacTraps                    ˇˇˇˇˇˇˇˇ´åñß      u,LIST   ListDemo.rsrc   ’L exÏ eÑV et  eX Ü eD   e@   e<   ep  e|   eÄ  eå  eà   eP   eH   eL   el e eT   e` @ eh     /  .  ; eî≤    HASH   öZONE   ¶KIND   ≤WLOC   æINDX    SLST   ÷CODE  ‚DATA  STRS  DREL  *SYMS  6CNFG BSIZE  ~DBST  äDBWS  ñCREL ¢DBUG ∫_STI  “FWIN  ﬁ        e$  ˇˇ   e  ˇˇ  R e,  ˇˇ  È e(  ˇˇ  ù e  ˇˇ  < e¯  ˇˇ  J e ˇˇ  Æ eå ˇˇ  ∂ eà ˇˇ ı e‹  ˇˇ  æ e  ˇˇ  ¬ e  ˇˇ  ∆ e  ˇˇ    e =«   S eÙ7   Y e(¸ !  } eÏS )  ° eË ˇˇ    eˇˇ 3  ¸ e  Äˇˇ   e‰ Äˇˇ  " e‡ ˇˇ  Œ     ˇˇ  “     ˇˇ  ÷     ˇˇ  ⁄      ˇˇ  Ù     Äˇˇ  
 eXmkahl .o ConverterSymantec C++THINK C	THINK Rez< key, attr, buf, size);		end		else begin			ICGetPref := ICRGetPref(ICRRecordPtr(inst)^, key, attr, buf, size);		end; (* if *)	end; (* ICGetPref *)	function ICSetPref (inst: ICInstance; key: Str255; attr: ICAttr; buf: Ptr; size: longint): ICError;	begin		if ICRRecordPtr(inst)^.instance <> nil then begin			ICSetPref := ICCSetPref(ICRRecordPtr(inst)^.instance, key, attr, buf, size);		end		else begin			ICSetPref := ICRSetPref(ICRRecordPtr(inst)^, key, attr, buf, size);		end; (* if *)	end; (* ICSetPref *)	function ICGetPrefHandle (inst: ICInstance; key: Str255; var attr: ICAttr; var prefh: Handle): ICError;	begin		if ICRRecordPtr(inst)^.instance <> nil then begin			ICGetPrefHandle := ICCGetPrefHandle(ICRRecordPtr(inst)^.instance, key, attr, prefh);		end		else begin			ICGetPrefHandle := ICRGetPrefHandle(ICRRecordPtr(inst)^, key, attr, prefh);		end; (* if *)	end; (* ICGetPrefHandle *)	function ICSetPrefHandle (inst: ICInstance; key: Str255; attr: ICAttr; prefh: Handle): ICError;	begin		if ICRRecordPtr(inst)^.instance <> nil then begin			ICSetPrefHandle := ICCSetPrefHandle(ICRRecordPtr(inst)^.instance, key, attr, prefh);		end		else begin			ICSetPrefHandle := ICRSetPrefHandle(ICRRecordPtr(inst)^, key, attr, prefh);		end; (* if *)	end; (* ICSetPrefHandle *)	function ICCountPref (inst: ICInstance; var count: longint): ICError;	begin		if ICRRecordPtr(inst)^.instance <> nil then begin			ICCountPref := ICCCountPref(ICRRecordPtr(inst)^.instance, count);		end		else begin			ICCountPref := ICRCountPref(ICRRecordPtr(inst)^, count);		end; (* if *)	end; (* ICCountPref *)	function ICGetIndPref (inst: ICInstance; n: longint; var key: Str255): ICError;	begin		if ICRRecordPtr(inst)^.instance <> nil then begin			ICGetIndPref := ICCGetIndPref(ICRRecordPtr(inst)^.instance, n, key);		end		else begin			ICGetIndPref := ICRGetIndPref(ICRRecordPtr(inst)^, n, key);		end; (* if *)	end; (* ICGetIndPref *)	function ICDeletePref (inst: ICInstance; key: Str255): ICError;	begin		if ICRRecordPtr(inst)^.instance <> nil then begin			ICDeletePref := ICCDeletePref(ICRRecordPtr(inst)^.instance, key);		end		else begin			ICDeletePref := ICRDeletePref(ICRRecordPtr(inst)^, key);		end; (* if *)	end; (* ICDeletePref *)	function ICEnd (inst: ICInstance): ICError;	begin		if ICRRecordPtr(inst)^.instance <> nil then begin			ICEnd := ICCEnd(ICRRecordPtr(inst)^.instance);		end		else begin			ICEnd := ICREnd(ICRRecordPtr(inst)^);		end; (* if *)	end; (* ICEnd *)	function ICDefaultFileName (inst: ICInstance; var name: Str63): ICError;	begin		if ICRRecordPtr(inst)^.instance <> nil then begin			ICDefaultFileName := ICCDefaultFileName(ICRRecordPtr(inst) .MPCCance,   //=====================================================================================// JPEGUtilities.h -- written by Aaron Giles// Last update: 7/7/94//=====================================================================================// A source code library for performing very simple operations (drawing, embedding into// PICTs, and extracting from PICTs) on JPEG-compressed images using QuickTime.//======================================================== = =CC = g++CFLAGS = -ansi -pedantic -fno-implicit-templates -Wall -O2COLSOBJECTS = KPString.o cols.oDEPSOBJECTS = KPString.o deps.oSPELLCHECKOBJECTS = KPString.o spellcheck.oall: cols deps spellcheckcols: $(COLSOBJECTS)	$(CC) $(CFLAGS) $(COLSOBJECTS) -o cols	strip colsdeps: $(DEPSOBJECTS)	$(CC) $(CFLAGS) $(DEPSOBJECTS) -o deps	strip depsspellcheck: $(SPELLCHECKOBJECTS)	$(CC) $(CFLAGS) $(SPELLCHECKOBJECTS) -o spellcheck	strip spellcheckclean:	rm -f $(COLSOBJECTS) $(DEPSOBJECTS) $(SPELLCHECKOBJECTS)is giles@med.cornell.edu.//= =RSED======       9∞  8∞   Ô ˝ the additional ˝ Üof a ˚Ä˛ListDemo.rsrc   rsrcRSED  P    rsrcRSED  P                    ´{≤≤      :üeek = (¸ÇPeek) myWin;ˇˇÑo ? +myWin->«txFont¿ = geneva;Ä// ˝ «¸ ã¿ ˛ Ü ˇˇÑ| ? -myWinPeek->˛ÇKind = «dBoxProc¿;á// ˝ ˚Ä˛ Ü       ( ( ®        Ä   7=`
  CDEFË  HÁ‡»N∫ ÚA˙ˇÍ †UN∫ êLﬂN˙öA˙ˇ÷—¸  6Ô †UNuHÁ YO o "o ,/ òX X X *t `D@ Äg“HÄH¿‘Ä`(ÅX @ @g0ÂH‚@H¿‘Ä`X X $Âä‚Ç›±( SÖJÖn∏XOLﬂ `NuHÁ $@ ,Ç∏&
ñÄg@JÄfB,Çº0<®üßF/0<°ò£F±     L   L   2nSeToamcid epg heman nfr t tDtouLList.h   TEXTKAHL        B  TEXTKAHL                      ®ª=]  IG  ~IePenffgnm men o oposprqurcrstSteulupy ñÄƒÊ≤ ‰|Ü ,("F–H¿Ë–H¿Ë:Hõ T ‚î.≈
J6NVX&4k x/^à&~êéNnPf
Ã   H 	Monaco                             * ˝˝ & G¸ß™%‘–   ]   ]           L   L   2 °ßî
®    2  MPSR   
Ìˇˇ     °¶     p`Ç"xÆpi u giv fR@`8≥\Ä` ˇ`p 08Z` ˇVp 8/R@` ˇJ8 /g88 "g4 OÚÄ  Û'0.H@g@?g@?8g@8gp `p`
p`p`p ` ˇ x?ˇén0<®üßF$ <  ´ßF <   ¥àf`
p ` <   ` ˛Œ8A˙ "H g ˛KAHLˆë… `  /*	log.h		Header file for log.c				©1994 by Dave Nebinger (dnebing@andy.bgsu.edu)		All Rights Reserved.				Feel free to use this where ever you wish, just drop me some email		stating what you are doing with it.*/#pragma once#ifndef __H_log__#define __H_log__/*	Apple includes*/#include <Script.h>	/* for smSystemScript */#include <Folders.h>/*	ANSI-small includes		These allow for the use of the '...' and also some of the string and printin  f????ions a       ‘  ‘   ⁄  ó” S           #¡Symantec C+68k Test Applications   APPL??  APPL????!  P                    ¨Ÿ      Æ ˇ¯ˇ      Ä                     W>     )  ’=  P@ ˇ¯ˇ      Ä                       #¡Symantec C++ for Power Mac        ó”  íLog File #1  Log File #2  Log File #3  This line (or two) is being added straight from the application.  An application might want to do this if it has alot of stuff to add to the file, or just because it has data that is not a C or Pas aSPM ring t  /* 	GetMyIPAddr.h		C definitions of parameter block entries needed for IP calls	Copyright Apple Computer, Inc. 1989 	All rights reserved		Modifications by Dave Nebinger (dnebing@andy.bgsu.edu), 01/30/94.*/#pragma once#ifndef __H_GetMyIPAddr__#define __H_GetMyIPAddr__#define ipctlGetAddr		15			/* csCode to get our IP address */// errorsenum {	getipBaseErr=23300,			// the base address for this section	getipNilPB,					// the GetIPParmBlkPt  SPM nil	g  /*	TCP.h		Header file for TCP.c, wrappers for the low level TCP functions.	*/#pragma once#ifndef __H_TCP__#define __H_TCP__#include <TCPPB.h>// special error codes returned by these routines// (MacTCP uses -23xxx, so the library uses 23xxx.  This section uses 231xx.)enum {	tcpBaseErr=23100,					// the base for one of these errors	tcpNilPB,							// the TCPiopb pointer was nil.	tcpNilStream,						// the ioCRefNum field of the TCPiopb was nil.	tcpNilRefNum						// the ioRefNum