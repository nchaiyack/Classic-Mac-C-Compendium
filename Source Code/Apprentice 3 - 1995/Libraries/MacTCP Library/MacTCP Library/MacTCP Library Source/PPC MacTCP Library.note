/*	PPC MacTCP Library.note		Just a quick note to explain the addition of the 'PPC MacTCP Library.rsrc' file.	This resource file just contains icons to make the xcoff and shared libraries	look pretty.  Other than that, it has nothing of importance in it.		In fact, you could remove the resource file without disrupting the functionality	of the library.		Dave Nebinger.	*/ pb);							// do an asynchronous call// DNR Folder extrasOSErr GetSystemFolder(short* vref,long* dirID);			// find the system folderOSErr GetCPanelFolder(short* vref,long* dirID);			// find the control panels folder// Trap extrasshort NumToolboxTraps(void);							// returns the number of traps in the systemTrapType GetTrapType(short theTrap);					// returns the trap type of a given trapBoolean TrapAvailable(short theTrap);					// determines whether a trap is available#ifdef __cplusplus}#endif#endif /* __H_MacTCPExtras__ */void (*HostInfoProcPtr)(HostInfoPtr hostInfoPtr, char* userDataPtr);typedef pascal void (*ReturnRecProcPtr)(ReturnPtr returnRecPtr, char* userDataPtr);#if USESROUTINEDESCRIPTORS	enum {		uppEnumProcInfo=kPascalStackBased			| STACK_ROUTINE_PARAMETER(1,SIZE_CODE(sizeof(CacheEntryPtr)))			| STACK_ROUTINE_PARAMETER(2,SIZE_CODE(sizeof(char*))),		uppHostInfoProcInfo=kPascalStackBased			| STACK_ROUTINE_PARAMETER(1,SIZE_CODE(sizeof(HostInfoPtr)))			| STACK_ROUTINE_PARAMETER(2,SIZE_CODE(sizeof(char*))),		uppReturnRecProcInfo=kPascalStackBased			| STACK_ROUTINE_PARAMETER(1,SIZE_CODE(sizeof(ReturnPtr)))			| STACK_ROUTINE_PARAMETER(2,SIZE_CODE(sizeof(char*)))	};		typedef UniversalProcPtr EnumUPP;	typedef UniversalProcPtr HostInfoUPP;	typedef UniversalProcPtr ReturnRecUPP;		#define CallEnumProc(routine,cep,data)\		CallUniversalProc((UniversalProcPtr)routine,uppEnumProcInfo,(cep),(data))	#define NewEnumProc(routine)\		(EnumUPP)NewRoutineDescriptor((ProcPtr)(routine),uppEnumProcInfo,GetCurrentISA())	#define CallHostInfoProc(routine,cep,data)\		CallUniversalProc((UniversalProcPtr)routine,uppHostInfoProcInfo,(cep),(data))	#define NewHostInfoProc(routine)\		(HostInfoUPP)NewRoutineDescriptor((ProcPtr)(routine),uppHostInfoProcInfo,GetCurrentISA())	#define CallReturnRecProc(routine,cep,data)\		CallUniversalProc((UniversalProcPtr)routine,uppReturnRecProcInfo,(cep),(data))	#define NewReturnRecProc(routine)\		(ReturnRecUPP)NewRoutineDescriptor((ProcPtr)(routine),uppReturnRecProcInfo,GetCurrentISA())#else	typedef EnumProcPtr EnumUPP;	typedef HostInfoProcPtr HostInfoUPP;	typedef ReturnRecProcPtr ReturnRecUPP;		#define CallEnumProc(routine,cep,data)\		(*(routine))((cep),(data))	#define NewEnumProc(routine)\		(EnumUPP)(routine)	#define CallHostInfoProc(routine,cep,data)\		(*(routine))((cep),(data))	#define NewHostInfoProc(routine)\		(HostInfoUPP)(routine)	#define CallReturnRecProc(routine,cep,data)\		(*(routine))((cep),(data))	#define NewReturnRecProc(routine)\		(ReturnRecUPP)(routine)#endif// this macro will expand correctly for either case#define DisposeEnumProc(routine)\	DisposeRoutineDescriptor((UniversalProcPtr)routine)#define DisposeHostInfoProc(routine)\	DisposeRoutineDescriptor((UniversalProcPtr)routine)#define DisposeReturnRecProc(routine)\	DisposeRoutineDescriptor((UniversalProcPtr)routine)#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct HostInfo {	long			rtnCode;	char			cname[255];	ip_addr		addr[NUM_ALT_ADDRS];};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct HInfoRec {	char			cpuType[30];	char			osType[30];};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct MXRec {	ushort		preference;	char			exchange[255];};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif	#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct ReturnRec {	long			rtnCode;	char			cname[255];	union {		ip_addr	addr[NUM_ALT_ADDRS];		HInfoRec	hinfo;		MXRec	mx;	} rdata;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif#if defined(powerc) || defined (__powerc)#pragma options align=mac68k#endifstruct CacheEntryRecord {	char*		cname;	ushort		type;	ushort		cclass;	ulong			ttl;	union {		char*	name;		ip_addr	addr;	} rdata;};#if defined(powerc) || defined(__powerc)#pragma options align=reset#endif#ifdef __cplusplusextern "C" {#endifextern OSErr OpenResolver(StringPtr fileName);extern OSErr CloseResolver(void);extern OSErr StrToAddr(char* hostName,HostInfoPtr host,HostInfoUPP hiproc,char* userDataPtr);extern OSErr AddrToStr(ip_addr addr,char* addrStr);extern OSErr EnumCache(EnumUPP eproc,char* userDataPtr);extern OSErr AddrToName(ip_addr addr,HostInfoPtr host,HostInfoUPP hiproc,char* userDataPtr);extern OSErr HInfo(char* hostName,ReturnPtr ret,ReturnRecUPP rproc,char* userDataPtr);extern OSErr MXInfo(char* hostName,ReturnPtr ret,ReturnRecUPP rproc,char* userDataPtr);#ifdef __cplusplus}#endif#endifn *this;    }    KPIterator<Element> a(my_list);    KPReadOnlyIterator<Element> b(set.my_list);    while (b.ptr()) {        while (a.ptr() && *a < *b)            a++;        if (!a.ptr()) {            b.end();            b++;        }        else {            if (*a == *b) {                a.remove_current();                a++;            }            b++;        }    }    return *this;}/****************************************************************************/template <class Element>KPSet<Element> &KPSet<Element>::operator-=(const Element &element){    KPIterator<Element> iter(my_list);    while (iter.ptr() && *iter < element)        iter++;    if (iter.ptr() && *iter == element)        iter.remove_current();    return *this;}/****************************************************************************/template <class Element>inline boolKPSet<Element>::operator==(const KPSet<Element> &set) const{    return my_list == set.my_list;}/****************************************************************************/template <class Element>inline boolKPSet<Element>::operator!=(const KPSet<Element> &set) const{    return my_list != set.my_list;}/****************************************************************************/template <class Element>inline boolKPSet<Element>::operator<(const KPSet<Element> &set) const{    return my_list < set.my_list;}/****************************************************************************/template <class Element>inline KPSet<Element> &KPSet<Element>::operator=(const KPSet<Element> &set){    my_list = set.my_list;    return *this;}/****************************************************************************/template <class Element>inline KPSet<Element> &KPSet<Element>::operator=(const Element &element){    my_list = element;    return *this;}/****************************************************************************/template <class Element>inline KPSet<Element> &KPSet<Element>::operator=(const KPList<Element> &list){    my_list = list;    if (my_list.size() > 1) {        my_list.sort();        KPIterator<Element> iter(my_list);         register const Element *prev = iter.ptr();        for (iter++; iter.ptr(); iter++)            if (*iter == *prev)                iter.remove_current();            else                prev = iter.ptr();    }    return *this;}/****************************************************************************/template <class Element>inline const KPList<Element> &KPSet<Element>::list() const{    return my_list;}/****************************************************************************/template <class Element>inline intKPSet<Element>::size() const{    return my_list.size();}/****************************************************************************/template <class Element>inline boolKPSet<Element>::is_empty() const{    return my_list.is_empty();}/****************************************************************************/template <class Element>boolKPSet<Element>::contains(const KPSet<Element> &set) const{    if (this == &set)        return true;    KPReadOnlyIterator<Element> a(my_list), b(set.my_list);    while (b.ptr()) {        while (a.ptr() && *a < *b)            a++;        if (!(a.ptr() && *a == *b))            return false;        a++;        b++;    }    return true;}/****************************************************************************/template <class Element>boolKPSet<Element>::contains(const Element &element) const{    KPReadOnlyIterator<Element> iter(my_list);    while (iter.ptr() && *iter < element)        iter++;    return (iter.ptr() && *iter == element);}/****************************************************************************/template <class Element>inline KPSet<Element>KPSet<Element>::all_such_that(bool (*f)(const Element &)) const{    KPSet<Element> new_set;    new_set.my_list = my_list.all_such_that(f);    return new_set;}/****************************************************************************/template <class Element>ElementKPSet<Element>::retrieve(){	if (my_list.is_empty()) {		cerr << "KPSet: retreive() - set empty\n";		exit(EXIT_FAILURE);	}	Element element = my_list.head();	my_list.remove_head();	return element;}/****************************************************************************/template <class Element>inline KPSet<Element> &KPSet<Element>::clear(){    my_list.clear();	return *this;}/****************************************************************************/#endif /* KP_SET_DEFINED */  ˇˆˇˇˇˇˆˇˇˇˇˆˆˆˆˆˆˇ   ˇ ˆˆˆˆˆˆˆˇˇˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˇ   ˇ ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˇ   ˇ ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˇ   ˇ ˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˆˇ    ˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇˇ       ˇˇˇˇˇˇˇˇˇˇˇˇˇ                ¿¿¿¿¿¿¿¿¿¿¿¿¿  ¿¿¿¿¿œˇˇ¿¿¿¿¿ ˜Äˇ ¿¿¿¿ppxô¿¿¿ âü ¿¿œpxppx¿¿¿ ˇ˘áàá¸¿¿˘ààpppp¿¿ˇ ˘òà¸¸ ¿¿˘êàÄppâ¿¿¿œ ˘óàâ¸ ¿¿œpxpÄpâ¿¿¿œ ˜è ¿¿¿pppp¿¿¿¿œ ˜ˇ ¿¿¿¿œˇˇ¿¿¿¿¿¿œ ¸ ¿¿ˇˇ¿¿¿¿¿¿¿¿œˇˇˇˇ¸ˇ¸ˇˇ¿¿œ¿¿¿¿¿¿¿¿¸ ¿¿¿œ¿¿¿¿¿¿¿¿  ¿¿¿œˇˇˇ¿¿¿ ¸ ¿¿¿¿¿¿¿¿¿¿¿¿¿  ¿¿¿¿¿¿¿¿¿¿¿¿¿ ˇˇˇˇˇˇˇˇˇˇˇˇˇ       	[  [   “ p'¿T    ¬ thng   :STR   Fvers   jICON   vICN#   Çicl8   éicl4   ö Ä     H     Äˇˇ         Åˇˇ        ˇˇ   Ç     ˇˇ   õ p(  Äˇˇ   À     Äˇˇ  O     Äˇˇ  S            2?.¸>©†JügzUè?p? /.ˇ¸N≠2TO`fp 	Test URLs   TEXTttxt  å        TEXTttxt  å                    ™ÆÓÖ   ë  LHn˝ÂN≠!*J POf TB(JEg"Uè?Hnˇ¸N≠*TO` TB(| ˝‰ Tº Hn˝‰N≠" XO` ˜∆ Tp JÄg,p @ g"p @ gp @ f/N∫ fXO TB(          	    	                 2 ç<8
J    2  styl   
 Äˇˇ     ç?Ã	(* fetch the mappings preference *)		if err = noErr then begin			err := ICMapErr(ICGetPrefHandle(instance, kICMapping, 									attr, mappings));		end; (* if *)	(* enter     v   v   Ry* by Internet Configuration appICPPCGlue.c   TEXTMPCC  (      TEXTMPCC  (                    ™Èî  B€  » current seed for prefs file *//* this seed changes every time a preference is modified *//* poll this to detect preference chan    . s’o . s’o                 H 	Monaco                             W s˛o W s˛o´¿a∏   Ñ   Ñ               v   v   R¬ ¯T    R MPSR  MWBB   *ˇˇ        Ìˇˇ   "    ˇˇ   n    instance);	end; (* if *)	(* beep if we get any errors*)	(* sophistic tPJMMrror h  unit ICSubs;interface	uses{$ifc undefined THINK_Pascal}		Types, {$endc}		ICTypes;	function ICMapErr (icerr: ICError): OSErr;	function ICGetPrefStr (inst: ICInstance; key: Str255; var attr: ICAttr; var str: Str255): ICError;	function ICSetPrefStr (inst: ICInstance; key: Str255; attr: ICAttr; str: Str255): ICError;implementation	uses{$ifc undefined THINK_Pascal}		Memory, Resources, QuickDraw, AppleTalk, Aliases, Files,{$endc}		ICKeys, ICAPI;	fu cMPCC ICMap  //=====================================================================================// JPEGUtilities.c -- written by Aaron Giles// Last update: 7/7/94//=====================================================================================// A source code library for performing very simple operations (drawing, embedding into// PICTs, and extracting from PICTs) on JPEG-compressed images using QuickTime.//================================================================ =// A module of KPlib v1.3.1.// Written by Keith Pomakis during the summer of 1994.// Released to the public domain on October 10, 1994.#ifndef KP_STACK_DEFINED#define KP_STACK_DEFINED#include "KPbasic.h"#include "KPList.h"#include <stdlib.h>// Assumes Element has a default constructor and operator=().template <class Element>class KPStack {    public:        KPStack();        KPStack(const KPStack<Element> &stack);        KPStack(const KPList<Element> &list);        KPStack(const Element &element);        ~K SKAHL();    #pragma once/*****************************************************************************************************																									**	Class ListItem is used internally by the ListClasses; you don't have to worry about it.			**	It is simply a template class which will hold the class you're storing in the list and will		**	point to the next object in the list															**																									**********************************************************************************************     r   r   RN∫f`| ˜*N∫ ö m˜HJ( gN∫ ÷N∫LList.c   TEXTKAHL         B  TEXTKAHL                       ®ª=-  î≠  ƒ DfBß/<ERR#Bg® _/N≠⁄ m˜H!@ DXè0.ˇ˛N^Nu˛‹ˇˇ$˛˛˛“ˇdˇnˇVB≠Ì~B≠ÛåN∫"N≠zN≠˙N≠BN≠*N≠N≠N≠RN≠N≠RN≠N≠zN≠2N≠JN≠ ‚N≠J     )˛      }ƒÒ       
  áˇˇ       H 	Monaco                             * ˝˝ & Îê™&@  â…  â…           r   r   R UÜ»~    R BKPT  MPSR   *^ˇˇ        !äˇˇ       Ìˇˇ   &    ***************************************************************************************************/ / *KAHL******       Ç  Ç   “N∫˜6N˙˜N∫ı⁄N∫¯ñN˙ˆ“N∫ıŒN∫¯ÆN˙ˆ¸68k Log.lib   LIB KAHL  x      LIB KAHL  x                    ¨‘≥      TÚ¬N˙ˇﬁN∫¯.N∫Ú∂N∫ıN˙ıN∫¯N∫Ú¶N∫ˆ>N˙ıN∫¯2N∫ÚñN˙ˇJN∫¯&N∫ÚäN˙ıN∫ÚÇN∫˜ÚN˙ˇñN∫˜ÍN∫ˆ&N˙ı^N∫ÚjN∫˜⁄N˙ˇíN∫Ú^N∫˜ÚN˙ˇvN∫ÚRN∫˜¬N˙ˇñN∫˜∫N∫ıﬁ   é SetFPos sprintf strlen  CloseLog    vsprintf    	DirCreate   FSClose FSWrite 
FindFolder  InitLog LogTime Log OpenLog   F   l    Ëı     Ülã      
   Ä  l˜ õ     v   Ä T        Ëgˇˇ  "   (    KAHL ≤      /*	LogLibComponent.c		Code version 1.02		This is the source for a log file component.  For those of you who don't know what a component is, read	the Component.note file.		5/7/94 dn - Created.	7/3/94 dn - Modified to work with the Universal Headers.	6/26/95 dn - Modified to build a Code Resource using Sym C++ 8.0 (Rainbow).*//*	In PPC applications, constructors and destructors for global and static objects are called automatically	by __cplusstart, which is actually the main entry point to your appli     §   §   rÀr         qo6ZoiH PartitAddressXlation.hd   TEXTSPM    TEXTSPM                        ûXºr         	ä   ó         	ä óó                                                                                                          *%L{ *%L{   ê                  
 	Genevaº   H 	Geneva                             ) ¢B U ¶¨ôà  ˛    U     ˇˇˇˇˇˇ  @                    §   §   r(ùÿ*¯    r MPSR  ETAB   >EFNT   J     Ç   Ç   f  çx 
        @     é, p9MacTCPExtras.hM   TEXTSPM   †  TEXTSPM   †                    ©uÀ0  ë  Ë'ˇ ¥‰&ˇ º‰&ˇ Ω„‰&'ˇ æ‚„'(ˇ Ã‚„'(ˇ Õ„‰&'ˇ Œ‰&ˇ ÈΩÕˇ Ó‰&ˇ Ô„‰&'ˇ ‚„'(ˇ ˛‚„'(ˇ ˇ        
 	Genevay   H 	Geneva                             ) ¢B L ÷@¨A’  T  T       ˇˇˇˇˇˇ  @                    Ç   Ç   f(ù§(    f ETAB   EFNT   &MPSR  2Ïˇˇ        Îˇˇ       Ìˇˇ   (òP'ˇˇ   b(òTain entry 