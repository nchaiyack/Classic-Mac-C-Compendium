/*******************************************************************************	Header file for asn2gb files.** $Log: makerpt.h,v $ * Revision 1.4  1995/05/15  21:46:05  ostell * added Log line *******************************************************************************/#ifndef _MAKERPT_#define _MAKERPT_#include <ncbi.h>#include <objsset.h>#include <prtutil.h>#include <seqport.h>#include <sequtil.h>#include <stdio.h>#include "a2fstruc.h"#define REPORT_ON_NA ( (Uint1)0)#define REPORT_ON_EVERYTHING ( (Uint1)1)#define REPORT_ON_AA ( (Uint1)2)#define REPORT_MODE ( (Uint1)5)#define EDIT_MODE ( (Uint1)6)#define SEQ_BLK_SIZE (60*NUM_SEQ_LINES)Int4 do_initial_setup PROTO ((SeqEntryPtr sep, Uint1 mode, Uint1 format, Boolean show_seq, Boolean error_msgs, StdPrintOptionsPtr Spop, FFPrintArrayPtr PNTR papp, BiotablePtr PNTR btp_aa_p, BiotablePtr PNTR btp_na_p));void report_set_output PROTO ((FILE *fp, BiotablePtr btp_aa, BiotablePtr btp_na, CharPtr line_return));void report_cleanup PROTO ((BiotablePtr btp_aa, BiotablePtr btp_na, FFPrintArrayPtr pap));CharPtr ReportPrint PROTO((FFPrintArrayPtr pap, Int4 index, Int4 pap_size));Boolean SeqEntryToNewReport PROTO ((SeqEntryPtr sep, Uint1 format, FILE *fp));#endifate new one, place in desktop = 0,0,0*       2) Edit old one, non-zero values, with input_itemtype matching the type*          of the editor.*       3) Create a new one, attach it to something else, non-zero values,*          with input_itemtype not matching the type of the editor.**     Functions to install the returned values are for the cases above:*       1) ObjMgrRegister()*       2) GatherReplaceDataForProc()*       3) GatherAttachDataForProc()**     returns the return from the proc, or OM_MSG_RET_NOPROC if not found******************************************************************************/Int2 GatherProcLaunch (Uint2 proctype, Boolean sel, Uint2 entityID, Uint2 itemID,                    Uint2 itemtype, Uint2 inputtype, Uint2 subinputtype, Uint2 outputtype, Uint2 suboutputtype){	ObjMgrPtr omp;	OMProcControl ompc;	ObjMgrProcPtr ompp=NULL, genproc=NULL;	ObjMgrTypePtr omtp;	Boolean retval;	Uint2 subtype = 0;	MemSet(&ompc, 0, sizeof(OMProcControl));	ompc.input_entityID = entityID;	ompc.input_itemID = itemID;	ompc.input_itemtype = itemtype;	retval = GatherDataForProc(&ompc, sel);	if (sel && (! retval))		return OM_MSG_RET_ERROR;	if (entityID && (! retval))		return OM_MSG_RET_ERROR;	if (! inputtype)   /* not set on input */		inputtype = ompc.input_itemtype;   /* could now be filled in */	omp = ObjMgrGet();	if ((! subinputtype) && (inputtype == ompc.input_itemtype)		               && (ompc.input_data != NULL))	{		omtp = ObjMgrTypeFind(omp, inputtype, NULL, NULL);		if (omtp != NULL)			subinputtype = (*(omtp->subtypefunc))(ompc.input_data);	}	while ((ompp = ObjMgrProcFindNext(omp, proctype, inputtype, outputtype, ompp)) != NULL)	{		if (ompp->subinputtype == subinputtype)			break;		else if ((genproc == NULL) && (! (ompp->subinputtype)))			genproc = ompp;	}	if (ompp == NULL)		ompp = genproc;	if (ompp == NULL)		return OM_MSG_RET_NOPROC;	ompc.proc = ompp;	return (*(ompp->func))((Pointer)&ompc);}LL;		static CharPtr genome[] = {	NULL, NULL, "Cloroplast ", "Chromoplast ", "Kinetoplast ", "Mitochondrion ", "Plastid", "Macronuclear", "Extrachrom", "Plasmid", NULL, NULL, "Cyanelle ", "Proviral"};	/* try new first */	if ((vnp=BioseqContextGetSeqDescr(btp->bcp[count], Seq_descr_source, vnp, NULL)) != NULL) 	{		biosp = vnp->data.ptrvalue;		if (biosp->genome < 6 || biosp->genome == 12)			retval = StringSave(genome[biosp->genome]);	}/* old next */	if (biosp == NULL) {		if ((vnp=BioseqContextGetSeqDescr(btp->bcp[count], Seq_descr_modif, vnp, NULL)) != NULL) 		{			for (man = (ValNodePtr) vnp-> data.ptrvalue; man; man = man -> next)			{				switch (man -> data.intvalue){					case 4: case 5: case 6: case 7:					if (! retval )						retval = StringSave(organelle_names								[man->data.intvalue-4]);						break;					default:						break;					}			}		}	}	return retval;}/**************************************************************************	Look for the same sfp in two different places.  Return 1*	if a match is found; return 0 if none found.*************************************************************************/Int2 RemoveRedundantFeats(BiotablePtr btp, Int2 count, SeqFeatPtr sfp){	Int2 index, retval=0, int_count;	for (int_count=count+1; int_count < (btp->count); int_count++)	{		index=0;		while (btp->sfpList[int_count][index])		{			if (btp->sfpList[int_count][index] == sfp)				return 1;			index++;		}	}	return retval;}Int4 GetNumOfSeqBlks (BiotablePtr btp, Int2 count){        Int4 length, num_of_seqblks;        length = BioseqGetLen(btp->bsp[count]);        num_of_seqblks = ROUNDUP(length, SEQ_BLK_SIZE)/SEQ_BLK_SIZE;        return num_of_seqblks;}->qual);	ifp = sfp_out->data.value.ptrvalue;	if (ifp->loc)		ifp->loc = MemFree(ifp->loc);	if (feat_index < total_feats)	{		sfp_in = btp->sfpList[count][feat_index];		switch (sfp_in->data.choice)		{ /* Note: the functions that CheckAndGetFeatLoc use for		checking fails on protein locations sometimes. */			case 3:				GetNonGeneQuals(sfp_in, sfp_out, btp, count, feat_index);				status = ConvertToAAImpFeat(btp, count, sfp_in, &sfp_out, feat_index);				if (status < 0)					break;				ComposeGBQuals(sfp_out, btp, count, feat_index);				GetAAFeatLoc(btp, count, &ptr, sfp_in, TRUE);				ifp->loc = ptr;				ptr = FlatLoc(btp, count, sfp_in->location);				sfp_out->qual =				     AddGBQual(sfp_out->qual, "coded_by", ptr);				ptr = MemFree(ptr);				genetic_code[0]='\0';				if (ASN2FF_TRANSL_TABLE == TRUE)				{					GetGeneticCode(genetic_code, sfp_in);					if (genetic_code[0] != '\0')						sfp_out->qual =							AddGBQual(sfp_out->qual, "transl_table", genetic_code);				}				status = ValidateAAImpFeat(btp, count, sfp_out, TRUE);				if (status >= 0)					PrintImpFeat(btp, count, sfp_out);				break;			case 4:				GetNonGeneQuals(sfp_in, sfp_out, btp, count, feat_index);				nsp = btp->nspp[count][feat_index];				AddProteinQuals(sfp_in, sfp_out, nsp);				status = ConvertToAAImpFeat(btp, count, sfp_in, &sfp_out, feat_index);				if (status < 0)					break;				ComposeGBQuals(sfp_out, btp, count, feat_index);				GetAAFeatLoc(btp, count, &ptr, sfp_out, FALSE);				ifp->loc = ptr;				status = ValidateAAImpFeat(btp, count, sfp_out, FALSE);				if (status >= 0)					PrintImpFeat(btp, count, sfp_out);				break;			case 7:			case 8:			case 9:			case 10:			case 11:			case 12:			case 17:			case 18:			case 19:				GetNonGeneQuals(sfp_in, sfp_out, btp, count, feat_index);				status = ConvertToAAImpFeat(btp, count, sfp_in, &sfp_out, feat_index);				if (status < 0)					break;				ComposeGBQuals(sfp_out, btp, count, feat_index);				GetAAFeatLoc(btp, count, &ptr, sfp_out, FALSE);				ifp->loc = ptr;				status = ValidateAAImpFeat(btp, count, sfp_out, FALSE);				if (status >= 0)					PrintImpFeat(btp, count, sfp_out);				break;			default:				break;		}	}	else		PrintOrphanFeatByNumber(btp, count, sfp_out, feat_index-total_feats);	sfp_out->comment = NULL;	sfp_out->location = NULL;	sfp_out->product = NULL;	if (sfp_out->qual)		sfp_out->qual = GBQualFree(sfp_out->qual);}	/* PrintAAFeatByNumber *//***************************************************************************ConvertToAAImpFeat**	This code copies a SeqFeat into an ImpFeat format for use in*	producing GenBank format.  Two SeqFeatPtr's should be passed*	in as arguments (sfp_in, sfp_out).  On the first call, of a*	number of calls, sfp_out should be NULL so that memory for *	ImpFeat can be allocated.  On subsequent calls, sfp_out->data.choice*	should be "8" (for ImpFeats).**	Written by Tom Madden ***************************************************************************/Int2 ConvertToAAImpFeat (BiotablePtr btp, Int2 count, SeqFeatPtr sfp_in, SeqFeatPtr PNTR sfpp_out, Int2 ext_index){	BioseqPtr bsp=NULL;	Char printbuf[41], temp[65];	CharPtr ptr;	ImpFeatPtr ifp, ifp_in;	Int2 retval=1;	NoteStructPtr nsp;	SeqFeatPtr sfp_out;	SeqIdPtr sip=NULL, xid;	ValNodePtr vnp, vnp1;	sfp_out = *sfpp_out;	if (sfp_out->data.choice != 8)		return -1;	ifp = (ImpFeatPtr) sfp_out->data.value.ptrvalue;	sfp_out->partial = sfp_in->partial;	sfp_out->comment = sfp_in->comment;	sfp_out->exp_ev = sfp_in->exp_ev;	sfp_out->location = sfp_in->location;	if (sfp_out->comment)	{		nsp = btp->nspp[count][ext_index];		CpNoteToCharPtrStack(nsp, NULL, (CharPtr) sfp_out->comment);	}	switch (sfp_in->data.choice)	{	case 3:		ifp->key = StringCpy(ifp->key, "CDS");		break;	case 4:		ifp->key = StringCpy(ifp->key, "Protein");		if (sfp_in->location)		{			sip = SeqLocId(sfp_in->location);			if (sip)				bsp = BioseqFind(sip);			if (bsp)			{				vnp = bsp->descr;				while (vnp)				{					if (vnp->choice == Seq_descr_modif)					{					    vnp1 = vnp->data.ptrvalue;					    while (vnp1)					    {					         if (vnp1->data.intvalue == 10)					         {					    		sfp_out->partial = TRUE;					    		break;					         }					         vnp1=vnp1->next;					    }					}					vnp = vnp->next;				}			}		}		break;	case 7:			ifp->key = StringCpy(ifp->key, "misc_feature");		if ((xid=CheckXrefFeat(btp->bsp[count], sfp_in)) != NULL)		{			SeqIdPrint(xid, printbuf, PRINTID_FASTA_SHORT);			ptr = &(temp[0]);			sprintf(ptr, "Cross-reference: %s", printbuf);			nsp = btp->nspp[count][ext_index];			SaveNoteToCharPtrStack(nsp, NULL, ptr);		}		else			retval = 0;		break;	case 8:		ifp_in = (ImpFeatPtr) sfp_in->data.value.ptrvalue;		ifp->key = StringCpy(ifp->key, ifp_in->key);		break;	case 9:		sfp_out->qual = 		     AddGBQual(sfp_out->qual, "region_name", sfp_in->data.value.ptrvalue);		ifp->key = StringCpy(ifp->key, "Region");		break;	case 10:		ifp->key = StringCpy(ifp->key, "misc_feature");		break;	case 11:		ptr = AsnEnumStr("SeqFeatData.bond", (Int2) (sfp_in->data.value.intvalue));		sfp_out->qual = AddGBQual(sfp_in->qual, "bond_type", ptr);		ifp->key = StringCpy(ifp->key, "Bond");		break;	case 12:		ptr = AsnEnumStr("SeqFeatData.site", (Int2) (sfp_in->data.value.intvalue));		sfp_out->qual = AddGBQual(sfp_out->qual, "site_type", ptr);		ifp->key = StringCpy(ifp->key, "Site");		break;	case 17:		ptr = AsnEnumStr("SeqFeatData.psec-str", (Int2) (sfp_in->data.value.intvalue));		sfp_out->qual = AddGBQual(sfp_out->qual, "sec_str_type", ptr);		ifp->key = StringCpy(ifp->key, "SecStr");		break;	case 18:		sfp_out->qual = 			AddGBQual(sfp_out->qual, "non-std-residue", sfp_in->data.value.ptrvalue);		ifp->key = StringCpy(ifp->key, "NonStdResidue");		break;	case 19:		sfp_out->qual = 		     AddGBQual(sfp_out->qual, "heterogen", sfp_in->data.value.ptrvalue);		ifp->key = StringCpy(ifp->key, "Het");		break;	default:		if (btp->error_msgs == TRUE)			ErrPostEx(SEV_WARNING, ERR_FEATURE_UnknownFeatureKey, 				"Unimplemented type of feat in ConvertToAAImpFeat\n");		retval = 0;		break;	}	return retval;}	/* ConvertToAAImpFeat *//*************************************************************************GetProductFromCDS(ValNodePtr product, ValNodePtr location, Int4 length)**	Gets the CDS product, using SeqPortNewByLoc*	The bsp is that of the protein, and comes from the location.  The bsp*	is found in the calling program anyway, as it's used to get*	the EC_NUM.*	The protein sequence comes back in allocated memory.  The user*	is responsible for deallocating that.**  A check is made (BioseqFind()) that the protein Bioseq is in memory.*  This guarantees that a fetch is NOT made if it is not memory, to accomodate*  the splitting of DNA and protein in Entrez. In this case, it's just*  translated.**************************************************************************/CharPtr GetProductFromCDS(ValNodePtr product, ValNodePtr location, Int4 bsp_length){	Boolean at_end=FALSE;	CharPtr protein_seq=NULL, start_ptr=NULL;	Int4 length;	SeqPortPtr spp;	Uint1 residue, code;	BioseqPtr bsp;	SeqIdPtr sip;	if (ASN2FF_IUPACAA_ONLY == TRUE)		code = Seq_code_iupacaa;	else		code = Seq_code_ncbieaa;	if (product)	{		sip = SeqLocId(product);		bsp = BioseqFindCore(sip);		if (bsp != NULL)    /* Bioseq is (or has been) in memory */		{			length = SeqLocLen(product);			if (length > 0)			{				if (SeqLocStart(location) == 0 ||					SeqLocStop(location) == bsp_length-1)					at_end = TRUE;				start_ptr = protein_seq = (CharPtr) MemNew((size_t) (length*sizeof(CharPtr)));				spp = SeqPortNewByLoc(product, code);				while ((residue=SeqPortGetResidue(spp)) != SEQPORT_EOF)				{					if ( !IS_residue(residue) && residue != INVALID_RESIDUE )						continue;					if (residue == INVALID_RESIDUE)						residue = (Uint1) 'X';					*protein_seq = residue;					protein_seq++;				}				SeqPortFree(spp);				if (at_end)				{					if (StringLen(start_ptr) < GENPEPT_MIN)						start_ptr = MemFree(start_ptr);				}			}		}	}	return start_ptr;}/*************************************************************************CharPtr DotRNAQuals (BiotablePtr btp, SeqFeatPtr sfp, Int2 count, Int2 ext_index)**	Make the anticodon qualifier and (possible) note to the tRNA*	with the following paradigm:**	1.) Look at SeqFeat.ext for a UserObject using the fct. QualLocWrite,*	if result is not NULL, use this location in anticodon qualifier;**	2.) Look for an anticodon qualifier, use if no QualLocWrite's *	result was not zero;**	3.) Make note if neither 1.) or 2.) was true, or there are*	multiple codons.*************************************************************************/void DotRNAQuals (BiotablePtr btp, SeqFeatPtr sfp_in, SeqFeatPtr sfp_out, Int2 count, Int2 ext_index){	Boolean found_anticodon=FALSE, found_qual=FALSE;	Char buffer[40];	CharPtr aa_ptr, newptr=NULL, ptr = &(buffer[0]), tmp=NULL;	GBQualPtr curq;	RnaRefPtr rrp;	tRNAPtr trna=NULL;	if (sfp_in->ext)	{	/* Look for UserObject */		tmp = QualLocWrite(sfp_in->ext, ptr);		if (tmp)		{			newptr = MemNew(50*sizeof(Char));			rrp = sfp_in->data.value.ptrvalue;			trna = rrp->ext.value.ptrvalue;			aa_ptr = GettRNAaa(trna, btp->error_msgs);			if (aa_ptr)			{			     sprintf(newptr, "(pos:%s,aa:%s)", ptr, aa_ptr);			     sfp_out->qual = 			        AddGBQual(sfp_out->qual, "anticodon", newptr); 			     found_anticodon=TRUE;			}			newptr = MemFree(newptr);		}	}	if (! found_anticodon)	{	/* Look for anticodon qual if no UserObject found */		for (curq=sfp_in->qual; curq; curq=curq->next)			if (StringCmp("anticodon", curq->qual) == 0)			{			    sfp_out->qual = 			       AddGBQual(sfp_out->qual, "anticodon", curq->val); 			    found_qual=TRUE;			    break;			}	}	if (!found_anticodon && !found_qual)	{	/* If neither was true, make note */		rrp = sfp_in->data.value.ptrvalue;		if (rrp->ext.choice == 2)		{			trna = rrp->ext.value.ptrvalue;			ComposetRNANote(btp, trna, count, ext_index);		}	}	if (trna && (trna->codon)[0] != 255 && (trna->codon)[1] != 255)	{	/* if multiple codons recognized, make note */		rrp = sfp_in->data.value.ptrvalue;		trna = rrp->ext.value.ptrvalue /*******************************************************************************	Header file for asn2gb files.*****************************************************************************//* $Revision: 1.10 $ */ /*************************************** $Log: asn2ff6.h,v $ * Revision 1.10  1995/05/15  21:46:05  ostell * added Log line ****************************************/#ifndef _ASN2FF6_#define _ASN2FF6_#include <asn.h>#include <objall.h>#include <objpubd.h>#include <objsub.h>#i c/*   gather.h* ===========================================================================**                            PUBLIC DOMAIN NOTICE*            National Center for Biotechnology Information (NCBI)**  This software/database is a "United States Government Work" under the*  terms of the United States Copyright Act.  It was written as part of*  the author's official duties as a United States Government employee and*  thus cannot be copyrighted.  This software/database is freely available*  to the p