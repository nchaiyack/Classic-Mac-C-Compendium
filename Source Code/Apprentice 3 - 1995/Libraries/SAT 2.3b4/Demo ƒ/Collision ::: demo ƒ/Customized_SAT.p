unit customized_SAT;interface{$ifc UNDEFINED THINK_PASCAL}	uses		Types, QuickDraw, Icons; {Icons assume UPI}{$endc}	type		SATPort = record				port: GrafPtr;		{GrafPtr/WindowPtr, use for SetPort, ShowWindowÉ}				device: GDHandle;	{Internal}				rows: Ptr;			{Internal}				bounds: Rect;			{Internal}				baseAddr: Ptr;		{Internal}				rowBytes: Integer;	{Internal}			end;		SATPortPtr = ^SATPort;		FacePtr = ^Face;		Face = record				colorData: Ptr;				resNum: integer;				iconMask: BitMap;				rowBytes: integer;				next: FacePtr;				maskRgn: RgnHandle;				rows, maskRows: Ptr;				redrawProc: ProcPtr;	{Called on depth changes, not needed if loaded from a cicn}			end;		SpritePtr = ^Sprite;		Sprite = record{ Variables that you should change as appropriate }				kind: Integer; { Used for identification. >0: friend. <0 foe }				position: Point;				hotRect, hotRect2: Rect; { Tells how large the sprite is; hotRect is centered around origo }										{hotRect is set by you. hotRect2 is offset to the current position.}				face: FacePtr; { Pointer to the Face (appearance) to be used. }				task: ProcPtr; { Callback-routine, called once per frame. If task=nil, the sprite is removed. }				hitTask: ProcPtr; { Callback in collisions. }				destructTask: ProcPtr; { Called when a sprite is disposed. (Usually nil.) }				clip: RgnHandle;{ SAT variables that you shouldn't change: }				oldpos: Point;				{The 'task' routine is not allowed to change this! }				next, prev: SpritePtr;	{You may change them in your own sorting routine, but be careful if you do.}				r, oldr: Rect;				{Rectangle telling where to draw. Avoid messing with it.}				oldFace: FacePtr;			{Used by RunSAT2}				dirty: Boolean;			{Used by RunSAT2}{Variables for internal use by the sprites. I have edited them, to add fixed-point postions!}{Since we have edited the record, we must SetSpriteSize immediately}{after initializing (before any sprites are created)!}				layer: integer; {For layer-sorting. When not used for that, use freely.}				speed: Point; { Can be used for speed, but not necessarily. }				mode: integer; { Usually used for different modes and/or to determine what image to show next. }				fixedPos: Point; {Position * 16}			end;{Type for SATs pattern utilities.}	type		SATPattern = record				patternType: integer; {1 = Pattern, PatHandle, 2 = PixPat, PixPatHandle}				thePat: PixPatHandle; {or PatHandle}			end; {record}		SATPatPtr = ^SATPattern;		SATPatHandle = ^SATPatPtr;{Update list. Used internally}		UpdatePtr = ^UpdateRec;		UpdateRec = record				updateRect: Rect;				next: UpdatePtr;			end;{The globals record. Some fields are important for you. These are marked with *}		SATglobalsRec = record				wind: SATPort;									{*The window that SAT draws in. You get the WindowPtr as gSAT.wind.port}				offSizeH, offSizeV: integer;		{*Offscreen size, used to limit sprite positions}				offScreen: SATPort;							{*Offscreen image }				backScreen: SATPort;						{*Background image }				ox, oy: longint;								{Internal}				pict, bwpict: integer;					{PICT id's}				fitThePICTs: boolean;						{Resize PICTs to fit?}				sorting: integer;								{Chosen sorting}				collision: integer;							{Chosen collision handling}				searchWidth: integer;						{Chosen search width}				screen: PixMapHandle;						{Internal}				bounds: Rect;										{Internal}				initDepth: Integer;							{*Depth at last icon initialization}				synchHook: ProcPtr;							{Synch procedure}				sRoot: SpritePtr;								{Sprite list root}				updateRoot: UpdatePtr;					{Update list root}				anyMonsters: Boolean;						{*False when no sprites with kind < -1 are active }				ditherOff: CGrafPtr;						{Internal}				ditherOffGD: GDHandle;					{Internal}				iconPort: SATPort;							{Internal}				iconPort2: SATPort;							{Internal}				bwIconPort: GrafPtr; 						{Internal}{Environment-independent globals:}				faceRoot: FacePtr;							{Root of face list}				colorFlag: Boolean;							{True if color QuickDraw is available.}{Blitters! You should not change these fields yourself. (Possibly for installing a blitter in your program code.)}				rectBlit1, maskBlit1: ProcPtr;				{Supplied - this is either RBlt/MBlt 0 or 1}				rectBlit2, maskBlit2: ProcPtr;				{Will probably never be used}				rectBlit4, maskBlit4: ProcPtr;				{Supplied}				rectBlit8, maskBlit8: ProcPtr;				{Supplied}				rectBlit16, maskBlit16: ProcPtr;			{Not supplied}				rectBlit32, maskBlit32: ProcPtr;			{Not supplied}				curRectBlit, curMaskBlit: ProcPtr;			{Currently selected fast blitter}			end;{Configuration types: VPositionSort and KindCollision are defaults.}	const{Sorting options}		kVPositionSort = 0;		kLayerSort = 1;		kNoSort = 2;{Collision detection options}		kKindCollision = 0;		kForwardCollision = 1;		kBackwardCollision = 2;		kNoCollision = 3;		kForwardOneCollision = 4;	var{$ifc UNDEFINED THINK_PASCAL}		gSAT: SATglobalsRec;		external;				{Most globals in a record. See above.}		gSATSoundErrorProc: ProcPtr;		external;		{Pointer to procedure to call on sound error.}{$elsec}{$J+}		gSAT: SATglobalsRec;				{Most globals in a record. See above.}		gSATSoundErrorProc: ProcPtr;		{Pointer to procedure to call on sound error.}{$J-}{$endc}{Initializing and customizing}	procedure SATConfigure (PICTfit: boolean; newSorting, newCollision, searchWidth: integer);	procedure SATInit (pictID, bwpictID, Xsize, Ysize: integer);	procedure SATCustomInit (pictID, bwpictID: integer; var SATdrawingArea: Rect; {}									preloadedWind: WindowPtr; chosenScreen: GDHandle; useMenuBar, {}									centerDrawingArea, fillScreen, dither4bit, beSmart: Boolean);{Maintainance, background manipulation etc.}	function SATDepthChangeTest: Boolean;	procedure SATDrawPICTs (pictID, bwpictID: integer);	procedure SATRedraw;{Drawing}	procedure SATPlotFace (theFace: FacePtr; theGrafPtr: SATPortPtr; where: Point; Fast: boolean);	procedure SATPlotFaceToScreen (theFace: FacePtr; where: Point; Fast: boolean);{SATCopybits is now only done with a CopyBits - so it's really obsolete.}	procedure SATCopyBits (src, dest: SATPortPtr; {}									var srcRect, destRect: Rect; fast: Boolean);	procedure SATCopyBitsToScreen (src: SATPortPtr; var srcRect, destRect: Rect; fast: Boolean);	procedure SATBackChanged (var r: Rect); {Tell SAT about changes in backScreen}{SetPort replacements}	procedure SATGetPort (var port: SATPort);	procedure SATSetPort (var port: SATPort);	procedure SATSetPortOffScreen; {Use before using QuickDraw on offScreen}	procedure SATSetPortBackScreen; {Use before using QuickDraw on backScreen}	procedure SATSetPortScreen; {Use to set port to gSAT.wind}{Basic sprite handling}	function SATGetFace (resNum: integer): FacePtr;	procedure SATDisposeFace (theFace: FacePtr);	function SATNewSprite (kind, hpos, vpos: integer; setup: ProcPtr): SpritePtr;	function SATNewSpriteAfter (afterthis: SpritePtr; kind, hpos, vpos: integer; setup: ProcPtr): SpritePtr;	procedure SATKillSprite (who: Spriteptr);{Animating}	procedure SATRun (fast: Boolean); {The heart of the whole package!}	procedure SATRun2 (fast: Boolean); {Alternate routine for allowing resting sprites}{Special functions for advanced programmers}	procedure SATInstallSynch (theSynchProc: ProcPtr);	procedure SATInstallEmergency (theEmergencyProc: ProcPtr);	procedure SATSetSpriteRecSize (theSize: longint);	procedure SATSkip;	procedure SATKill; {Dispose of offscreen buffers to allow re-init}	procedure SATWindMoved;{Offscreen - use only if you need an *extra* offscreen buffer. These calls are likely to change in the future!}	procedure SATMakeOffscreen (var portP: SATPort; rectP: Rect); {Make offscreen buffer in current screen depth and CLUT.}	procedure SATDisposeOffScreen (var portP: SATPort); {Get rid of offscreen}	function CreateOffScreen (var bounds: Rect; depth: Integer; colors: CTabHandle; var retPort: CGrafPtr; var retGDevice: GDHandle): OSErr; {From Principia Offscreen - color only}	procedure DisposeOffScreen (doomedPort: CGrafPtr; doomedGDevice: GDHandle);{From Principia Offscreen - color only}{Face manipulation (for advanced programmers)}	procedure SATSetPortMask (theFace: FacePtr);	procedure SATSetPortFace (theFace: FacePtr);	procedure SATSetPortFace2 (theFace: FacePtr);	function SATNewFace (var faceBounds: Rect): FacePtr;	procedure SATChangedFace (theFace: FacePtr);{New procedures, EXPERIMENTAL, intended for making a C++ interface}	function SATGetFacePP (resNum: integer; fStorage: Ptr): FacePtr;	function SATNewSpritePP (afterthis: SpritePtr; sStorage: Ptr; theKind, hpos, vpos: integer; setup: ProcPtr): SpritePtr;	procedure SATCopySprite (destSprite: SpritePtr; srcSprite: SpritePtr);	function SATNewFacePP (var faceBounds: Rect; fStorage: Ptr): FacePtr;	procedure SATCopyFace (destFace: FacePtr; srcFace: FacePtr);	procedure SATDisposeFacePP (theFace: FacePtr);{Cicn utilities}	function SATGetCicn (cicnId: integer): CIconHandle;	procedure SATPlotCicn (theCicn: CIconHandle; dest: GrafPtr; destGD: GDHandle; r: Rect); {Borde jag lŠgga till device?}	procedure SATDisposeCicn (theCicn: CIconHandle);{Utilities}	procedure SATSetStrings (ok, yes, no, quit, memerr, noscreen, nopict, nowind: Str255);	function SATTrapAvailable (theTrap: Integer): Boolean;	procedure SATDrawInt (i: integer);	procedure SATDrawLong (l: longint);	function SATRand (n: integer): integer;	function SATRand10: integer;	function SATRand100: integer;	procedure SATReportStr (str: str255);	function SATQuestionStr (str: str255): Boolean;	function SATFakeAlert (s1, s2, s3, s4: Str255; nButtons, defButton, cancelButton: integer;{}									t1, t2, t3: Str255): integer;	procedure CheckNoMem (p: Ptr); {If the Ptr is nil, out of memory emergency exit}	procedure SATSetMouse (where: point);	procedure SATInitToolbox;{Pattern utilities}	procedure SATPenPat (SATpat: SATPatHandle);	procedure SATBackPat (SATpat: SATPatHandle);	function SATGetPat (patID: integer): SATPatHandle;	procedure SATDisposePat (SATpat: SATPatHandle);{Menu bar utilities}	procedure SATShowMBar (wind: WindowPtr);	procedure SATHideMBar (wind: WindowPtr);{PICT utilities}	procedure SATGetandDrawPICTRes (id: integer);	procedure SATGetandDrawPICTResInRect (id: integer; frame: Rect);	procedure SATGetandCenterPICTResInRect (id: integer; frame: Rect);{Sound}	procedure SATSoundInit; {Called from SATInit}	procedure SATSoundPlay (TheSound: Handle; Priority: integer; CanWait: boolean);	procedure SATSoundEvents; {Call this once in a while when not calling SATRun often}	procedure SATSoundShutup; {Silence, dispose of sound channel}	procedure SATSoundOn;	procedure SATSoundOff;	function SATSoundDone: Boolean; {Any sound going on ?}	function SATGetSound (sndId: integer): handle;		{ To load a sound and get a handle for SATSoundPlay }	function SATGetNamedSound (name: Str255): Handle; { Same but using resource names }	procedure SATDisposeSound (theSnd: handle);{Multi-channel sound routines}	function SATSoundInitChannels (num: integer): integer;	function SATSoundDoneChannel (chanNum: integer): Boolean;	procedure SATSoundPlayChannel (theSound: Handle; chanNum: integer);	procedure SATSoundReserveChannel (chanNum: integer; reserve: Boolean);	procedure SATSoundShutupChannel (chanNum: integer);	procedure SATPreloadChannels;{Experimental, likely to be renamed/removed/changed:}	procedure SATSoundPlay2 (theSound: Handle; priority: integer; canWait, skipIfSame: Boolean);	procedure SATSoundPlayEasy (theSound: Handle; canWait: Boolean);{More multi-channel:}	function SATGetNumChannels: integer;	function SATGetChannel (chanNum: integer): Ptr;{Customization}	procedure SATSetSoundInitParams (params: Longint);implementationend.