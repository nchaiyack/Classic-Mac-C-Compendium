/* * Copyright (c) 1985 Regents of the University of California. * All rights reserved. * * Redistribution and use in source and binary forms are permitted * provided that this notice is preserved and that due credit is given * to the University of California at Berkeley. The name of the University * may not be used to endorse or promote products derived from this * software without specific prior written permission. This software * is provided ``as is'' without express or implied warranty. */#if defined(LIBC_SCCS) && !defined(lint)static char sccsid[] = "@(#)res_mkquery.c	6.7 (Berkeley) 3/7/88";#endif /* LIBC_SCCS and not lint */#include <stdio.h>#include <sys/types.h>#include <netinet/in.h>#include <arpa/nameser.h>#include <resolv.h>/* * Form all types of queries. * Returns the size of the result or -1. */res_mkquery(op, dname, class, type, data, datalen, newrr, buf, buflen)	int op;			/* opcode of query */	char *dname;		/* domain name */	int class, type;	/* class and type of query */	char *data;		/* resource record data */	int datalen;		/* length of data */	struct rrec *newrr;	/* new rr for modify or append */	char *buf;		/* buffer to put query */	int buflen;		/* size of buffer */{	register HEADER *hp;	register char *cp;	register int n;	char dnbuf[MAXDNAME];	char *dnptrs[10], **dpp, **lastdnptr;	extern char *strchr();#ifdef DEBUG	if (_res.options & RES_DEBUG)		printf("res_mkquery(%d, %s, %d, %d)\n", op, dname, class, type);#endif DEBUG	/*	 * Initialize header fields.	 */	hp = (HEADER *) buf;	hp->id = htons(++_res.id);	hp->opcode = op;	hp->qr = hp->aa = hp->tc = hp->ra = 0;	hp->pr = (_res.options & RES_PRIMARY) != 0;	hp->rd = (_res.options & RES_RECURSE) != 0;	hp->rcode = NOERROR;	hp->qdcount = 0;	hp->ancount = 0;	hp->nscount = 0;	hp->arcount = 0;	cp = buf + sizeof(HEADER);	buflen -= sizeof(HEADER);	dpp = dnptrs;	*dpp++ = buf;	*dpp++ = NULL;	lastdnptr = dnptrs + sizeof(dnptrs)/sizeof(dnptrs[0]);	/*	 * If the domain name contains no dots (single label), then	 * append the default domain name to the one given.	 */	if ((_res.options & RES_DEFNAMES) && dname != 0 && dname[0] != '\0' &&	    strchr(dname, '.') == NULL) {		if (!(_res.options & RES_INIT))			if (res_init() == -1)				return(-1);		if (_res.defdname[0] != '\0') {			(void)sprintf(dnbuf, "%s.%s", dname, _res.defdname);			dname = dnbuf;		}	}	/*	 * perform opcode specific processing	 */	switch (op) {	case QUERY:		buflen -= QFIXEDSZ;		if ((n = dn_comp(dname, cp, buflen, dnptrs, lastdnptr)) < 0)			return (-1);		cp += n;		buflen -= n;		putshort(type, cp);		cp += sizeof(u_short);		putshort(class, cp);		cp += sizeof(u_short);		hp->qdcount = htons(1);		if (op == QUERY || data == NULL)			break;		/*		 * Make an additional record for completion domain.		 */		buflen -= RRFIXEDSZ;		if ((n = dn_comp(data, cp, buflen, dnptrs, lastdnptr)) < 0)			return (-1);		cp += n;		buflen -= n;		putshort(T_NULL, cp);		cp += sizeof(u_short);		putshort(class, cp);		cp += sizeof(u_short);		putlong(0, cp);		cp += sizeof(u_long);		putshort(0, cp);		cp += sizeof(u_short);		hp->arcount = htons(1);		break;	case IQUERY:		/*		 * Initialize answer section		 */		if (buflen < 1 + RRFIXEDSZ + datalen)			return (-1);		*cp++ = '\0';	/* no domain name */		putshort(type, cp);		cp += sizeof(u_short);		putshort(class, cp);		cp += sizeof(u_short);		putlong(0, cp);		cp += sizeof(u_long);		putshort(datalen, cp);		cp += sizeof(u_short);		if (datalen) {			bcopy(data, cp, datalen);			cp += datalen;		}		hp->ancount = htons(1);		break;#ifdef ALLOW_UPDATES	/*	 * For UPDATEM/UPDATEMA, do UPDATED/UPDATEDA followed by UPDATEA	 * (Record to be modified is followed by its replacement in msg.)	 */	case UPDATEM:	case UPDATEMA:	case UPDATED:		/*		 * The res code for UPDATED and UPDATEDA is the same; user		 * calls them differently: specifies data for UPDATED; server		 * ignores data if specified for UPDATEDA.		 */	case UPDATEDA:		buflen -= RRFIXEDSZ + datalen;		if ((n = dn_comp(dname, cp, buflen, dnptrs, lastdnptr)) < 0)			return (-1);		cp += n;		putshort(type, cp);                cp += sizeof(u_short);                putshort(class, cp);                cp += sizeof(u_short);		putlong(0, cp);		cp += sizeof(u_long);		putshort(datalen, cp);                cp += sizeof(u_short);		if (datalen) {			bcopy(data, cp, datalen);			cp += datalen;		}		if ( (op == UPDATED) || (op == UPDATEDA) ) {			hp->ancount = htons(0);			break;		}		/* Else UPDATEM/UPDATEMA, so drop into code for UPDATEA */	case UPDATEA:	/* Add new resource record */		buflen -= RRFIXEDSZ + datalen;		if ((n = dn_comp(dname, cp, buflen, dnptrs, lastdnptr)) < 0)			return (-1);		cp += n;		putshort(newrr->r_type, cp);                cp += sizeof(u_short);                putshort(newrr->r_class, cp);                cp += sizeof(u_short);		putlong(0, cp);		cp += sizeof(u_long);		putshort(newrr->r_size, cp);                cp += sizeof(u_short);		if (newrr->r_size) {			bcopy(newrr->r_data, cp, newrr->r_size);			cp += newrr->r_size;		}		hp->ancount = htons(0);		break;#endif ALLOW_UPDATES	}	return (cp - buf);}	cp = reply_string;	oldintr = signal(SIGINT,cmdabort);	for (;;) {		dig = n = code = 0;		while ((c = s_fgetc(cin)) != '\012') {			if (c == IAC) {     /* handle telnet commands */				switch (c = s_fgetc(cin)) {				case WILL:				case WONT:					c = s_fgetc(cin);					s_fprintf(cout, "%c%c%c",IAC,DONT,c);					(void) s_fflush(cout);					break;				case DO:				case DONT:					c = s_fgetc(cin);					s_fprintf(cout, "%c%c%c",IAC,WONT,c);					(void) s_fflush(cout);					break;				default:					break;				}				continue;			}			dig++;			if (c == EOF) {				if (expecteof) {					(void) signal(SIGINT,oldintr);					code = 221;					return (0);				}				lostpeer();				if (verbose) {					printf("421 Service not available, remote server has closed connection\n");					(void) fflush(stdout);				}				code = 421;				return(4);			}			if (c != '\015' && (verbose > 0 ||			    (verbose > -1 && n == '5' && dig > 4))) {				if (proxflag &&				   (dig == 1 || dig == 5 && verbose == 0))					printf("%s:",hostname);				(void) putchar(c);			}			if (dig < 4 && isdigit(c))				code = code * 10 + (c - '0');			if (!pflag && code == 227)				pflag = 1;			if (dig > 4 && pflag == 1 && isdigit(c))				pflag = 2;			if (pflag == 2) {				if (c != '\015' && c != ')')					*pt++ = c;				else {					*pt = '\0';					pflag = 3;				}			}			if (dig == 4 && c == '-') {				if (continuation)					code = 0;				continuation++;			}			if (n == 0)				n = c;			*cp++ = c;		}		if (verbose > 0 || verbose > -1 && n == '5') {			if (c == '\012')				(void) putchar('\n');			else				(void) putchar(c);			(void) fflush (stdout);		}		if (continuation && code != originalcode) {			if (originalcode == 0)				originalcode = code;			continue;		}		*cp = '\0';		if (n != '1')			cpend = 0;		(void) signal(SIGINT,oldintr);		if (code == 421 || originalcode == 421)			lostpeer();		if (abrtflag && oldintr != cmdabort && oldintr != SIG_IGN)			(*oldintr)();		return (n - '0');	}}empty(mask, sec)	struct fd_set *mask;	int sec;{	struct timeval t;	t.tv_sec = (long) sec;	t.tv_usec = 0;	return( s_select(32, mask, (struct fd_set *) 0, (struct fd_set *) 0, &t));}jmp_buf	sendabort;abortsend(){	mflag = 0;	abrtflag = 0;	printf("\nsend aborted\n");	(void) fflush(stdout);	longjmp(sendabort, 1);}#define HASHBYTES 1024sendrequest(cmd, local, remote)	char *cmd, *local, *remote;{	FILE *fin, *dout = 0, *popen();	int (*closefunc)(), pclose(), fclose(), (*oldintr)(), (*oldintp)();	int abortsend();	char buf[BUFSIZ], *bufp;	long bytes = 0, hashbytes = HASHBYTES;	register int c, d;	struct stat st;	struct timeval start, stop;	char *mode;	if (proxy) {		proxtrans(cmd, local, remote);		return;	}	closefunc = NULL;	oldintr = NULL;	oldintp = NULL;	mode = "w";	if (setjmp(sendabort)) {		while (cpend) {			(void) getreply(0);		}		if (data >= 0) {			(void) s_close(data);			data = -1;		}		if (oldintr)			(void) signal(SIGINT,oldintr);		if (oldintp)			(void) signal(SIGPIPE,oldintp);		code = -1;		return;	}	oldintr = signal(SIGINT, abortsend);	if (strcmp(local, "-") == 0) {		fin = stdin;#ifdef MILLIGAN	} else if (*local == '|') {		oldintp = signal(SIGPIPE,SIG_IGN);		fin = popen(local + 1, "r");		if (fin == NULL) {			perror(local + 1);			(void) signal(SIGINT, oldintr);			(void) signal(SIGPIPE, oldintp);			code = -1;			return;		}		closefunc = pclose;#endif	} else {		fin = fopen(local, "r");		if (fin == NULL) {			perror(local);DebugStr("\popen failed");			(void) signal(SIGINT, oldintr);			code = -1;			return;		}		closefunc = fclose;#ifdef MILLIGAN		if (fstat(fileno(fin), &st) < 0 ||		    (st.st_mode&S_IFMT) != S_IFREG) {			fprintf(stdout, "%s: not a plain file.\n", local);			(void) signal(SIGINT, oldintr);			fclose(fin);			code = -1;			return;		}#endif MILLIGAN	}	if (initconn()) {		(void) signal(SIGINT, oldintr);		if (oldintp)			(void) signal(SIGPIPE, oldintp);		code = -1;		if (closefunc != NULL)			(*closefunc)(fin);		return;	}	if (setjmp(sendabort))		goto abort;	if (remote) {		if (command("%s %s", cmd, remote) != PRELIM) {			(void) signal(SIGINT, oldintr);			if (oldintp)				(void) signal(SIGPIPE, oldintp);			if (closefunc != NULL)				(*closefunc)(fin);			return;		}	} else		if (command("%s", cmd) != PRELIM) {			(void) signal(SIGINT, oldintr);			if (oldintp)				(void) signal(SIGPIPE, oldintp);			if (closefunc != NULL)				(*closefunc)(fin);			return;		}	dout = dataconn(mode);	if (dout == NULL)		goto abort;	(void) gettimeofday(&start, (struct timezone *)0);	oldintp = signal(SIGPIPE, SIG_IGN);	switch (type) {	case TYPE_I:	case TYPE_L:		errno = d = 0;		while ((c = read(fileno(fin), buf, sizeof (buf))) > 0) {			bytes += c;			for (bufp = buf; c > 0; c -= d, bufp += d)				if ((d = s_write(s_fileno(dout), bufp, c)) <= 0)					break;			if (hash) {				while (bytes >= hashbytes) {					(void) putchar('#');					hashbytes += HASHBYTES;				}				(void) fflush(stdout);			}		}		if (hash && bytes > 0) {			if (bytes < HASHBYTES)				(void) putchar('#');			(void) putchar('\n');			(void) fflush(stdout);		}		if (c < 0){			perror(local);DebugStr("\pc < 0");}		if (d <= 0) {			if (d == 0)				fprintf(stderr, "netout: write returned 0?\n");			else if (errno != EPIPE) 				perror("netout");			bytes = -1;		}		break;	case TYPE_A:		while ((c = getc(fin)) != EOF) {			if (c == '\n') {				while (hash && (bytes >= hashbytes)) {					(void) putchar('#');					(void) fflush(stdout);					hashbytes += HASHBYTES;				}				if (s_ferror(dout))					break;				(void) s_fputc('\015', dout);				c = '\012';				bytes++;			}			(void) s_fputc(c, dout);			bytes++;	/*		if (c == '\r') {			  	*/	/*		(void)	s_fputc('\0', dout);  /* this violates rfc */	/*			bytes++;				*/	/*		}                          			*/			}		if (hash) {			if (bytes < hashbytes)				(void) putchar('#');			(void) putchar('\n');			(void) fflush(stdout);		}		if (ferror(fin)){			perror(local);DebugStr("\pferror(fin)");}		if (s_ferror(dout)) {			if (errno != EPIPE)				perror("netout");			bytes = -1;		}		break;	}	(void) gettimeofday(&stop, (struct timezone *)0);	if (closefunc != NULL)		(*closefunc)(fin);	(void) s_fclose(dout);	(void) getreply(0);	(void) signal(SIGINT, oldintr);	if (oldintp)		(void) signal(SIGPIPE, oldintp);	if (bytes > 0)		ptransfer("sent", bytes, &start, &stop, local, remote);	return;abort:	(void) gettimeofday(&stop, (struct timezone *)0);	(void) signal(SIGINT, oldintr);	if (oldintp)		(void) signal(SIGPIPE, oldintp);	if (!cpend) {		code = -1;		return;	}	if (data >= 0) {		(void) s_close(data);		data = -1;	}	if (dout)		(void) s_fclose(dout);	(void) getreply(0);	code = -1;	if (closefunc != NULL && fin != NULL)		(*closefunc)(fin);	if (bytes > 0)		ptransfer("sent", bytes, &start, &stop, local, remote);}jmp_buf	recvabort;abortrecv(){	mflag = 0;	abrtflag = 0;	printf("\n");	(void) fflush(stdout);	longjmp(recvabort, 1);}recvrequest(cmd, local, remote, mode)	char *cmd, *local, *remote, *mode;{	FILE *fout, *din = 0, *popen();	int (*closefunc)(), pclose(), fclose(), (*oldintr)(), (*oldintp)(); 	int abortrecv(), oldverbose, oldtype = 0, is_retr, tcrflag, nfnd;	char *bufp, *gunique(), msg;	static char *buf;	static int bufsize;	long bytes = 0, hashbytes = HASHBYTES;	struct fd_set mask;	register int c, d;	struct timeval start, stop;	struct stat st;	extern char *malloc();	is_retr = strcmp(cmd, "RETR") == 0;	if (proxy && is_retr) {		proxtrans(cmd, local, remote);		return;	}	closefunc = NULL;	oldintr = NULL;	oldintp = NULL;	tcrflag = !crflag && is_retr;	if (setjmp(recvabort)) {		while (cpend) {			(void) getreply(0);		}		if (data >= 0) {			(void) s_close(data);			data = -1;		}		if (oldintr)			(void) signal(SIGINT, oldintr);		code = -1;		return;	}	oldintr = signal(SIGINT, abortrecv);	if (strcmp(local, "-") && *local != '|') {		if (access(local, 2) < 0) {			char *dir = strrchr(local, '/');			if (errno != ENOENT && errno != EACCES) {				perror(local);DebugStr("\perrno != ENOENT && errno != EACCES");				(void) signal(SIGINT, oldintr);				code = -1;				return;			}			if (dir != NULL)				*dir = 0;			d = access(dir ? local : ".", 2);			if (dir != NULL)				*dir = '/';			if (d < 0) {				perror(local);DebugStr("\pd < 0");				(void) signal(SIGINT, oldintr);				code = -1;				return;			}			if (!runique && errno == EACCES &&			    chmod(local, 0600) < 0) {				perror(local);DebugStr("\!runique && errno == EACCES && ...");				(void) signal(SIGINT, oldintr);				code = -1;				return;			}			if (runique && errno == EACCES &&			   (local = gunique(local)) == NULL) {				(void) signal(SIGINT, oldintr);				code = -1;				return;			}		}		else if (runique && (local = gunique(local)) == NULL) {			(void) signal(SIGINT, oldintr);			code = -1;			return;		}	}	if (initconn()) {		(void) signal(SIGINT, oldintr);		code = -1;		return;	}	if (setjmp(recvabort))		goto abort;	if (!is_retr) {		if (type != TYPE_A) {			oldtype = type;			oldverbose = verbose;			if (!debug)				verbose = 0;			setascii();			verbose = oldverbose;		}	}	if (remote) {		if (command("%s %s", cmd, remote) != PRELIM) {			(void) signal(SIGINT, oldintr);			if (oldtype) {				if (!debug)					verbose = 0;				switch (oldtype) {					case TYPE_I:						setbinary();						break;					case TYPE_E:						setebcdic();						break;					case TYPE_L:						settenex();						break;				}				verbose = oldverbose;			}			return;		}	} else {		if (command("%s", cmd) != PRELIM) {			(void) signal(SIGINT, oldintr);			if (oldtype) {				if (!debug)					verbose = 0;				switch (oldtype) {					case TYPE_I:						setbinary();						break;					case TYPE_E:						setebcdic();						break;					case TYPE_L:						settenex();						break;				}				verbose = oldverbose;			}			return;		}	}	din = dataconn("r");	if (din == NULL)		goto abort;	if (strcmp(local, "-") == 0) {		fout = stdout;#ifdef MILLIGAN	} else if (*local == '|') {		oldintp = signal(SIGPIPE, SIG_IGN);		fout = popen(local + 1, "w");		if (fout == NULL) {			perror(local+1);			goto abort;		}		closefunc = pclose;#endif	} else {		fout = fopen(local, mode);		if (fout == NULL) {			perror(local);			goto abort;		}		closefunc = fclose;	}#ifdef MILLIGAN	if (fstat(fileno(fout), &st) < 0 || st.st_blksize == 0)#endif MILLIGAN		st.st_blksize = BUFSIZ;	if (st.st_blksize > bufsize) {		if (buf)			(void) free(buf     L   L   2  .GetMyIPAddr.h   TEXTMPS  	dprintf.c   TEXTKAHL ÿÿÿÿ      TEXTKAHL ÿÿÿÿ                  ¡!½'    ~             .MacTCPCommonTypes.h   TEXTMPS  ÿü ý    S    Â       ~    U$@ U$@ 0–-            I  0Ï         KÀ        H 	Monaco ÊOï    Ä 
 $ 	 PÊ      < $Sý < $Sý¡!½à                L   L   2 &Ìj    2  MPSR   
íÿÿ     'P= c;			if (hash) {				while (bytes >= hashbytes) {					(void) putchar('#');					hashbytes += HASHBYTES;				}				(void) fflush(stdout);			}		}		if (hash && byte