unit ICStrH;interface{$ifc undefined THINK_Pascal}	uses		Types;{$endc}	type		lineIndex = integer;	function NewStrH: handle;	procedure ReinitStrH (h: handle);	function CountStrs (id: integer): lineIndex;	function CountStrsH (h: handle): lineIndex;	function GetIndStr (id: integer; index: lineIndex): str255;	function GetIndStrH (h: handle; index: lineIndex): str255;	procedure SetIndStr (id, index: lineIndex; s: str255);	procedure SetIndStrH (h: handle; index: lineIndex; s: str255);	procedure DelIndStr (id: integer; index: lineIndex);	procedure DelIndStrH (h: handle; index: lineIndex);	procedure InsIndString (id: integer; index: lineIndex; s: str255);	procedure InsIndStrH (h: handle; index: integer; s: str255);implementation{$ifc undefined THINK_Pascal}	uses		Memory, Resources, ToolUtils;{$endc}	type		indexPtr = ^lineIndex;		indexHandle = ^indexPtr;	function NewStrH: handle;	begin		NewStrH := NewHandleClear(SizeOf(lineIndex));	end;	procedure ReinitStrH (h: handle);	begin		SetHandleSize(h, SizeOf(lineIndex));		indexHandle(h)^^ := 0;	end;	function CountStrsH (h: handle): integer;	begin		CountStrsH := indexHandle(h)^^;	end;	function CountStrs (id: integer): lineIndex;		var			h: handle;	begin		h := GetResource('STR#', id);		CountStrs := indexHandle(h)^^;	end;	function GetIndStr (id: integer; index: lineIndex): str255;		var			s: str255;	begin		GetIndString(s, id, index);		GetIndStr := s;	end;	function GetIndStrH (h: handle; index: lineIndex): str255;		var			count, i: lineIndex;			s: str255;			ps: longInt;	begin		count := indexHandle(h)^^;		if (1 <= index) and (index <= count) then begin			ps := SizeOf(lineIndex);			for i := 1 to index - 1 do				ps := ps + BAND(ptr(ord(h^) + ps)^, $FF) + 1;			BlockMove(ptr(ord(h^) + ps), @s, BAND(ptr(ord(h^) + ps)^, $FF) + 1);		end		else			s := '';		GetIndStrH := s;	end;	procedure SetIndStrH (h: handle; index: lineIndex; s: str255);		var			count, i: lineIndex;			sz: longInt;			p: longInt;			err: longInt;			ps: longInt;	begin		count := indexHandle(h)^^;		sz := GetHandleSize(h);		if count < index then begin			SetHandleSize(h, sz + index - count);			for p := ord(h^) + sz to ord(h^) + sz + index - count - 1 do				ptr(p)^ := 0;			indexHandle(h)^^ := index;			count := index;		end;		ps := SizeOf(lineIndex);		for i := 1 to index - 1 do			ps := ps + BAND(ptr(ord(h^) + ps)^, $FF) + 1;		err := Munger(h, ps, nil, BAND(ptr(ord(h^) + ps)^, $FF) + 1, @s, length(s) + 1);	end;	procedure SetIndStr (id, index: lineIndex; s: str255);		var			h: handle;	begin		h := GetResource('STR#', id);		HNoPurge(h);		SetIndStrH(h, index, s);		HPurge(h);		ChangedResource(h);		WriteResource(h);	end;	procedure DelIndStrH (h: handle; index: integer);		var			count, i: lineIndex;			sz: longInt;			err: longInt;			ps: longInt;	begin		count := indexHandle(h)^^;		sz := GetHandleSize(h);		if count >= index then begin			ps := SizeOf(lineIndex);			for i := 1 to index - 1 do				ps := ps + BAND(ptr(ord(h^) + ps)^, $FF) + 1;			err := Munger(h, ps, nil, BAND(ptr(ord(h^) + ps)^, $FF) + 1, @err, 0); { @err is a safe, non nil addr }			indexHandle(h)^^ := count - 1;		end;	end;	procedure DelIndStr (id: integer; index: lineIndex);		var			h: handle;	begin		h := GetResource('STR#', id);		HNoPurge(h);		DelIndStrH(h, index);		HPurge(h);		ChangedResource(h);		WriteResource(h);	end;	procedure InsIndStrH (h: handle; index: integer; s: str255);		var			count, i: lineIndex;			err: longInt;			ps: longInt;			t: string[2];	begin		count := indexHandle(h)^^;		if count >= index then begin			ps := SizeOf(lineIndex);			for i := 1 to index - 1 do				ps := ps + BAND(ptr(ord(h^) + ps)^, $FF) + 1;			t := '';			err := Munger(h, ps, nil, 0, @t, length(t) + 1);			indexHandle(h)^^ := count + 1;		end;		SetIndStrH(h, index, s)	end;	procedure InsIndString (id: integer; index: lineIndex; s: str255);		var			h: handle;	begin		h := GetResource('STR#', id);		HNoPurge(h);		InsIndStrH(h, index, s);		HPurge(h);		ChangedResource(h);		WriteResource(h);	end;end.