#include <Memory.h>#include <OSUtils.h>#define kAppParmsSize 32long A5Size (void);/* prototype for routine in Runtime.o */void A5Init (Ptr myA5);/* prototype for routine in Runtime.o */pascal void MakeA5World (A5RefType *A5Ref) {	*A5Ref = NewHandle(A5Size());	if ((long)*A5Ref) {		HLock((Handle)*A5Ref);		A5Init((Ptr)( (long)**A5Ref + A5Size() - kAppParmsSize));		HUnlock((Handle)*A5Ref);	}}pascal long SetA5World (A5RefType A5Ref) {	HLock((Handle)A5Ref);	return SetA5( (long)*A5Ref + A5Size() - kAppParmsSize);}pascal void RestoreA5World (long oldA5, A5RefType A5Ref) {	if (SetA5(oldA5)) {}	/* side effect only */	HUnlock((Handle)A5Ref);}pascal void DisposeA5World (A5RefType A5Ref) {	DisposHandle((Handle)A5Ref);}pascal long OpenA5World (A5RefType *A5Ref) {	MakeA5World(A5Ref);	if ((long)*A5Ref) {		return SetA5World(*A5Ref);	} else {		return 0;	}}pascal void CloseA5World (long oldA5, A5RefType A5Ref) {	RestoreA5World(oldA5, A5Ref);	DisposeA5World(A5Ref);}of #define's that can be used with #ifdef's to do compile-time  checking on OS, COMPILER, and LANGUAGE settings... Makes cross-platform  compiles so much easier. Read the text for more detail.    NOTE: The current version of the file was compiled with no errors under   both MPW C 3.2.4 and Think C 5.0.4.  @End-Description.*//* Your basic Macintosh application include files */#include "XCONFIG.h"#include <QuickDraw.h>#include <Traps.h>#include <ToolUtils.h>#include <Desk.h>#include <Windows.h>#include <Types.h>#include <Memory.h>#include <Events.h>#include <OSEvents.h>#include <Fonts.h>#include <Menus.h>#include <Dialogs.h>#include <TextEdit.h>#include <Folders.h>#include <Packages.h>#ifdef COMPILER_MPW#include <Strings.h>#endif/* Every plug-in aware application  needs to add this header */#include "XPINCALL.h"/* Shared settings between MCaller.c and MCaller.r */#include "MCaller.h"#define	kMainWindow		128#define	kAbout			128#define	kSleep					20L#define	kMoveToFront		(WindowPtr) -1L#define	okButton				1Boolean		gDone;/* These settings are global. gHaveXPIN is a nicety so we don't have to   keep calling XPINCount everytime to see if any plug-ins were loaded.   The pluginMenu menu is created at runtime only if plug-ins are found.   Your application may just add items to an existing menu. The menu handle   has to be deallocated before leaving.   xpin is the most important item. You need one of these per type of plug-in.   The pointer to the structure is kept global. The actual structure is   allocated on the heap at runtime. It should be deallocated before leaving.*/Boolean		gHaveXPIN;MenuHandle	pluginMenu;XPIN		*xpin;/* Function prototypes */void		Initialize();void		SetupWindow();void		SetupMenubar();void		DoEventLoop();void		DoOneEvent(EventRecord *event);void		DoMouseDown(EventRecord *event);void		DoMenuChoice(long menuItem);void		DoAppleMenu(short item);void		DoFileMenu(short item);void		DoUpdate(EventRecord *event);void		DoAbout(void);/* Slight discrepancy between Think-C and MPW-C on the syntax for QuickDraw   globals. */#ifdef	COMPILER_THINK#define	QD(i)	(i)#endif#ifdef	COMPILER_MPW#define	QD(i)	(qd.i)#endif/* ********************************  Entry point ******************************** */int main(void){	gHaveXPIN = false;	// assume we don't have any plug-ins		Initialize();		// Initialize toolboxes and the XPIN	SetupWindow();		// Set up the main window	SetupMenubar();		// Set up the menu bar	DoEventLoop();		// go into endless loop until we quit/*    After the event loop returns (only when we've officially quit)   we check to see if any was created. If so, clean up before leaving */	if (gHaveXPIN) {		XPINDone(xpin);		DisposPtr((Ptr) xpin);		DisposeMenu(pluginMenu);	}}/* ********************************************************************  Toolbox Initializations *********************************************************************/void		Initialize(){XPINErr	status;		// Return status for XPIN	InitGraf(&QD(thePort));	InitFonts();	FlushEvents(everyEvent, 0);	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();	MaxApplZone();/*    Allocate the structure as a zeroed out pointer on the heap.   This should be done early in the program to avoid heap fragmentation.   There should be one structure per plug-in type supported.   NOTE: The filetype setting to XPINInit is passed as a null-terminated   string. Ordinarily, this is a four-byte character field. But we want   to be cross-platform compatible so we use pointers.   $HOME translates to the application's home directory.   $SYSTEM translates to the System Folder. */	xpin = (XPIN *) NewPtrClear(sizeof(XPIN));	status = XPINInit(xpin, "$HOME", "xPIN");	if (status != XPINOK) // Do error checking here...		return;	if (XPINCount(xpin) > 0)	// Did we get any?		gHaveXPIN = true;}/* ********************************************************************  No-nonesense Window setup *********************************************************************/void		SetupWindow(){WindowPtr	window;	window = GetNewWindow(kMainWindow, nil, kMoveToFront);	if (window == nil) {		// If we fail, there's no use continuing		SysBeep(10);		ExitToShell();	}		SetPort(window);	ShowWindow(window);}/* ********************************************************************  Setup the menubar + XPIN *********************************************************************/void		SetupMenubar(void){Handle		menuBar;MenuHandle	menu;long		xCount, i;char		*label;Str255		xName;	menuBar = GetNewMBar(128);	SetMenuBar(menuBar);	menu = GetMHandle(mApple);	AddResMenu(menu, 'DRVR');/* * Get the number of plug-ins found, if zero, don't add anything to * the menu bar. NOTE: XPINLabel returns a pointer to an internal * storage area, so you need to make sure you make a copy before * messing around with it. */	xCount = XPINCount(xpin); 	if (xCount > 0) {		pluginMenu = NewMenu(mPlugin, "\pPlug-in");		for (i = 0; i < xCount; i++) {					label = (char *) XPINLabel(xpin, i);			strcpy((char *) xName, label);			C2P(xName);			InsMenuItem(pluginMenu, xName, i+1);		}		InsertMenu(pluginMenu, 0) ;	}	DrawMenuBar();}/* ********************************************************************  The giant event loop *********************************************************************/void		DoEventLoop(){EventRecord	event;	gDone = false;	while (gDone == false) {		WaitNextEvent(everyEvent, &event, kSleep, nil);		DoOneEvent(&event);	}}/* ********************************************************************  Process on event at a time *********************************************************************/void		DoOneEvent(EventRecord *event){char	theChar;	switch(event->what) {		case mouseDown:			DoMouseDown(event);			break;		case keyDown:		case autoKey:			theChar = event->message & charCodeMask;			if ((event->modifiers & cmdKey) != 0)				DoMenuChoice(MenuKey(theChar));			break;		case updateEvt:			DoUpdate(event);			break;	}}/* ********************************************************************  Process all mousedown events *********************************************************************/void	DoMouseDown(EventRecord *event){WindowPtr	theWindow;short		thePart;long			menuChoice;	thePart = FindWindow(event->where, &theWindow);	switch(thePart) {		case inMenuBar:			menuChoice = MenuSelect(event->where);			DoMenuChoice(menuChoice);			break;		case inSysWindow:			SystemClick(event, theWindow);			break;		case inDrag:			DragWindow(theWindow, event->where, &QD(screenBits.bounds));			break;		case inGoAway:			gDone = true;			break;		}}/* ********************************************************************  Process all menu selection events *********************************************************************/void DoMenuChoice(long menuItem){short	menu;short	item;XBlock	xb;			// A single XBlock to pass things back and forthlong	xID;		// The XPIN index. NOTE: It's a longword.short	result;		// The result from the plug-in itself.XPINErr	status;		// The result from the XPINCall. Should be XPINOK.	if (menuItem != 0) {		menu = HiWord(menuItem);		item = LoWord(menuItem);				switch(menu) {			case mApple:				DoAppleMenu(item);				break;			case mFile:				DoFileMenu(item);				break;/* * NOTE: We don't distinguish between which plug-in we're going to call * so everyone gets the same stuff in the XBlock. A proper plug-in app * would set up a protocol for what to load into the XBlock for what * type of request... We also attach come up with a simplistic way of * translating from the menu item to the XPIN index. Since there's nothing * other than plug-in labels on this menu and we're just adding them in * order, we get away with just subtracting one from the menu item and * getting the index. A real app would be better off coming up with a * lookup table of some sort to go from the user-interface element ID * to the XPIN index... */			case mPlugin:				xID = (long) (item - 1);				XSETw(&xb, 0, 100);				// the xtension can get				XSETw(&xb, 1, 200);				// this through XGETw(xb, 0)				status = XPINCall(xpin, xID, &xb);	// call it				result = XGETSTATw(&xb);		// get the result				break;			}		HiliteMenu(0);	}}/* ********************************************************************  Process Apple Menu requests. *********************************************************************/void DoAppleMenu(short item){MenuHandle	appleMenu;Str255		daName;short		daNumber;	switch(item) {		case iAbout:			DoAbout();			break;		default:			appleMenu = GetMHandle(mApple);			GetItem(appleMenu, item, daName);			daNumber = OpenDeskAcc(daName);			break;		}}/* ********************************************************************  Handle File menu requests. *********************************************************************/void	DoFileMenu(short item){/*   We just handle Quit. It just sets the Done flag and returns.   This forces the event loop to break out and exit */ 	switch(item) {		case iQuit:			gDone = true;			break;		}}/* ********************************************************************  Miscellaneous update events inside the window *********************************************************************/void		DoUpdate(EventRecord *event){	// Do Window Update here}/* ********************************************************************  Do the credits *********************************************************************/void	DoAbout(){pascal Boolean MyDialogFilter(DialogPtr, EventRecord *, short *);short	itemHit;DialogPtr	myDlg;	myDlg = GetNewDialog(kAbout,0, kMoveToFront);	do {		ModalDialog( MyDialogFilter, &itemHit );		} while(itemHit != okButton);	DisposDialog( myDlg);}/* ********************************************************************  Handle the about dialog *********************************************************************/pascal Boolean MyDialogFilter(DialogPtr theDlg,EventRecord *theEvent,	short *itemHit ){	if ( theEvent->what != keyDown )		return(false);	switch ( (theEvent->message) & charCodeMask ) {		case 0x0d:	// Enter or Return 		case 0x03:		case 0x1b:			*itemHit = okButton;			return( true );			default:			return( false );	}}g you can define. Check XPINSHR.H for those reserved for internal use. You can add global actions every plug-in has to respond to in the file XPINOP.C. Current XOP_INIT and XOP_DONE are the only two. Each arg field and the status field is a union and can be accessed as either a byte, word, long, or pointer value. A set of C macros, XSET#, XGET#, XGETSTAT#, and XSETSTAT#  (where # is one of 'b', 'w', 'l', or 'p') are provided to simplify access to the XBlock values. They can be used by both the caller and plug-in. On the PC, the "p" value is a far pointer.Remember, it is your responsibility as the writer of the application to define what gets passed in args[0..4] and what action codes and status returns are supported. And after you decide, you should publish them so others can write plug-ins for your application too. I toyed with a lot of ways to save you this step. But short of a central parameter registry (i.e. me), or runtime parameter parsing (slow and not necessarily cross-platform portable), there is no easy way to do it and remain flexible. Remember though, plan ahead!At this point, some of you may be wondering if these plug-ins are compatible with other plug-ins (like Photoshop or HyperCard). Well, they're not. I looked carefully at the way these other ones were designed and decided they were each intended for very specific applications. What I wanted was much more general purpose. However, if you think about it, each application defines a way to associate plug-ins with an interface element (i.e. the Filters menu in PhotoShop). And there is a well-defined protocol between the caller and the plug-in and it's published. So the two main ingredients for plug-in nirvana are right here ready for you to use with very little thinking...The other important thing you should know about is that standlone CODE resources (Mac) and DLL's (Windows) each have restrictions on what can be done inside them. These aren't actually restrictions. More like rules. Or intense suggestions.  They have nothing to do with the way the toolkit is implemented. They just come with the territory. The restrictions usually don't get in the way, but when you step on them, your application will mysteriously barf and you will think of me as an enemy (rather than your best friend and someone who would never trash your house when you're out of town). The restrictions are further described in the Programmer's Guide. If you try doing something non-trivial, you should know about these restrictions. The truly daring will also read the References to further reading at the end. If you do, you'll be so much more impressed that some poor schmuck sat down and made plug-ins portable. Maybe you'll buy me a beer next time.What you should be getting as part of this toolkit is the documentation, source, and libraries for the toolkit, sample callers for Mac (or Windows) versions, and a couple of plug-ins that do pretty much nothing, but sufficiently illustrate that this isn't vaporware. This release of the Macintosh version is compatible with Think C 5.0, and MPW 3.2.x.  You get Think C libraries and project files and MPW makefiles. Just note that Think C uses A4-relative techniques for making standalone code resources, and MPW uses the A5-relative ones. Take your pick.The Windows version works with Microsoft C/C++ 7.0 and Borland C++ 3.1. Makefiles for both MSC and Borland, and Borland Windows IDE project files are included. I haven't tested against Visual C++ and Borland 4.0 but there should be no reason why they shouldn't work.Please note that the toolkit has only been tested against the compilers and versions noted. If you have different compilers or versions, I don't make any promises (it might work though). The Mac version requires System 7. The toolkit supports Aliases to plug-ins, FSSpec's, and the new file and folder searching routines; things that make life bucket-loads easier. If there is a huge hue and cry for System 6 compatibility, I'll immediately add that in (NOT!). Everyone I associate with socially runs System 7 though, so I may have to find new friends. The Windows version has only been tested under version 3.1. It may work under 3.0 and I don't think there are any 3.1 specific routines there. Try it out if you must. Again, everyone I know moved up to 3.1 a long time ago. The tester program ran under a pre-release vers     ”   ”   fÿÿÿÌÌ ÿÿÿÿ™™ ÿÿÿÿff ÿÿÿÿ33 ÿ	MCaller.c   TEXTKAHL   `      TEXTKAHL   `                  §¤[¨  .á  úÿÿ™™ff ÿÿ™™33 ÿÿ™™   ÿÿffÿÿ ÿÿffÌÌ ÿÿff™™ ÿÿffff ÿÿff33 ÿÿff   ÿÿ33ÿÿ ÿÿ33ÌÌ ÿÿ33™™ ÿÿ33ff ÿÿ3333 ÿÿ33   ÿÿ  ÿÿ ÿ   H 	Monaco                             8 †@ 8 †@§¥àß  -”  -”  +     8 †@ 8 †@  Á             
  %í`           &Xb N-´  xID     ”   ”   f [{„ü    f MPSR  BKPT   2DTVU   >íÿÿ     Uµ¸ðÿÿ   L    yFÿÿ   n    V°ÿÿ   |     library