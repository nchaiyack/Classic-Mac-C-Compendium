/* Stand-alone code modules which need to use global variables   may include the interfaces in this unit. Such code modules   must also be linked with Runtime.o and SAGlobals.o. */#include <Types.h>typedef Handle A5RefType;/* MakeA5World allocates space for an A5 world based on the  size of the global variables defined by the module and its  units. If sufficient space is not available, MakeA5World  returns NIL for A5Ref and further initialization is aborted. */pascal void MakeA5World (A5RefType *A5Ref);/* SetA5World locks down a previously-allocated handle containing   an A5 world and sets the A5 register appropriately. The return   value is the old value of A5 and the client should save it for   use by RestoreA5World. */pascal long SetA5World (A5RefType A5Ref);/* RestoreA5World restores A5 to its original value (which the   client should have saved) and unlocks the A5 world to avoid   heap fragmentation in cases where the world is used again. */pascal void RestoreA5World (long oldA5, A5RefType A5Ref);/* DisposeA5World simply disposes of the A5 world handle. */pascal void DisposeA5World (A5RefType A5Ref);/* OpenA5World combines MakeA5World and SetA5World for the majority   of cases in which these two routines are called consecutively. An   exception is when a single A5 world is invoked many times. In this   case, the world is only created once with MakeA5World and it is   invoked each time by SetA5World. Most developers will find it easier   just to call OpenA5World and CloseA5World at the end. If the memory   allocation request fails, OpenA5World returns NIL for A5Ref and zero   in the function result. */pascal long OpenA5World (A5RefType *A5Ref);/* CloseA5World is the dual of OpenA5World. It combines RestoreA5World   and DisposeA5World. Again, in certain cases it may be necessary to   call those two routines explicitly, but most of the time CloseA5World   is all that is required. */pascal void CloseA5World (long oldA5, A5RefType A5Ref);#if defined	(BuildLib)	#include "SAGlobals.inc1.c"#endifome compile-time portability mechanisms to help isolate system dependencies. The second goal was simplicity in the interface. The caller API consists of seven C-language functions that look and behave identically across all platforms.Before I get to how this was done, some examples are in order. Figure 1 shows a sample Macintosh caller program with no plug-ins present.		                                      Figure 1: Sample Caller Folder with no plug-ins present.Figure 2 shows what the menu-bar for the Sample Caller program looks like when run. Nothing spectacular there.		                             Figure 2: Sample Caller menubar with no plug-ins present.Figure 3 shows the same program with two plug-in files copied into its directory. The Sample Caller program is then invoked again.		                                      Figure 3: After copying two plug-ins into the folder.Figure 4 shows the same program. This time, it detected the presence of the plug-ins, obtained their labels (an internal value that has nothing to do with the filename) and added them to the menu bar. The user can now invoke each of these plug-ins as if they were integral parts of the original code. Adding this functionality to the Sample Caller program required about 30 extra lines of code, primarily having to do with handling the menu.		                                 Figure 4: The plug-ins are now available for use by the Sample Caller program.Figures 5-8 present the same scenario running under Windows. Figures 5 and 6 show  the directory for the Sample Caller as shown by the File Manager and a snapshot of the program running without any plug-ins in the directory. 		                           Figure 5: Directory with no plug-ins.		                           Figure 6: Sample Caller with no plug-ins.Figures 7 and 8 show the program after two plug-in files were copied into the directory and the program was restarted.		                              Figure 7: Directory with two plug-ins copied in.		                               Figure 8: The two plug-ins available at runtime. The source code for the plug-ins was directly copied from a Macintosh to a PC and recompiled. The platform-specific functions of the plug-in were isolated using the appropriate #ifdef's, but otherwise, they were built with no code modification. Figure 9 lists the code for the "Dialog" plug-in with the comments stripped out.#include "XPIN.h"#ifdef OS_MAC#include <Dialogs.h>#endifXPIN(xblk){int localVarsGoHere;DescribeXPIN(xblk, "Dialog","Description of Dialog", 1, 0);#ifdef OS_WIN      	MessageBox(NULL, "This is a sample dialog box...",					"Dialog Plug-in Message",		MB_ICONSTOP | MB_YESNO);#elif OS_MAC		ParamText("\pThis is a sample dialog box...", 				NIL, NIL, NIL);		Alert(128, NIL);#endif     	XSETSTATw(xblk, 0);	// Return 0 as statusEndXPIN();}Figure 9: Code listing for a sample plug-in.- The Caller APIThe toolkit defines only six functions for use of the caller:	XPINInit		Initializes internal data and searches the toolkit for 				plug-ins. Those found are asked to provide a label 				and a description. These are cached in the caller 				data space for quick access.	XPINCount	Returns the number of plug-ins found.	XPINLabel	Returns the label associated with a given plug-in.	XPINDesc		Returns the description string associated with a given 				plug-in. This could be used for an "About" message 				or a simple help screen.	XPINCall		Calls a single plug-in. A general purpose parameter				block is used to pass arguments to the plug-in.	XPINDone		Called before the program exits. The internal data 				structures are deallocated. Each plug-in is also sent 				a "done" message to allow it to deallocate any space 				it may have allocated. 				- Plug-in IdentificationPlug-ins are individual files which happen to contain code. Installing and removing them is a simple matter of moving files around, an act presumably mastered by most users. Plug-ins, therefore, have to be distinguished from other files in a directory. This is done by assigning a "type" to each plug-in. I decided to let the operating system help identify files of this type. This was not only faster, but simpler. On a Macintosh every file has a creator and a type associated with it. These values allow the Macintosh Finder to automatically find and launch a program when one of its datafiles is double-clicked. On the Macintosh all plug-ins of one category must have a given finder type. For example, all import filters may be of type 'impf'.There are routines in the Macintosh Toolbox that allow a directory to be scanned for all files of a given type, effectively performing a wildcard search.. A happy side-effect of this mechanism is that the Macintosh Finder assigns individual icons to each file type. So plug-ins can have icons that visually distinguish them from other files.On the PC, no such intrinsic type can be associated with a file. What you do have, however, is the three letter file extension. Many DOS programs, including the command processor use this file extension to locate special-use files (for example, COMMAND.COM allows files of type .EXE, .COM, and .BAT to be executed by simply typing the filename). Moreover, there are corresponding DOS functions that return files based on filename wildcards. You can, for example, look for all files with the same 3-letter extension (ie., 'PIN') using the pattern '*.PIN'.Since it is possible for a non-plug in file to be accidentally assigned a plug-in type value, the toolkit validates all files it locates to make sure they are legitimate plug-ins. The toolkit effectively ignores all "bad" plug-ins. The caller never sees them.The toolkit does not apply any architectural limits to the types and numbers of plug-ins a single program can handle. To stop runaway searches, the toolkit stops the directory search after 100 files, a constant defined in a header file. This limit could be easily updated or removed altogether. An application program can also support multiple plug-in types. Each type could be located in a different directory (or all together). The overhead for the plug-in structure is small. The main internal tracking structure takes about 120 bytes of space. Each plug-in located takes about 300 bytes. The number of internal structures is limited by available memory. The plug-in structure is allocated off the heap and released when XPINDone is called.- The Pathname DilemmaA problem in writing cross-platform software has to do with the way directory pathnames are identified under each operating system. For example, the directory name separator under DOS is the backslash character '\'; the Macintosh uses the colon ':', and Unix has the forward slash '/'. There are other syntactic and semantic differences in pathnames that go beyond the scope of this article. One option was to force the developer to make sure the right pathname was passed to the toolkit on each platform. I took this route. But it seemed like a cop-out to put all the burden on the developer. It turned out that under both operating systems, there are two "blessed" locations: the application's home directory, and the environment's "system" directory. On the Mac-OS, this is the System Folder. Under Windows, this is the directory in which Windows is installed. So the toolkit was extended to support two "aliases" as a replacement for the plug-in search path. The $HOME and $SYSTEM names are aliases that are replaced with absolute paths at runtime.  They can  be used on their own (for maximum portability), or incorporated into an absolute path (i.e. $HOME\PLUGIN\ or $HOME:PlugIn:). The other advantage of using these aliases is that the $HOME alias allows the user to freely move the entire application with plug-ins from one directory to the other and the $SYSTEM alias simplifies booting off different volumes. The application and its plug-ins can be located easily, since the aliases are resolved at runtime. - Passing ParametersThe toolkit takes care of all the background work finding plug-ins and invoking them. But the developer has a few more issues to consider. An application needs to be able to exchange information between itself and the plug-in. In the case of plug-ins, the compiler does not have the luxury of knowing what type of parameters are being passed around. In a static program, the compiler and linker know how many parameters of which type are to be exchanged between a program and a function. The compiler often takes care of all type casting and parameter conversion. Parameters are usually passed to a function using the stack. The compiler generates the instructions necessary to pass the right number of parameters onto the stack and to restore the stack after the function returns. The function being called expects the stack to be in a well-defined state. The only exception to this rule is the varargs mechanism first popularized under Unix. Despite its flexibility, I chose not to use this mechanism because of implementation discrepancies across platforms.In a dynamic situation like the one facing plug-ins, the compiler basically has no idea what it may encounter at runtime. The solution to this problem is the parameter block (called the XBlock in the toolkit). The number and type of parameters between the caller and the plug-in function are pre-defined. However, one of the parameters is a pointer to an XBlock structure. The caller is free to load anything it wants into the XBlock, as long as the plug-in is designed to expect the proper values in the right order. The alternative to using a parameter block was to devise a dynamic runtime parsing mechanism that supported a stream of variable length arguments, each identified by their data type and size. Despite its flexibility, I decided against this "parameter stream" approach due to its overhead. I will probably revisit the issue at some future time, but for now, the XBlock mechanism appears to be sufficient.  The XBlock is a fixed size block of arguments (the number of slots can be changed in a header file). Each slot can be either a byte, word, long, or a pointer (a far pointer under Windows). The values in the slots can be easily accessed through a series of XSET# and XGET# macros (where # is one of b, w, l, or p). Figure 10 shows the definition of the XBlock structure.#define	XBLOCK_MAXARGS		5union	Arg {		UPtr	p;    // Pointer		Ubyte	b;    // Byte		Uword	w;    // Word		Ulong	l;    // Longword		};typedef union Arg Arg;struct	XBlock {	Uword	action;			// action code (XOP)	Arg	args[XBLOCK_MAXARGS];	// array of args	Arg	status;			// result sent back from XPIN	};Figure 10: The XBlock structureThe XBlock also has space for an action code and a status value. The action code can be defined by the developer. It is most useful for defining behavior that is common to all plug-ins. Internally, the toolkit reserves two action codes to get the plug-ins to return their label and description fields (XOP_INIT), and to perform cleanup action (XOP_DONE). Other popular attempts at plug-ins either require fixed parameters (Adobe Photoshop), or the use of parameter blocks (Hypercard). Coming up with a flexible specification for the XBlock is one of the crucial tasks of application programmers who want to create plug-in aware programs. If not specified correctly, ill-defined plug-ins will instantly throw the main program into asphyxiating spasms. It behooves the wise programmer to define how the application intends to pass parameters to the plug-in and properly document it. The published specification can be used by enterprising third-parties to write undoubtedly amazing plug-ins.- TANSTAAFL (There Ain't No Such Thing As A Free Lunch)What I have been calling plug-ins are, in reality, standalone code resources under the Macintosh environment, and Dynamic Link Libraries (DLL) under Windows. I have just simplified their interfaces. Under the hood, however, they have to obey the rules and restrictions of their host operating system. These are not debilitating restrictions.However, if not properly observed, they will quickly block the oxygen supply to the application. The references list a number of publications on standalone code resources and DLL's. The prudent programmer should read them for details on the proper do's and don'ts. I will briefly summarize some of the more important concerns.The main thing to consider is that using plug-ins requires an understanding of how programs use memory, particularly in the form of the stack and the heap (it was illuminating to discover that Macintosh CODE resources and Windows DLL's had similar but opposite memory requirements--otherwise, they behaved very similarly. Who knows, maybe operating systems will someday merge into one giant MCP).Windows plug-ins (DLL's) have no stack of their own. When loaded, they share the stack of the calling application. This means that the plug-in should not assume the presence of a large amount of stack space. Whatever space the application started with minus what was used before invoking the plug-in is all that is left. If the plug-in accidentally exceeds the stack space, the heap will almost certainly become corrupted (gasp!). Allocating space on the heap, however, carries much less risk. The well-behaved plug-in should check the status returns from all memory request calls and handle errors gracefully. You should also be aware that Windows keeps only one copy of  a DLL in memory at any given time. This can cause prob eMPS ith st  #   File:       DLOGPIN.make#   Target:     DLOGPIN (a.k.a. Dialog Plug-in)#   Sources:    DLOGPIN.C XPINOP.C## NOTE: Change InputName to the name of your plug-in's filename (minus the # .C suffix). Change OutputPlugin to whatever you want to call it out the# other end... Change the ApplicationType to match your app's creator.# PluginType is the filetype of the plugin. It should match the type field# in XPINInit (if it is to be found).#InputName=DLOGPINOutputPlugin='Dialog Plug-in'ApplicationTy