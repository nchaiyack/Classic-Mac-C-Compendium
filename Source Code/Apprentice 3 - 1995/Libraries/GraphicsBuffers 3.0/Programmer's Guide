GraphicsBuffers Programmer's GuideGuide Version: 3.0Guide Date: June 1995Written by: Hiep DamThe GraphicsBuffers Programmer's Guide assumes you are familiar with GWorlds and their usage. If you're not familiar, please read Inside Macintosh: Imaging With QuickDraw. This guide is intended on describing how to use the GraphicsBuffers routines, not how they work; that's another guide altogether (which may be written in the future).In this guide, prototypes are provided for all GraphicsBuffers routines.  Where appropriate, there is additional information in the form of argument explanations, descriptions, and/or special considerations. With routines that I feel are self-explanatory,  I've either kept the documentation to a minimum or left it out altogether.- Maintenance Routines -NewGraphicsBufferÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑOSErr NewGraphicsBuffer(GraphicsBufferPtr *buffer, long pixelDepth, Rect *boundsRect, long flags, long cache);bufferA pointer to the GraphicsBuffer created by this routine. NewGraphicsBuffer will do all the memory allocation for you.pixelDepthIn almost all cases you should pass 0. This implies first setting the monitor of interest to the desired depth before calling NewGraphicsBuffer. Valid values in addition to 0 include: 1, 2, 4, 8, 16 and 32. (Note: currently the blitters support 4, 8 and 16 bit depths only).boundsRectThis is the boundary rectangle of the GraphicsBuffer. The rectangle should be in global coordinates.flagsUse the same constants as you would for GWorldFlags. Valid subset flags are: pixPurge, useTempMem, keepLocal, and noNewDevice. In most cases you would want to pass noNewDevice, except when creating 1-bit mask GraphicsBuffers; in this case pass 0 (no flags).cachePass true or false. This argument is defined as a long for long-word stack alignment.DESCRIPTIONUse this call to create a GraphicsBuffer. Since GraphicsBuffers allocates some memory via pointers, you should call this routine early on in the initialization of your program in order to decrease heap fragmentation.GraphicsBuffers are intended to be used mostly in games, so there is no need really to "lock" and "unlock" the pixels in the GraphicsBuffer (actually the GWorld in the GraphicsBuffer). Nor is there a need to "purge" or "unpurge" the pixels. The GraphicsBuffers and the GWorld it allocates are intended to stay resident for the duration of your program. Thus after allocating a private GWorld the GraphicsBuffer locks it down via a call to LockPixels. This keeps it locked; almost all the other GraphicsBuffer calls never use UnlockPixels (except for DisposeGraphicsBuffer and UpdateGraphicsBuffer). This should pose no problems 99% of the time, unless you need to dynamically create and dispose a lot of GraphicsBuffers during runtime. You might consider using UnlockGraphicsBuffer and LockGraphicsBuffer.UpdateGraphicsBufferÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑOSErr UpdateGraphicsBuffer(GraphicsBufferPtr buffer, long pixelDepth, Rect *boundsRect, long flags, long cache);SPECIAL CONSIDERATIONSThis routine works analogously to UpdateGWorld. However, argument "buffer" differs from UpdateGWorld's "offscreenGWorld" argument. With UpdateGWorld, you pass a pointer to your GWorldPtr; with UpdateGraphicsBuffer just pass a GraphicsBufferPtr, not a pointer to a GraphicsBufferPtr.In most cases you would want to change the depth of the monitor of interest first, and then pass a pixelDepth of 0 for optimum GraphicsBuffer and GWorld updating.DisposeGraphicsBufferÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑOSErr DisposeGraphicsBuffer(GraphicsBufferPtr buffer);Convert2GraphicsBufferÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑOSErr Convert2GraphicsBuffer(GraphicsBufferPtr *buffer, WindowPtr srcWind, Rect *bounds, long cache);DESCRIPTIONCopyGraphicsBuffer and all the related pixel-copying routines use a GraphicsBuffer as both source and destination. For copying between two GraphicsBuffers, there's no extra work involved. However, to copy from a GraphicsBuffer to the screen/window, you must first "convert" that window into a GraphicsBuffer via Convert2GraphicsBuffer. This call will encapsulate the window and monitor data into an "output" GraphicsBuffer.SPECIAL CONSIDERATIONSCopyGraphicsBuffer is smart enough to allow for an output GraphicsBuffer to be either source or destination.The blitter versions of CopyGraphics in general expect the destination to be either a normal GraphicsBuffer or an output GraphicsBuffer. However, the source should be a normal GraphicsBuffer only.SetGraphicsBufferÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid SetGraphicsBuffer(GraphicsBufferPtr buffer);DESCRIPTIONThis call works analogously to SetGWorld. Use this call prior to drawing to a GraphicsBuffer (i.e. using LineTo's, EraseRect, etc).SPECIAL CONSIDERATIONSThere is no analogous GraphicsBuffer routine to GetGWorld. Just use GetGWorld instead.LockGraphicsBufferÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑBoolean LockGraphicsBuffer(GraphicsBufferPtr buffer);SPECIAL CONSIDERATIONSIn almost all cases you will never need to use these calls (LockGraphicsBuffer and UnlockGraphicsBuffer). Upon creating a GraphicsBuffer, NewGraphicsBuffer locks down the pixmap in its private GWorld. The pixmap will stay locked for the duration of your program, or until you dispose of them. However, they're included here for completeness.UnlockGraphicsBufferÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid UnlockGraphicsBuffer(GraphicsBufferPtr buffer);- Straight (Direct) Pixel Copying Routines -Ê- Non-blitters -CopyGraphicsBufferÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid CopyGraphicsBuffer(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR);DESCRIPTIONThis is the GraphicsBuffer routine analogous to CopyBits (in fact it calls CopyBits). However you'll notice two differences right away: there are no arguments for transfer mode nor a mask region. CopyGraphicsBuffer uses a simple srcCopy transfer mode and passes nil to CopyBits.CopyGraphicsBuffer2WindowÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid CopyGraphicsBuffer2Window(GraphicsBufferPtr srcBuffer, WindowPtr destWind, Rect *srcR, Rect *destR);DESCRIPTIONThis call is very similar to CopyGraphicsBuffer, except the destination argument is an explicit window. Like CopyGraphicsBuffer, CopyGraphicsBuffer2Window in turn calls CopyBits with a transfer mode of srcCopy and a mask region set to nil.SPECIAL CONSIDERATIONSInstead of using this routine, it is recommended you create an output GraphicsBuffer via Convert2GraphicsBuffer and use CopyGraphicsBuffer instead. This way you can also use the blitter routines as well with the output GraphicsBuffer as the destination.CopyWindow2GraphicsBufferÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid CopyWindow2GraphicsBuffer(WindowPtr srcWind, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR);- Blitters -BlitGraphicsBuffer_16bitBlitGraphicsBuffer_8bitBlitGraphicsBuffer_4bitÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid BlitGraphicsBuffer_16bit(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR);void BlitGraphicsBuffer_8bit(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR);void BlitGraphicsBuffer_4bit(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR);DESCRIPTIONThese blitters do a straight pixel-per-pixel copy without any masking. SPECIAL CONSIDERATIONSThe 16-bit version requires that the width of your rectangle boundary be a multiple of 2 pixels: 2, 4, 16, 62, and so on. The 8-bit version requires the width be a multiple of 4 pixels, and the 4-bit version requires the width to be a multiple of 8 pixels.The source and destination rectangle boundaries need not be at the same location; they just need to be the same width and height.The 4-bit version also requires that the left coordinates of both the source and destination rectangle boundaries be even. Thus, the left side of both rectangles cannot be 1, 3, 7, 25, etc.If the destination GraphicsBuffer is an "output" GraphicsBuffer (i.e. window/monitor) then you need to hide the cursor via a call to HideCursor or ShieldCursor.- Masked Pixel Copying Routines -Note: in the example figure below, the bounding boxes are there only as a guide showing you the boundaries of the sprite; you would probably not want to include them in a real program.Ê¥ All the pixel blitting routines, both straight and mask blitters, assume the source GraphicsBuffer to be a normal GraphicsBuffer. The destination GraphicsBuffer may be either be a another standard GraphicsBuffer or an "output" GraphicsBuffer.¥ All the masked pixel copying routines (CopyBits, CopyMask, and blitters) use the same calling arguments:void pixelcopy(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR, Ptr mask);You might have to do some typecasting, but all the routines share a pointer type mask as the last argument. The GraphicsBuffer header file declares three function pointer types. CopyGraphicsBufferRegion expects a RgnHandle, so you must typecast it to a plain pointer (Ptr) type. Please look at the sample code to see how it's implemented.CopyGraphicsBufferRegionÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid CopyGraphicsBufferRegion(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR, RgnHandle maskRgn);DESCRIPTIONThis call is similar to CopyGraphicsBuffer, but here you can supply a standard region mask. Whatever is outside the region is masked out and not copied.CopyGraphicsBufferMaskÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid CopyGraphicsBufferMask(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR, GraphicsBufferPtr maskBuffer);DESCRIPTIONThis call is similar to CopyGraphicsBuffer, but here you can supply a mask GraphicsBuffer. This call uses CopyMask. As a rule, you should supply a 1-bit mask GraphicsBuffer, although deeper depths are allowable.SPECIAL CONSIDERATIONSIn designing your mask, black pixels denote the mask and white pixels denote the mask-out areas. Pixels in your source GraphicsBuffer corresponding to black pixels in the mask are copied; any other pixels are not. See the sample figure above...CopyGraphicsBufferTransparentÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid CopyGraphicsBufferTransparent(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR, GraphicsBufferPtr _notUsed);DESCRIPTIONThis routine is different from the other mask pixel copyers in that it doesn't use any mask(s) at all. As you can see from the prototype, the mask argument is ignored. The routine determines which pixels to copy by looking at their colors. For CopyGraphicsBufferTransparent, if the source pixel's color is the same as the background color of the destination GraphicsBuffer, it's not copied. By default, the background color of a GraphicsBuffer is white. Thus any pixels which are white in the source GraphicsBuffer will not be copied to the destination GraphicsBuffer.SPECIAL CONSIDERATIONS	Because white is the default mask-out color, you must use a color other than white if you want your sprite/image to have portions of "white" pixels that are copied and not masked out. This can be easily fixed with 8-bit or higher depths by using the closest color to white. As long as they're not white, these pixels will be copied. In most cases your eyes will still believe it's seeing white.BlitGraphicsBuffer_Mask8bitBlitGraphicsBuffer_Mask4bitÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid BlitGraphicsBuffer_Mask8bit(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR, GraphicsBufferPtr maskBuffer);void BlitGraphicsBuffer_Mask4bit(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR, GraphicsBufferPtr maskBuffer);DESCRIPTIONThese routines are also known as "deep mask blitters". This is to differentiate the masks used in these blitters with those used by CopyMask, which is usually 1-bit deep. As with all the other blitters, the source and destination GraphicsBuffers must be the same depth. In addition, the mask must be the same depth as the source and destination GraphicsBuffers as well, which is why they're called deep mask blitters.SPECIAL CONSIDERATIONSThe mask used in these blitters are the reverse of those used in CopyGraphicsBufferMask. That is, white pixels denote the mask and black pixels denote the masked-out areas. Pixels in the source image corresponding to white pixels are copied, those corresponding to black pixels are ignored and not copied.Note that it's very easy to use only one mask for both CopyGraphicsBufferMask and BlitGraphicsBuffer_Mask*Bit. Choose one mask method for one routine and use an InvertRect when using the other routine.The 8-bit version requires the width of the rectangle boundary be a multiple of 4 pixels; the 4-bit version requires it to be 8 pixels. In addition, the 4-bit version requires the left side of the rectangle boundary to be even.Due to the way pixel values are stored for direct color devices (16-bit and higher), a deep mask version for 16-bit is not available (nor to my knowledge, possible).BlitGraphicsBuffer_Transparent16bitBlitGraphicsBuffer_Transparent8bitÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid BlitGraphicsBuffer_Transparent8bit(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR, GraphicsBufferPtr _notUsed);void BlitGraphicsBuffer_Transparent16bit(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer, Rect *srcR, Rect *destR, GraphicsBufferPtr _notUsed);DESCRIPTIONThese blitters do not use masks. Their advantage lies in the fact that they're still much faster than CopyBits/CopyMask, while not incurring the memory overhead of requiring deep masks. The disadvantage is that they're slower than the deep mask blitters.You must design your sprites/images such that portions that you don't want copied must be white. Any colors other than white will be copied by the transparent blitters.Like all the other blitters of the same depth, the 8-bit blitter requires that the width of the rectangle boundary be a multiple of 4 pixels; the 16-bit version requires the width to be a multiple of 2 pixels.SPECIAL CONSIDERATIONSPlease read the special considerations for CopyGraphicsBufferTransparent as they apply to these transparent blitters as well.Due to the way pixels are stored in 4-bit depths, a transparent blitter is not available.- Miscellaneous -SetMonitorDepthÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑvoid SetMonitorDepth(GDHandle monitor, short depth, Boolean color);DESCRIPTIONThis routine is very simple to use. Simply pass the monitor you want to change the depth to, pass the depth, and whether you want to change to color or grayscale.