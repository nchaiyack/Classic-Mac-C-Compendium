//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D.cpp//|//| This implements the Object3D class.  An Object3D is a three-//| dimensional object.//|//| This code was created by Greg Ferrar, based on original code//| created by Jeff Palmer.  There are no restrictions on the use//| or distribution of this library, except that you may not//| restrict its use or distribution.  Any project which is//| created from this code, or any significant modification of//| this code, may be distributed in any way you choose; you may//| even sell it or its source code.  However, any limitations//| placed on the distribution or use of such a project or//| modification may not in any way limit the distribution or use//| of this original code.//|________________________________________________________________#include <string.h>#include <stdlib.h>#include <fstream.h>#include <math.h>#include "PtrList.hpp"#include "Light3D.hpp"#include "Vertex3D.hpp"#include "Vector3D.hpp"#include "Matrix3D.hpp"#include "Macros3D.h"#include "Window3D.h"#include "Scene3D.h"#include "View3D.hpp"#include "Poly3D.hpp"#include "Object3D.h"#include "Color3D.hpp"#include "Line3D.hpp"#include "Plane3D.hpp"#include "Sphere3D.hpp"#include "Util3D.h"#define PI                     3.141592653589793238462643383279502884197#define TWO_PI                 2*PI#define THETA_DIVISIONS        20#define THETA_INC              TWO_PI/THETA_DIVISIONS#define PHI_DIVISIONS          10#define PHI_INC                PI/PHI_DIVISIONS#define CIRCLE_APPROX_SEGMENTS 10#define CIRCLE_INC             TWO_PI/CIRCLE_APPROX_SEGMENTS//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::Copy//|//| Purpose: This methods makes this into a copy of the object entered//|//| Parameters: object: the object to make a copy of//|//| Created by Greg Ferrar, December 8, 1994//|//| Modified://|___________________________________________________________________void Object3D::Copy(Object3D& object){  // Loop through all vertices, copying them as we go  register int i;  for (i = 1; i <= object.vertices.NumElements(); i++)    {    // Get this vertex    Vertex3D *thisVertex = (Vertex3D *) vertices.Element(i);    // Create a new vertex, a copy of this one    Vertex3D *vertexCopy = new Vertex3D(*thisVertex);        // Add this vertex to the end of the vertices list    vertices.Append(vertexCopy);        }  // Loop through all polygons, copying them as we go  register Polygon3D *polygon = (Polygon3D *) object.polygons.GetFirst();  for (i = 1; i <= object.polygons.NumElements(); i++)    {    // Create a copy of this polygon    Polygon3D *polygonCopy = new Polygon3D(*polygon);        // Add this polygon to the end of the list    polygons.Append(polygonCopy);        // Go to the next polygon    polygon = (Polygon3D *) object.polygons.GetNext();    }  // Copy the data fields of the object  bound = object.bound;  shadingMethod = object.shadingMethod;  objectTransform = object.objectTransform;  normalsValid = object.normalsValid;  objectTransformsValid = object.objectTransformsValid;  totalTransformValid = object.totalTransformValid;  transformedVerticesValid = object.transformedVerticesValid;  backfacesValid = object.backfacesValid;  shadingValid = object.shadingValid;  boundValid = object.boundValid;  //  The new object is not attached to a scene yet  scene = NULL; }  //==== Object3D::Copy() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::Empty//|//| Purpose: This method clears the contents of an Object3D//|//| Parameters: none//|//| Created by Maarten Gribnau//|//| Modified://|___________________________________________________________________void Object3D::Empty(void){  // Loop through all vertices, deleting each one  register Vertex3D *vertex = (Vertex3D *) vertices.GetFirst();  while (vertex)    {    delete(vertex);    vertex = (Vertex3D *) vertices.GetNext();    }  // Loop through all polygons, deleting each one  register Polygon3D *polygon = (Polygon3D *) polygons.GetFirst();  while (polygon)    {    delete(polygon);    polygon = (Polygon3D *) polygons.GetNext();    }   // Clear the pointer lists  vertices.RemoveAll();  polygons.RemoveAll();    objectTransform.Identity();  //  We haven't computed anything yet, so everything's invalid  normalsValid = FALSE;  objectTransformsValid = FALSE;  totalTransformValid = FALSE;  transformedVerticesValid = FALSE;  backfacesValid = FALSE;  shadingValid = FALSE;  boundValid = FALSE;}  //==== Object3D::Empty ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::Object3D//|//| Purpose: This method creates an empty Object3D//|//| Parameters: none//|//| Created by Jeff Palmer//|//| Modified://|___________________________________________________________________Object3D::Object3D(void){  // Make this facet shaded by default  shadingMethod = shadeFaceted;  objectTransform.Identity();  Vector3D center (0., 0., 0.);  bound.Set(center, 0);  //  The new object is not attached to a scene yet  scene = NULL;   //  We haven't computed anything yet, so everything's invalid  normalsValid = FALSE;  objectTransformsValid = FALSE;  totalTransformValid = FALSE;  transformedVerticesValid = FALSE;  backfacesValid = FALSE;  shadingValid = FALSE;  boundValid = FALSE;}  //==== Object3D::Object3D() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::Object3D//|//| Purpose: This method creates an Object3D//|//| Parameters: pathname: name of the file to read this Object3D from//|             reverse:  True if we should reverse the order of//|                       polygon vertices//|//| Created by Jeff Palmer//|//| Modified://|___________________________________________________________________Object3D::Object3D(char *objPathname, int reverse){  ReadObjectFromFile(objPathname, reverse);	// Read in the object from the disk file  // Make this facet shaded by default  shadingMethod = shadeFaceted;  //  Not attached to a scene yet  scene = NULL;  //  We haven't computed anything yet, so everything's invalid  normalsValid = FALSE;  objectTransformsValid = FALSE;  totalTransformValid = FALSE;  transformedVerticesValid = FALSE;  backfacesValid = FALSE;  shadingValid = FALSE;  boundValid = FALSE;}  //==== Object3D::Object3D() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::Object3D//|//| Purpose: Copy constructor//|//| Parameters: object: the object to make a copy of//|//| Created by Greg Ferrar, December 8, 1994//|//| Modified://|___________________________________________________________________Object3D::Object3D(Object3D& object){  Copy(object);}  //==== Object3D::Object3D() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::Object3D//|//| Purpose: Copy constructor//|//| Parameters: object: the object to make a copy of//|//| Created by Greg Ferrar, December 8, 1994//|//| Modified://|___________________________________________________________________Object3D::Object3D(Object3D *object){  Copy(*object);}  //==== Object3D::Object3D() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::~Object3D//|//| Purpose: This method disposes of an Object3D//|//| Parameters: none//|//| Created by Jeff Palmer//|//| Modified: MAART: Moved code to Empty()//|___________________________________________________________________Object3D::~Object3D(void){  Empty();  }  //==== Object3D::~Object3D() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::operator =//|//| Purpose: This operator overwrites the contents of an Object3D//|          with the contents of another, making a copy of the other.//|//| Parameters: obj: the Object3D to assign to this Object3D//|             returns this Object3D//|//| Created by Jeff Palmer//|//| Modified://|   May 10, 1995 by Maarten Gribnau//|     use Empty method to clear contents//|___________________________________________________________________Object3D &Object3D::operator = (Object3D &object){  Empty();  Copy(object);  return *this;}  //==== Object3D::operator =====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| operator << for Object3D//|//| Purpose: This outputs an Object3D to an output stream//|//| Parameters: object: the object to output//|//| Created by Greg Ferrar, August 31, 1994//|//| Modifications://|________________________________________________________________________ostream &operator<<(ostream &out, const Object3D &object){//  o << "position: " << object.position << '\n';//  o << "heading: " << object.heading << '\n';//  o << "twist: " << object.twist << '\n';//  o << "scaleVector: " << object.cumulativeScale << '\n';  out << "shadingMethod: ";  if (object.shadingMethod == shadeWireframe)    out << "wireframe\n";  else if (object.shadingMethod == shadeFaceted)    out << "faceted\n";  else    out << "smooth\n";  out << "vertices: ";  int i;  for (i = 1; i <= object.vertices.NumElements(); i++)    out << *((Vector3D *) object.vertices.Element(i)) << ' ';  out << "\nPolygons:\n";  for (i = 1; i <= object.polygons.NumElements(); i++)    out << *((Polygon3D *) object.polygons.Element(i));  return out;}  //==== operator << for Object3D ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| operator <<//|//| Purpose: This procedure inputs an Object3D object from an//|          input stream//|//| Parameters: none//|//| Created by Greg Ferrar on August 29, 1994//|//| Modified//|________________________________________________________________istream &operator <<(istream &in, Object3D &object){//  char dummy[100];//  in >> dummy >> object.position;		  // read the position//  in >> dummy >> object.heading;		  // read the heading//  in >> dummy >> object.twist;			  // read the twist//  in >> dummy >> object.cumulativeScale;	  // read the scale vector  char shadingMethodString[20];  // Read the shading method  in >> shadingMethodString;  if (!strcmp(shadingMethodString, "wireframe"))    // Set the shading method to wireframe    object.shadingMethod =  shadeWireframe;  else if (!strcmp(shadingMethodString, "faceted"))    // Set the shading method to faceted    object.shadingMethod = shadeFaceted;  else    // Set the shading method to smooth    object.shadingMethod = shadeSmooth;  return in;}  //==== operator << for Object3D ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::ReadObjectFromFile//|//| Purpose: This method reads an Object3D from a text file//|//| Parameters: fileName: the file to read this Object3D from//|             reverse:  True if we should reverse the order of//|                       polygon vertices//|//| Created by Jeff Palmer//|//| Modified://|___________________________________________________________________int Object3D::ReadObjectFromFile(char *fileName, int reverse){   // This will read in the file format that I am using  //  // At this point, it is proprietary, but only because  // I have found nothing which supports the functionality  // that I am looking for (in terms of differentiation)  // between different polygon types and attributes, etc.  // I am still looking, as I would rather adhere to a   // pseudo-standard than be off in my own little world.  // Anyway, this is how things work now:  // 1 - Get the object name  // 2 - Get the number of vertices  // 3 - Read in the vertices which are "x y z"  // 4 - Read the number of polygons  // 5 - Read in each polygon type and create the  //     appropriate polygon  char objectName[40];  ifstream f(fileName);  int i;  int polyType;  f >> objectName;				      // Read the name of the object  int numVertices;  f >> numVertices;				      // Find the number of vertices  for (i = 1; i <= numVertices; i++)		      // Loop through all vertices in file    {    Vertex3D *vertex = new(Vertex3D);		      // Create a vertex    // MAART: Temporary: vertex->pos.ReadFromFile(f);		      // Read in the vertex position    vertices.Append(vertex);			      // Add this vertex to the list    }  // Read the polygons  // Each polygon begins with an integer which  // represents the type of poly it is.  // These are enums which are defined in  // Polygon3D.h  int numPolygons;  f >> numPolygons;				      // Find the number of polygons  for (i = 1; i <= numPolygons; i++)		      // Loop through all polygons in file    {        Polygon3D *polygon = new Polygon3D(this);	      // Create a new polygon    f >> polyType;				      // Read the polygon type    polygon->ReadPolygonFromFile(f, reverse);// Read polygon in from file    polygons.Append(polygon);			      // Add polygon to the polygons list    }//  Triangulate();				      // DEBUG  //  We need to compute the normals, the shading, backfaces, and bounding radius  //  for this object  transformedVerticesValid = FALSE;  normalsValid = FALSE;  backfacesValid = FALSE;  shadingValid = FALSE;  boundValid = FALSE;  return 1;}  //==== Object3D::ReadObjectFromFile() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::SetScene//|//| Purpose: This sets the scene this object belongs to.  This should//|          in general only be called by Scene3D methods.//|//| Parameters: theScene: the scene this object is now in//|//| Created by Jeff Palmer//|//| Modified://|___________________________________________________________________void Object3D::SetScene(Scene3D* theScene){  scene = theScene;    //  A new scene means a new view and new lights, so we need to  //  recompute the total transform, the backface, and the shading  totalTransformValid = FALSE;  transformedVerticesValid = FALSE;  backfacesValid = FALSE;  shadingValid = FALSE;}  //==== Object3D::SetScene = ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::CGetObjectTransform//|//| Purpose: This returns the transformation matrix for this Object3D//|//| Parameters: returns the transformation matrix for this Object3D//|//| Created by Maarten Gribnau//|//| Modified://|___________________________________________________________________Matrix3D& Object3D::CGetObjectTransform(void){  return objectTransform;}  //==== Object3D::CGetObjectTransform() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::GetObjectTransform//|//| Purpose: This returns the transformation matrix for this Object3D//|//| Parameters: returns the transformation matrix for this Object3D//|//| Created by Maarten Gribnau//|//| Modified://|___________________________________________________________________Matrix3D* Object3D::GetObjectTransform(void){  return &objectTransform;}  //==== Object3D::GetObjectTransform() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::SetShadingMethod//|//| Purpose: This sets the method used to shade this object//|//| Parameters: method: the new shading method//|//| Created by Greg Ferrar, August 3, 1994//|//| Modified://|  May 09, 1995 by Maarten Gribnau//|    updated for ShadingMethod typedef//|___________________________________________________________________void Object3D::SetShadingMethod(ShadingMethod newShadingMethod){  //  Change the shading method  shadingMethod = newShadingMethod;  //  The shading is no longer valid  shadingValid = FALSE;  }  //==== Object3D::SetShadingMethod() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::GetShadingMethod//|//| Purpose: This gets the method used to shade this object//|//| Parameters: returns the shading method//|//| Created by Greg Ferrar, August 3, 1994//|//| Modified://|  May 09, 1995 by Maarten Gribnau//|    updated for ShadingMethod typedef//|___________________________________________________________________ShadingMethod Object3D::GetShadingMethod(void){  return shadingMethod;}  //==== Object3D::GetShadingMethod() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::Triangulate//|//| Purpose: This method ensures that all polygons are triangles.//|          If any polygon is not a triangle, this method splits//|          it into two or more triangles.//|//| Parameters: none//|//| Created by Jeff Palmer//|//| Modified://|___________________________________________________________________void Object3D::Triangulate(void){  // Loop through all polygons  register i;  for (i = 1; i <= polygons.NumElements(); i++)    {    // Get this polygon    Polygon3D *polygon = (Polygon3D *) polygons.Element(i);    // If this is already a triangle, don't mess with it    if (polygon->GetVertices().NumElements() == 3)      continue;    // Remove this polygon from the polygons list.  Next polygon will    // still be at this index, since we just removed this one    polygons.Remove(i);    i--;        // Set one anchor to the one side of vertex 1    long anchor1 = 2;        // Set the another anchor to the other side of vertex 1    long anchor2 = polygon->GetVertices().NumElements();    // Build a triangle from vertex 1 and those on either side of it.    AddTriangle(*polygon, 1, anchor1, anchor2);    while (1)      {      // Advance the anchors      long nextAnchor1 = anchor1 + 1;      long nextAnchor2 = anchor2 - 1;      // Check if the anchors have met.      if (nextAnchor1 == nextAnchor2)        {        // Make one final triangle        AddTriangle(*polygon, anchor1, nextAnchor1, anchor2);                // Done with this polygon        break;        }	      // Check if the anchors have passed each other; if so, we're done now      else if (nextAnchor1 > nextAnchor2)        break;      else    // Anchors are still headed towards each other        {        // Make two more triangles to cover the parallelogram connecting        // anchor1, anchor2, nextAnchor1, and nextAnchor2.        AddTriangle(*polygon, anchor1, nextAnchor1, nextAnchor2);        AddTriangle(*polygon, anchor1, nextAnchor2, anchor2);        }      // Prepare for next step      anchor1 = nextAnchor1;      anchor2 = nextAnchor2;      }  // end while (1)    }  // end loop through all polygons  //  Eliminate any redudant vertices we may have created while doing this  EliminateRedundantVertices();  //  We need to compute the normals, shading, and backfacing for the new polygons  transformedVerticesValid = FALSE;  normalsValid = FALSE;  backfacesValid = FALSE;  shadingValid = FALSE;}  //==== Object3D::Triangulate() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::EliminateRedundantVertices//|//| Purpose: This method looks through the vertex list to see if there//|          are any repeated vertices.  If there are, it combines them//|          into a single vertex.//|//| Parameters: none//|//| Created by Greg Ferrar, October 19, 1994//|//| Modified://|___________________________________________________________________void Object3D::EliminateRedundantVertices(void){  int numVertices = (int) vertices.NumElements();  // This list will be built to contain all the unique vertices  // in the object  PtrList uniqueVertices;    //  Loop through all vertices, mapping each vertex to itself  register Vertex3D *vertex = (Vertex3D *) vertices.GetFirst();  while (vertex)    {    // Map this vertex to itself    vertex->uniqueEquivalent = vertex;        // Go to the next vertex    vertex = (Vertex3D *) vertices.GetNext();    }      // Loop through the vertices, looking for duplicates  register int vertexIndex = 1;  register int i;  for (vertexIndex = 1; vertexIndex <= vertices.NumElements(); vertexIndex++)    {    // Get this vertex    vertex = (Vertex3D *) vertices.Element(vertexIndex);        // Check if this vertex is unique (so far).  If it's now, then    // we will have mapped it to a unique alias of itself.    if (vertex->uniqueEquivalent != vertex)      continue;				   // Not unique    // Create new vertex at same position    Vertex3D *newVertex = new Vertex3D(vertex->pos);        // Add the new vertex to the unique vertices list    uniqueVertices.Append(newVertex);        // Map this vertex to the unique copy of it    vertex->uniqueEquivalent = newVertex;    // Loop through the remaining vertices, checking if any are    // the same as this vertex    for (i = vertexIndex + 1; i <= vertices.NumElements(); i++)      {      // Get this vertex      Vertex3D *vertexi = (Vertex3D *) vertices.Element(i);      // Remap vertexi to the new vertex if they are the same      if ((ABS(vertex->pos.X() - vertexi->pos.X()) < REAL_SMALLNUM) &&	      (ABS(vertex->pos.Y() - vertexi->pos.Y()) < REAL_SMALLNUM) &&	      (ABS(vertex->pos.Z() - vertexi->pos.Z()) < REAL_SMALLNUM))        vertexi->uniqueEquivalent = newVertex;      } // end for i (checking for duplicates of vertex)          }  // end for vertexIndex (checking each vertex)  // Loop through all polygons, and change their vertex pointers  // to point to the new unique versions  register Polygon3D *polygon = (Polygon3D *) polygons.GetFirst();  while (polygon)    {        // Loop through all vertices of this polygon.  Change each vertex    // pointer in the list to its unique equivalent    for (i = 1; i <= polygon->GetVertices().NumElements(); i++)      {      // Get the unique equivalent      vertex = ((Vertex3D *) polygon->GetVertices().Element(i))->uniqueEquivalent;            // Change the vertex to point to the unique equivalent      polygon->GetVertices().SetElement(i, vertex);            // Add this polygon to the polygons list for the unique equivalent      vertex->polygons.Append(polygon);      }                   // Go to next polygon    polygon = (Polygon3D *) polygons.GetNext();    }  // Loop through all original vertices, deleting each one  vertex = (Vertex3D *) vertices.GetFirst();  while (vertex)    {    // Delete this vertex from memory    delete vertex;        // Go to the next vertex    vertex = (Vertex3D *) vertices.GetNext();    }  // Clear the object's vertex list  vertices.RemoveAll();  // Add all the new unique vertices to the vertex list  vertex = (Vertex3D *) uniqueVertices.GetFirst();  while (vertex)    {    //  Add this unique vertex to the object vertex list    vertices.Append(vertex);        // Go to next vertex    vertex = (Vertex3D *) uniqueVertices.GetNext();    }}  //==== Object3D::EliminateRedundantVertices() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::ComputeBoundingSphere//|//| Purpose: This method find a bounding sphere for this Object3D//|//| Parameters: none//|//| Created by Jeff Palmer//|//| Modified://|   May 10, 1995 by Maarten Gribnau//|     updated for bounding sphere centered at (0, 0, 0)//|     updated for new Vector3D methods//|___________________________________________________________________void Object3D::ComputeBoundingSphere(void){  // Initialize max vector to include center (0, 0, 0)  Vector3D max (0., 0., 0.);  Real x, y, z;   // Loop through all vertices  register Vertex3D *vertex = (Vertex3D *) vertices.GetFirst();  while (vertex)    {        // If this vertex exceeds any of the current maxima or minima,    // remember the new maximum or mininum    x = vertex->pos.X();    x = ABS(x);    if (x > max.X())      max.SetX(x);    y = vertex->pos.Y();    y = ABS(y);    if (y > max.Y())      max.SetY(y);    z = vertex->pos.Z();    z = ABS(z);    if (z > max.Z())      max.SetZ(z);          // Go to next vertex    vertex = (Vertex3D *) vertices.GetNext();    }  // Now that we have the max vector the greatest distance between the  // center and any point on the object is the length of this vector  bound.SetRadius(max.Magnitude());  //  The bound is now valid  boundValid = TRUE;    }  //==== Object3D::ComputeBoundingSphere() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::ComputePolygonPlanes//|//| Purpose: This method computes the normals of all polygons in this//|          Object3D.//|//| Parameters: none//|//| Created by Jeff Palmer//|//| Modified://|  May 09, 1995 by Maarten Gribnau//|    Updated for plane equation in Polygon3D//|___________________________________________________________________void Object3D::ComputePolygonPlanes(void){  register Polygon3D *polygon = (Polygon3D *) polygons.GetFirst();  while (polygon)    {    // Find the plane equation for this polygom    polygon->ComputePlane();    // Go to next polygon    polygon = (Polygon3D *) polygons.GetNext();        }  //  Polygon normals are now valid  normalsValid = TRUE;}  //==== Object3D::ComputePolygonPlanes() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::ComputeTransformedVertices//|//| Purpose: This transforms all vertices of this object into//|          scene space.//|//| Parameters: none//|//| Created by Greg Ferrar, February 9, 1995//|//| Modified: //|   May 09, 1995 by Maarten Gribnau//|     updated for new Matrix3D methods//|___________________________________________________________________void Object3D::ComputeTransformedVertices(void){  // Transform the vertices from object space into screen space  register Vertex3D *vertex = (Vertex3D *) vertices.GetFirst();  while (vertex)    {    // Transform this vertex    vertex->transformedPos = vertex->pos * totalTransform;    // Apply perspective to the vertex, and map it into the screen window    scene->GetView()->ApplyPerspective(vertex->transformedPos);    // Go to next vertex    vertex = (Vertex3D *) vertices.GetNext();    	    }  //  The transformed vertices are now valid  transformedVerticesValid = TRUE;}	//==== Object3D::ComputeTransformedVertices() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::ComputeBackfaces//|//| Purpose: This marks all polygons in this object which are backfaces.//|//| Parameters: none//|//| Created by Greg Ferrar, February 7, 1995//|//| Modified://|________________________________________________________________void Object3D::ComputeBackfaces(void){  //  Transform the viewpoint to this object's space  Vector3D transformedViewpoint = scene->GetView()->viewpoint;  transformedViewpoint *= viewpointTransform;  //  Loop through all polygons of this object  register Polygon3D *polygon = (Polygon3D *) polygons.GetFirst();  while (polygon)    {    // Mark whether this polygon is a backface    polygon->CheckBackface(transformedViewpoint);        // Go to next polygon    polygon = (Polygon3D *) polygons.GetNext();    }  //  The backfaces are now valid  backfacesValid = TRUE;}  //==== Object3D::ComputeBackfaces() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::ComputeShading//|//| Purpose: This shades this object//|//| Parameters: none//|//| Created by Greg Ferrar, February 9, 1995//|//| Modified://|   May 01, 1995 by Maarten Gribnau//|     updated for light's updated TransformPos method//|   May 09, 1995 by Maarten Gribnau//|     updated for ShadingMethod typedef//|______________________________________________________________________void Object3D::ComputeShading(void){  //  Loop through all lights, transforming each on to the  //  appropriate position in this object's space.  register Light3D *light = (Light3D *) scene->lights.GetFirst();  while (light)    {    light->TransformPos(viewpointTransform);    light = (Light3D *) scene->lights.GetNext();    }      //  Loop through all polygons of this object, shading each one  register Polygon3D *polygon = (Polygon3D *) polygons.GetFirst();  while (polygon)    {    // Only shade polygons which are frontfaces    if (!polygon->IsBackface() || (shadingMethod == shadeSmooth))      {          // Start the color at the background (ambient) color.      Real red   = scene->ambientIntensity;      Real green = scene->ambientIntensity;      Real blue  = scene->ambientIntensity;      // Loop through all lights, applying each one to the polygon      light = (Light3D *) scene->lights.GetFirst();      while (light)        {              // Find dot product of normal with transformed light vector        Real dot = light->transformedPos.Dot(polygon->plane.Normal());        //Real dot = light->transformedPos.DotFixed(polygon->normal);          // Make faces dark when they are on the side of the object        // away from the light        if (dot < 0)          dot = 0;          // Find the color resulting from this light, and add it to total color	        red += light->CalculateFlatRedIntensity(polygon->color.r, dot);        green += light->CalculateFlatGreenIntensity(polygon->color.g, dot);        blue += light->CalculateFlatBlueIntensity(polygon->color.b, dot);                // Go to the next light        light = (Light3D *) scene->lights.GetNext();                }            // Truncate colors to full intensity      if (red > REAL_COLOR_MAX) red = REAL_COLOR_MAX;      if (green > REAL_COLOR_MAX) green = REAL_COLOR_MAX;      if (blue > REAL_COLOR_MAX) blue = REAL_COLOR_MAX;        // Save the shaded color      polygon->shadedColor.r = red;      polygon->shadedColor.g = green;      polygon->shadedColor.b = blue;      }  // end polygon loop      // Go to the next polygon    polygon = (Polygon3D *) polygons.GetNext();              }  //  end polygon loop  //  If we're using smooth shading, find the vertex colors  if (shadingMethod == shadeSmooth)    {    register Vertex3D *vertex = (Vertex3D *) vertices.GetFirst();    while (vertex)      {            //  Find the color of this vertex      vertex->EstimateColor();            // Go to the next vertex      vertex = (Vertex3D *) vertices.GetNext();            }    }  //  The shading is now valid  shadingValid = TRUE;}  //==== Scene3D::ComputeShading() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::ComputeTransforms//|//| Purpose: Computes the viewpoint transformation matrix from the//|          current object transformation.//|//| Parameters: none//|//| Created by Jeff Palmer//|//| Modified://|  May 01, 1995 by Maarten Gribnau//|    updated for new matrix based positioning//|___________________________________________________________________void Object3D::ComputeTransforms(void){  objectTransform.InvertTo(viewpointTransform);    // The object transforms are now valid  objectTransformsValid = TRUE;    // The total transform is no longer valid, since we've changed the object transform.  totalTransformValid = FALSE;    // The transformed vertices, shading, and backfaces are no longer valid  transformedVerticesValid = FALSE;  shadingValid = FALSE;  backfacesValid = FALSE;  }  //==== Object3D::ComputeTransforms() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::ComputeTotalTransform//|//| Purpose: This generates the transformation matrix which transforms//|          points from object space into screen space.//|//| Parameters: none//|//| Created by Greg Ferrar, February 7, 1995//|//| Modified://|___________________________________________________________________void Object3D::ComputeTotalTransform(void){  //  Compute the total transform  totalTransform = objectTransform * scene->GetView()->projectionTransform;  //  The total transform is now valid  totalTransformValid = TRUE;    //  The transformed vertices are no longer valid because the transform has changed  transformedVerticesValid = FALSE;    //  Backfaces are no longer valid because the orientation of the object  //  with respect to the viewpoint has changed  backfacesValid = FALSE;    //  We need to reshade because we didn't shade backfaces, and they may  //  be different now  shadingValid = FALSE;  }  //==== Object3D::ComputeTotalTransform() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::Update//|//| Purpose: This updates this Object3D//|//| Parameters: none//|//| Created by Maarten Gribnau, May 10, 1995//|//| Modified://|___________________________________________________________________void Object3D::Update(void){  // Compute the bounding sphere if we haven't yet  if (!boundValid)    ComputeBoundingSphere();  // If we need to recompute the object transforms, do it now  if (!objectTransformsValid)    ComputeTransforms();  // If we need to recompute the total transform, do it now  if (!totalTransformValid)    ComputeTotalTransform();  // If we need to recompute the polygon normals, do it now  if (!normalsValid)    ComputePolygonPlanes();  // If we need to recompute the backfaces, do it now  if (!backfacesValid)    ComputeBackfaces();  // If we need to reshade this object, do it now  if (!shadingValid)    ComputeShading();  // If we need to transform the vertices, do it now  if (!transformedVerticesValid)    ComputeTransformedVertices();  }    //==== Object3D::Update() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::TransformVerticesInPlace//|//| Purpose: this applies a transformation to all the vertices of this//|          object.  The transformed vertices replace the originals,//|          which are lost.//|//| Parameters: transformation: the transformation to apply//|//| Created by Greg Ferrar, July 26, 1994//|//| Modifications://|________________________________________________________________________void Object3D::TransformVerticesInPlace(Matrix3D& transformation){  //  Loop through all vertices  register Vertex3D *vertex = (Vertex3D *) vertices.GetFirst();  while (vertex)    {        // Transform this vertex    vertex->pos *= transformation;    // Go to next vertex    vertex = (Vertex3D *) vertices.GetNext();    	    }  //  This makes a lot of stuff invalid; make sure it  //  gets updated.  transformedVerticesValid = FALSE;  boundValid = FALSE;  normalsValid = FALSE;  shadingValid = FALSE;  backfacesValid = FALSE;}  //==== Object3D::TransformVerticesInPlace() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::AddTriangle//|//| Purpose: This method adds a triangle to this Object3D.//|//| Parameters: index: the indices of the triangle vertices//|//| Created by Greg Ferrar, August 9, 1994//|//| Modified://|___________________________________________________________________void Object3D::AddTriangle(Polygon3D &polygon,                           long index1,                           long index2,                           long index3){  // Find the actual vertices  Vertex3D *vertex1 = (Vertex3D *) polygon.GetVertices().Element(index1);  Vertex3D *vertex2 = (Vertex3D *) polygon.GetVertices().Element(index2);  Vertex3D *vertex3 = (Vertex3D *) polygon.GetVertices().Element(index3);  // Create a new triangular polygon  Polygon3D *triangle = new Polygon3D(this, vertex1, vertex2, vertex3);  // Add it to the polygons list  polygons.Append(triangle);  //  We need to recompute the normals, backfaces, shading, and  //  bounding sphere now that we have a new polygon  //  (COULD OPTIMIZE TO JUST RECOMPUTE THIS POLYGON).  transformedVerticesValid = FALSE;  normalsValid = FALSE;  backfacesValid = FALSE;  shadingValid = FALSE;  boundValid = FALSE;}  //==== Object3D::AddTriangle() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::AddTriangle//|//| Purpose: This method adds a triangle to this Object3D//|//| Parameters: v1, v2, v3: the vertices of the triangle//|//| Created by Greg Ferrar, October 9, 1994//|//| Modified://|___________________________________________________________________void Object3D::AddTriangle(const Vector3D& v1, const Vector3D& v2, const Vector3D& v3){  // Create a list to hold the vertices  PtrList vertexList;    // Create and append the three vertices for this triangle  // to the vertex list  vertexList.Append(new Vertex3D(v1));  vertexList.Append(new Vertex3D(v2));  vertexList.Append(new Vertex3D(v3));  // Add this triangle to the object  AddPolygon(vertexList);}  //==== AddTriangle() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::AddQuadrilateral//|//| Purpose: This method adds a triangle to this Object3D//|//| Parameters: v1, v2, v3, v4: the vertices of the quadrilateral//|//| Created by Greg Ferrar, October 17, 1994//|//| Modified://|___________________________________________________________________void Object3D::AddQuadrilateral(const Vector3D& v1, const Vector3D& v2,                                const Vector3D& v3, const Vector3D& v4){  // Create a list to hold the vertices  PtrList vertexList;    // Create and append the four vertices for this quadrilateral  // to the vertex list  vertexList.Append(new Vertex3D(v1));  vertexList.Append(new Vertex3D(v2));  vertexList.Append(new Vertex3D(v3));  vertexList.Append(new Vertex3D(v4));  // Add this triangle to the object  AddPolygon(vertexList);}  //==== AddQuadrilateral() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::AddPolygon//|//| Purpose: This method adds a polygon to this Object3D. It adds//|          the polygon vertices to the list of object vertices,//|          and then creates a new polygon with those vertices//|//| Parameters: polygonVertice: list of vertices//|//| Created by Greg Ferrar, October 9, 1994//|//| Modified://|___________________________________________________________________void Object3D::AddPolygon(PtrList& polygonVertices){  // Create a new Polygon3D  Polygon3D *polygon = new Polygon3D(this);    //  Loop through the vertices of the polygon  register Vertex3D *vertex = (Vertex3D *) polygonVertices.GetFirst();  while (vertex)    {        // Add this vertex to the object vertices list    vertices.Append(vertex);        // Add this vertex to the polygon    polygon->AddVertex(vertex);        // Go to the next polygon vertex    vertex = (Vertex3D *) polygonVertices.GetNext();    }      // Add this polygon to this object  polygons.Append(polygon);  //  We need to recompute the normals, backfaces, shading, and  //  bounding sphere now that we have a new polygon  //  (COULD OPTIMIZE TO JUST RECOMPUTE THIS POLYGON).  transformedVerticesValid = FALSE;  normalsValid = FALSE;  backfacesValid = FALSE;  shadingValid = FALSE;  boundValid = FALSE;}  //==== AddPolygon() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::AddPolyhedron//|//| Purpose: This method adds a polyhedron to this Object3D.  Faces//|          are represented as arrays of vertex numbers, terminated//|          by -1.  faces should be an array of pointer to such//|          arrays.//|//| Parameters: vertices:        the vertices//|             numFaces:        the number of faces//|             faceNumVertices: the number of vertices in each face//|             faces:           the faces//|//| Created by Greg Ferrar, October 9, 1994//|//| Modified://|___________________________________________________________________void Object3D::AddPolyhedron(Vector3D *vertices, int numFaces,			     int *faceNumVertices, int **faces){  //  *** THIS CODE IS UNTESTED ***  //  int i;  // Loop through all faces  for (i = 0; i < numFaces; i++)    {    // List to hold vertices    PtrList polygonVertices;    int j;        // Loop through all vertices in this face, and store each one in the array    for (j = 0; j < faceNumVertices[i]; j++)      polygonVertices.Append(new Vertex3D(vertices[faces[i][j]]));    // Add this polygon to the object    AddPolygon(polygonVertices);        // Empty vertices list    polygonVertices.RemoveAll();    }  // There may be some repeated vertices in the vertex list.  If so,  // this eliminates them.  EliminateRedundantVertices();}  //==== AddPolyhedron() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::AddSphere//|//| Purpose: This method adds a sphere to this Object3D//|//| Parameters: center: the center of the sphere//|             radius: the radius of the sphere//|//| Created by Greg Ferrar, October 9, 1994//|//| Modified://|___________________________________________________________________void Object3D::AddSphere(Vector3D *center, double radius){  static Vector3D point1, point2, point3, point4;  // The top and bottom of the sphere (which are cones) are made not  // of quadrilateral patches (like the rest) but of triangles.   // We generate these triangles first  double theta, phi;  register int i, j;  //  Walk around the sphere, drawing the polygons which touch the poles  for (theta = THETA_INC, i = 1; i <= THETA_DIVISIONS; theta += THETA_INC, i++)    {    // Generate one of the top triangles    point1.SetSpherical(radius, 0, PI, center);    point2.SetSpherical(radius, theta, PI - PHI_INC, center);    point3.SetSpherical(radius, theta - THETA_INC, PI - PHI_INC, center);    AddTriangle(point3, point2, point1);    // Generate one of the bottom triangles    point1.SetSpherical(radius, 0, 0, center);    point2.SetSpherical(radius, theta - THETA_INC, PHI_INC, center);    point3.SetSpherical(radius, theta, PHI_INC, center);    AddTriangle(point3, point2, point1);    }  // We now traverse the globe, generating a longitude/lattitude grid, and  // adding a quadrilateral for each square of the grid  for (phi = 2*PHI_INC, i = 2; i < PHI_DIVISIONS; phi += PHI_INC, i++)    for (theta = THETA_INC, j = 1; j <= THETA_DIVISIONS; theta += THETA_INC, j++)      {      // Add a quadrilateral      point1.SetSpherical(radius, theta, phi, center);      point2.SetSpherical(radius, theta, phi - PHI_INC, center);      point3.SetSpherical(radius, theta - THETA_INC, phi - PHI_INC, center);      point4.SetSpherical(radius, theta - THETA_INC, phi, center);      AddQuadrilateral(point4, point3, point2, point1);      }  // The algorithm used to generate the sphere generates four vertices  // in the vertex list for each actual vertex needed. Here we  // eliminate all redundant vertices.  EliminateRedundantVertices();}  //==== AddSphere() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::AddCylinder//|//| Purpose: This method adds a cylinder to this Object3D//|//| Parameters: top: the center of the top of the cylinder//|             bottom: the center of the bottom of the cylinder//|             radius: the radius of the cylinder//|//| Created by Greg Ferrar, October 9, 1994//|//| Modified://|___________________________________________________________________void Object3D::AddCylinder(Vector3D *top, Vector3D *bottom,                           Flag capTop, Flag capBottom, double radius){  // A cylinder is a cone with equal end radii  AddCone(top, bottom, capTop, capBottom, radius, radius);}  //==== AddCylinder() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::AddCone//|//| Purpose: This method adds a cone to this Object3D//|//| Parameters: top:          the center of the top of the cone//|             bottom:       the center of the bottom of the cone//|             topRadius:    the radius of the top of the cone//|             bottomRadius: the radius of the bottom of the cone//|//| Created by Greg Ferrar, October 9, 1994//|//| Modified://|  May 08, 1995 by Maarten Gribnau//|    updated for new Vector3D methods//|___________________________________________________________________void Object3D::AddCone(Vector3D *top, Vector3D *bottom,                       Flag capTop, Flag capBottom,                       double topRadius, double bottomRadius){  if (bottomRadius == 0)    {    if (topRadius == 0)      return;  //  degenerate    else      {      // Ensure that bottom is not a point reversing to make top a point      AddCone(bottom, top, capBottom, capTop, bottomRadius, topRadius);      return;      }    }  // Find the axis of the cone, top-to-bottom  Vector3D axis = *top - *bottom;    // Find an orthogonal basis which contains the normal.  The other two  // basis vectors will be used as the basis of the top and bottom  Vector3D b1, b2;  FindBasis(axis, b1, b2);  // Loop through all vertices of the approximating polygon  int i;  double angle;  for (i = 1, angle = CIRCLE_INC; i <= CIRCLE_APPROX_SEGMENTS; i++, angle += CIRCLE_INC)    {    // Find the corners of a strip of the cone.  This finds the    // corners as points on circles in the yz plane    Vector3D topDiscPoint1 = *top + b1 * DOUBLE_TO_REAL((topRadius * sin(angle - CIRCLE_INC))) +	                                b2 * DOUBLE_TO_REAL((topRadius * cos(angle - CIRCLE_INC)));    Vector3D topDiscPoint2 = *top + b1 * DOUBLE_TO_REAL((topRadius * sin(angle))) +                                    b2 * DOUBLE_TO_REAL((topRadius * cos(angle)));    Vector3D bottomDiscPoint1 = *bottom + b1 * DOUBLE_TO_REAL((bottomRadius * sin(angle - CIRCLE_INC))) +                                          b2 * DOUBLE_TO_REAL((bottomRadius * cos(angle - CIRCLE_INC)));    Vector3D bottomDiscPoint2 = *bottom + b1 * DOUBLE_TO_REAL((bottomRadius * sin(angle))) +                                          b2 * DOUBLE_TO_REAL((bottomRadius * cos(angle)));    // If the bottom is capped, add a "pie slice" to it    if (capBottom)      {      AddTriangle(*bottom, bottomDiscPoint1, bottomDiscPoint2);      // If the top is open, make the bottom opaque from both sides      if (!capTop)        AddTriangle(bottomDiscPoint1, *bottom, bottomDiscPoint2);      }    // If the cone tapers to a point at the top, use triangles    //  instead of rectangles to plate the sides    if (topRadius == 0)      {      AddTriangle(bottomDiscPoint1, *top, bottomDiscPoint2);            // If the bottom is open, make walls opaque both directions      if (!capBottom)        AddTriangle(bottomDiscPoint2, *top, bottomDiscPoint1);      }    else      {	      // If the top is capped, add a "pie slice" to it      if (capTop)        {        AddTriangle(topDiscPoint1, *top, topDiscPoint2);              // If the bottom is open, make the top opaque from both sides        if (!capBottom)          AddTriangle(*top, topDiscPoint1, topDiscPoint2);        }      // Add one rectangle plate to the side      AddQuadrilateral(bottomDiscPoint2, bottomDiscPoint1, topDiscPoint1, topDiscPoint2);      // If either side is open, make walls opaque in both directions      if ((!capTop) || (!capBottom))        AddQuadrilateral(topDiscPoint1, bottomDiscPoint1, bottomDiscPoint2, topDiscPoint2);      }    }  // The algorithm used to generate the cone generates more vertices in the vertex  // list than we actually need (some vertices are repeated).  Here we eliminate  // all redundant vertices.  EliminateRedundantVertices();}  //==== AddCone() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::AddDisc//|//| Purpose: This method adds a disc to this Object3D//|//| Parameters: center: the center of the disc//|             radius: the radius of the disc//|             normal: a vector normal to the disc//|//| Created by Greg Ferrar, October 9, 1994//|//| Modified://|___________________________________________________________________void Object3D::AddDisc(Vector3D *center, double radius, Vector3D *normal){  // Find an orthogonal basis which contains the normal. The other two  // basis vectors will be used as the basis of the disc  Vector3D b1, b2;  FindBasis(*normal, b1, b2);  //  These lists will be filled in to hold the disc vertices  PtrList topVertices, bottomVertices;  // Loop through all vertices of the approximating polygon  int i;  double angle;  Vector3D topPoint, bottomPoint;  for (i = 0, angle = 0; i <= CIRCLE_APPROX_SEGMENTS; i++, angle += CIRCLE_INC)                          {    // Generate and save a vertex of the top polygon    topPoint = *center + b1 * (radius * sin(angle)) + b2 * (radius * cos(angle));    Vertex3D *topVertex = new Vertex3D(topPoint);    topVertices.Append(topVertex);        // Generate and save a vertex of the bottom polygon     bottomPoint = *center + b1 * (-radius * sin(angle)) + b2 * (radius * cos(angle));    Vertex3D *bottomVertex = new Vertex3D(bottomPoint);    bottomVertices.Append(bottomVertex);    }      // Add the top polygon to the object  AddPolygon(topVertices);      // Add the bottom polygon to the object  AddPolygon(bottomVertices);  // The algorithm used to generate the disc generates more vertices in the vertex  // list than we actually need (some vertices are repeated).  Here we eliminate  // all redundant vertices.  EliminateRedundantVertices();  }  //==== AddDisc() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::AddBox//|//| Purpose: This method adds a box to this Object3D//|//| Parameters: oneCorner:      one corner of the box//|             oppositeCorner: the corner of the box opposite oneCorner//|//| Created by Greg Ferrar, October 9, 1994//|//| Modified://|   May 1, 1995 by Maarten Gribnau//|     updated for new vector methods and macro's//|___________________________________________________________________void Object3D::AddBox(Vector3D *top, Vector3D *bottom){  Vector3D min(MIN(top->XDouble(), bottom->XDouble()),               MIN(top->YDouble(), bottom->YDouble()),               MIN(top->ZDouble(), bottom->ZDouble()));  Vector3D max(MAX(top->XDouble(), bottom->XDouble()),               MAX(top->YDouble(), bottom->YDouble()),               MAX(top->ZDouble(), bottom->ZDouble()));  Vector3D point4, point3, point2, point1;  // Generate face where x = max.x  point4.SetX(max.X()); point4.SetY(max.Y()); point4.SetZ(max.Z());  point3.SetX(max.X()); point3.SetY(max.Y()); point3.SetZ(min.Z());  point2.SetX(max.X()); point2.SetY(min.Y()); point2.SetZ(min.Z());  point1.SetX(max.X()); point1.SetY(min.Y()); point1.SetZ(max.Z());  AddQuadrilateral(point1, point2, point3, point4);  // Generate face where x = min.x  point4.SetX(min.X()); point4.SetY(max.Y()); point4.SetZ(max.Z());  point3.SetX(min.X()); point3.SetY(min.Y()); point3.SetZ(max.Z());  point2.SetX(min.X()); point2.SetY(min.Y()); point2.SetZ(min.Z());  point1.SetX(min.X()); point1.SetY(max.Y()); point1.SetZ(min.Z());  AddQuadrilateral(point1, point2, point3, point4);  // Generate face where y = max.y  point4.SetX(max.X()); point4.SetY(max.Y()); point4.SetZ(max.Z());  point3.SetX(min.X()); point3.SetY(max.Y()); point3.SetZ(max.Z());  point2.SetX(min.X()); point2.SetY(max.Y()); point2.SetZ(min.Z());  point1.SetX(max.X()); point1.SetY(max.Y()); point1.SetZ(min.Z());  AddQuadrilateral(point1, point2, point3, point4);  // Generate face where y = min.y  point4.SetX(max.X()); point4.SetY(min.Y()); point4.SetZ(max.Z());  point3.SetX(max.X()); point3.SetY(min.Y()); point3.SetZ(min.Z());  point2.SetX(min.X()); point2.SetY(min.Y()); point2.SetZ(min.Z());  point1.SetX(min.X()); point1.SetY(min.Y()); point1.SetZ(max.Z());  AddQuadrilateral(point1, point2, point3, point4);  // Generate face where z = max.z  point4.SetX(max.X()); point4.SetY(max.Y()); point4.SetZ(max.Z());  point3.SetX(max.X()); point3.SetY(min.Y()); point3.SetZ(max.Z());  point2.SetX(min.X()); point2.SetY(min.Y()); point2.SetZ(max.Z());  point1.SetX(min.X()); point1.SetY(max.Y()); point1.SetZ(max.Z());  AddQuadrilateral(point1, point2, point3, point4);  // Generate face where z = min.z  point4.SetX(max.X()); point4.SetY(max.Y()); point4.SetZ(min.Z());  point3.SetX(min.X()); point3.SetY(max.Y()); point3.SetZ(min.Z());  point2.SetX(min.X()); point2.SetY(min.Y()); point2.SetZ(min.Z());  point1.SetX(max.X()); point1.SetY(min.Y()); point1.SetZ(min.Z());  AddQuadrilateral(point1, point2, point3, point4);  // The algorithm used to generate the box generates more vertices in  // the vertex list than we actually need (some vertices are repeated).  // Here we eliminate all redundant vertices.  EliminateRedundantVertices();    }  //==== AddBox() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::AddNURBS//|//| Purpose: This method adds a NURB surface to this Object3D//|//| Parameters: to be decided later//|//| Created by Greg Ferrar, October 9, 1994//|//| Modified://|___________________________________________________________________void Object3D::AddNURB(void){//  cerr << "NURBS are not yet implemented.\n";}  //==== AddNURB() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::Draw//|//| Purpose: This draws this Object3D//|//| Parameters: view: the view to draw in//|//| Created by Greg Ferrar, February 7, 1995//|//| Modified://|   May 10, 1995 by Maarten Gribnau//|     Moved update code to Update() method//|___________________________________________________________________void Object3D::Draw(View3D& view){  // Update the object if needed  Update();    // Loop through all the polygons  Polygon3D *polygon;  polygon = (Polygon3D *) polygons.GetFirst();  while (polygon)    {    // Draw this polygon if it's a frontface    if (!polygon->IsBackface())      polygon->Draw(view, shadingMethod);     // Go to the next polygon    polygon = (Polygon3D *) polygons.GetNext();    }}  //==== Object3D::Draw() ====//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Object3D::Intersect//|//| Purpose: Intersects line with this object, Intersections are//|          appended to the pointer list.//|          Line is transformed to object spacefor polygon intersection//|          intersections are transformed back to scene space.//|//| Parameters: line:          line to intersect with//|             intersections: list with intersections found//|             Returns TRUE if there was at least one intersection.//|//| Created by Maarten Gribnau//|//| Modified://|___________________________________________________________________Flag Object3D::Intersect(const Line3D &line, PtrList &intersections){  // Update the object if needed  Update();    Line3D objectLine (line);  objectLine.Transform(viewpointTransform);  if (!bound.Intersect(objectLine))    {    // Line does not intersect bounds, no use in going on    return FALSE;    }    // Loop through all the polygons  Flag       found = FALSE;  Vector3D   intersection;  Vector3D  *newIntersection;  Polygon3D *polygon;  polygon = (Polygon3D *) polygons.GetFirst();  while (polygon)    {    // Check for an intersection with this polygon    if (polygon->Intersect(objectLine, intersection))      {      // We have an intersection, store it in the list      newIntersection = new Vector3D (intersection);      *newIntersection *= objectTransform;      intersections.Append(newIntersection);      found = TRUE;      }    // Go to the next polygon    polygon = (Polygon3D *) polygons.GetNext();    }      return found;} !8a c  a 8    < H;  a L8  ; P8~  K9`    l;   p;    <   (     <  (    <  (    t;   =   r  =  ! r ] } B @!*  * KeA   \;  x? _ !  _  B @  c2`B*@!* KA  `b   @ $b  h8~  K`    hH  ( \ $   \ d8~  KY`    d @b;   |a <a 8  ; 8~  K`    ;   ;    <   (     <  (    <  (    ;   =   r  =  ! r ] } B @!*  * KA   ;  ? _ !  _  B @  c2`B*@!* KA  b   @ $b  8~  K	`    H  (  $    8~  K`     Da @  @ 8`H   a @ D  @ |cxH  8` 8!  |N  | a  !8a c  a 8    < H;  8c a L8  ; P8~  K`    l;   p;    <   (     <  (    <  (    t;   =   r  =  ! r ] } B @!*  * KA   \;  x? _ !  _  B @  c2`B*@!* KA  `b   @ $b  h8~  K`    hH  ( \ $   \ d8~  K`    d @b;   |a <8c a 8  ; 8~  KQ`    ;   ;    <   (     <  (    <  (    ;   =   r  =  ! r ] } B @!*  * K}A   ;  ? _ !  _  B @  c2`B*@!* K)A  b   @ $b  8~  K`    H  (  $    8~  Kq`     Da @  @ 8`H   a @ D  @ |cxH  8` 8!  |N  | a  ! X 8(  A 8  K`   8  H `   8! @ |N  | a  ! \ 8(  A $ <8  8c K`   8  H `   8! D |N  |a a     $ (!(8a <K`   8a XK`    bH a ;         0 ,  A  0  c  H  |cxa ta t(  A8 < a tK)`   ,  A; <8  K`   8` H `   ;   x(  A  8~  8c K`   (   8a t~  ;   ;  | | |  |  | 0 ,  A | 3c |   H  |cx;           ; X 8~  a  ,  @ L ;     |"T: 8e  H L`   ~ ~ ~ ~  Tc: |d~ a  d  } 8c } }  8c }  } 8c} |*x8  K`    8  H L%`      |cx  8`  a ;   0 ,  A  0  c  H  |cxa tK 8a Xa c   d  ,  @  8a XK`   8a <K`   H (8a XK`   a c   |  @ H  8d  a |8a X;          0 ,  A  0  c  H  |cxa 8|cxa a  ||  @ da 8c   T: |d).; X  0 ,  A  0  c  H  |cxa 8a 8c a K|*x8a XKI`   8a XK`   8a <K`   8! a |N  a  !a @a 8   D 8          8   8  $        8! (N  | !bK]`   8! 8 |N  | !bK`   8! 8 |N                                                                                              | a     $! `8 $KI`   8 0K=`   8 @K	`   8 pK	`   8` `H Y`   ;   8(  A  l h8~  K`   (   8`   d8  H u`   b   b     8  8! H |N  | a    ! T8 $Ky`   8 0Km`   8 @K	`   8 pK	`   a \ |cx  X8  H  `   b   b    8  8! < |N  | a !a Tc ,  A 4 T (  A $8   k  k  H 9A ,   T8 pK
e`   8 @K
Y`   8 0K]`   8 $KQ`   8! < |N  | a  !b   \  a 8c 8 |c#<C0lc a  ! (    a <c 8 |c#<C0lc a   ! (       A  \    H   \    b   \ <a `  8  K`   |cx 8! D |N  a !    a  N  a !    a   N  | a !a P 8d   P   d H eA 8! 8 |N  |H I a !T8 $; 88  8 0H 9`   ;   =   r  =  ! r ] } B @!*  * KA   Pb # , $   T8 $; X8  K`   ;      P       P      P   8a dK`   8a d;  8}  H `   ;  b  (        $  (  ,8a K1`   8~    b # 4 @  8~  a b # 4 A ; 88    8  #    r  8  # 8  C !   * K%A   b # 0 $ 8     P  r 8  a       P     8a K)`   8a 8a 8    $ 4 @ a b # 4 A P ! T r 8a 8a   P r      P    ;8  K`   T> < P 8  H Y`   8  88 8d8 848a dK$e`   8a4K$Q`   8adK$=`   88~ @H `   8 p8~ @K`   8` ~ 8` aaTc  K`   |  A 4aTc  K`   a|"x a8c aK8aK`   8adK`   8a4K`   8aK`   8a Ky`   8a Km`   8a dKa`   8a XKe`   8a 8KY`   8!<H 	 |N  | a    ! l8  KA`    h   p=   (     =  (    =  (   8! P |N  a !|cxa a , @ P  @  4|-.  < |"   8c |e a 8c a K8! N  | a ! !! |! HKEA   @! HKA   D|cxa 8 8, @   x|.  < @? 2  |~C a DB @!(  |#.?   |~C  2   *   |~ a 88c a 8Kp8! ` |N  a  !|cxa a , @ \  8|,.  4|5. |"  |"  |" c |f a 8c a Ka 48! N  a  !b  Da la 8  $  hD !$  (   a $8  a  8  &  ! $ ! (%  a 08  a ,8  &  $   4 a <8  a 88    $   r  $  *   @  a H8  a D $   r  $  *   L 8! PN  | a ! \    d H YA     d H AA  ,  @ 8  K`   8` a 8a \c  K5`    8|  A < 8a \  8e  K1`   a < \K`   a 88c a 8Ka \ 8d   \   d H A 8! D |N  |H ya a     $!aPc ,  @ aPK	`   ; 88  K`    \8  V<C0l   d! (  P>  (   `   h8   d8    >  $   l   p8  Z<C0l   l! (  >  (   t  |8   x8   >  $     8    `   ;  ; p             r  <  ! \ B@!*  *  < $ *      r  < ! \ B@!*  *  < ( *      r  < ! \ B@!*  *  < , *   ~ b C Xb # P; D8}  K`    ;  ; p             r  >  ! ^ B@!*  *  > $ *      r  > ! ^ B@!*  *  > ( *      r  > ! ^ B@!*  *  > , *   8  ; P8~  K`    ;   ;}    ;   (     ;  (    ;  (    ;  b  H ;|  ;   ;  ;  =r_~B*!*KA $                  a\a 8   8  ;   ;e  a         a  8  ;  ;d  a         8~  K	`   8}  K`   8  K`   8!8H a |N                                                                                                                                      a N  a N  |H  a     $! (A ,!H a H `    ! ( A   < a H Y`     (  !  r @8a DK`   bc  @ bc  @ $bc  Abc   @x < @ (   $ 8; D \8    T8      X8  $   (      P8  $   *   `   p8   h8    l8  $  (      d8  $  *   t 8  a 8   |  8  $  (     8   x$  *    bc  @ 0  ; D         H    ; D         H  Ta <b   @ @a @b   @ ,!  a H  `   !  a H  `   8a DK`   8! H U |N  a  a ,  A , A , A  H  (a #  H  $a # H  a # H  a #  N  a  !  a ,  A , A  , A (H  0  a   H     a  H    a  N  a    b d  a d a  d |cxd |cxd 8d  N  a b d  N  | a ! T  |c!Tc:H `     (   MPCC8   // -*- C++ -*-//|~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//| Light3D.in//|//| These are the inline methods of the Light3D class//|//| This code was created by Greg Ferrar, based on original code//| created by Jeff Palmer.  There are no restrictions on the use//| or distribution of this library, except that you may not//| restrict its use or distribution.  Any project which is//| created from this code, or any significant modification of//| this 