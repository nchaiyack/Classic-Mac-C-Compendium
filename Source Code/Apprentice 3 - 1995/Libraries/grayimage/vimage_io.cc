// This may look like C code, but it is really -*- C++ -*-/* ************************************************************************ * *			   Grayscale Image * *	  	Verify reading/writing of various image formats * * $Id: vimage_io.cc,v 1.1 1994/02/07 15:50:58 oleg Exp oleg $ * ************************************************************************ */#include "image.h"#include <builtin.h>#include <ostream.h>static IMAGE Test_image(16,32,8); //(256,512,8);					// Verify the pixels have the value					// that is expectedstatic void verify_pixel_value(const GRAY val){  register int i,j;  for(i=0; i<Test_image.q_nrows(); i++)    for(j=0; j<Test_image.q_ncols(); j++)      if( Test_image(i,j) != val )	_error("Pixel [%d,%d] has the value 0x%x different from expected 0x%x",	       i,j,Test_image(i,j),val);}static char * Image_file_name = "/tmp/aa";				// Write different kinds of image file formats				// into the file named Image_file_namestatic void write_xwd(const IMAGE& image){  image.write_xwd(Image_file_name);}static void write_pgm(const IMAGE& image){  image.write_pgm(Image_file_name);}static void write_tiff(const IMAGE& image){  image.write_tiff(Image_file_name);}static void write_default(const IMAGE& image){  image.write(Image_file_name);}				// Check reading and writing of a test imagestatic void test_image_io(void (*writer)(const IMAGE& image)){  cout << "\n\n\tWriting the Test_image and reading it back\n";  Test_image = 154; Test_image(0,0) = 0; Test_image(1,0) = 1;  writer(Test_image);  IMAGE read_back(Image_file_name,1);  Test_image -= read_back;  verify_pixel_value(0);  cout << "\nDone\n";}				// Test the I/O using a real imagestatic void real_image_io(const IMAGE& image, 			  void (*writer)(const IMAGE& image)){  cout << "\n\n\tWriting a real image and reading it back\n";    start_timer();  writer(image);  cout << "\nIt took " << return_elapsed_time(0)        << " sec to write the image\n";  start_timer();  IMAGE read_again_image(Image_file_name);  cout << "\nIt took " << return_elapsed_time(0)       << " sec to read the image\n";  assert( read_again_image == image );  cout << "\nDone\n";}main(void){  cout << "\n\nTest image input/output operations\n";  test_image_io(write_xwd);  test_image_io(write_pgm);  test_image_io(write_tiff);  test_image_io(write_default);  IMAGE image("pictures/512.xwd");  real_image_io(image,write_xwd);  real_image_io(image,write_pgm);  real_image_io(image,write_tiff);  real_image_io(image,write_default);}--------------------------------------------------------------------void DoTestBedDemo() {	SetupVariables();	/* Hide dialog */	HideWindow(gTestBed.testDlog);	ShowWindow(gTestBed.demoWindow);	SetPort(gTestBed.demoWindow);	FillRect(&gTestBed.demoWindow->portRect, &qd.black);		Animate();	HideWindow(gTestBed.demoWindow);	ShowWindow(gTestBed.testDlog);	SelIText(gTestBed.testDlog, kTestBedDlog_NumSpritesEditText,		0, 32767);} // END DoTestBedDemo// ---------------------------------------------------------------------------void HandleEvent(EventRecord *theEvent) {	switch(theEvent->what) {		case updateEvt:			LoadSprite(gTestBed.curSprite);			for (short i = kTestBedDlog_FrameBoxBegin; i <= kTestBedDlog_FrameBoxEnd; i++) {				FrameBorderDotted(gTestBed.testDlog, i);			}		break;				case keyDown: case autoKey:			char theKey = theEvent->message & charCodeMask;			//if (theKey == 13) DoTestBedDemo();		break;	} // END switch} // END HandleEvent// ---------------------------------------------------------------------------void InitToolBox() {	InitGraf((Ptr) &qd.thePort);	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(0L);	InitCursor();} // END InitToolBox-----------------------------OSErr DisposeGraphicsBuffer(GraphicsBufferPtr buffer) {	if (buffer == NULL)		return(paramErr);	/* Dispose contents of GraphicsBuffer */	if (buffer->gworld != NULL) {		UnlockPixels(buffer->pixmap);		DisposeGWorld(buffer->gworld);	}	if (buffer->rowAddressOffsets != NULL)		DisposePtr((Ptr)buffer->rowAddressOffsets);	/* Dispose GraphicsBuffer itself */	DisposePtr((Ptr)buffer);	return(noErr);} // END DisposeGraphicsBuffer// ---------------------------------------------------------------------------OSErr Convert2GraphicsBuffer(	GraphicsBufferPtr *buffer,	WindowPtr srcWind,	Rect *bounds,	long cache)/*	Bounds should be in global coordinates of the window.*/{		// Some local variables...	Rect testRect;	GraphicsBufferPtr gb;	GDHandle monitor;	long i;	*buffer = NULL;	gb = (GraphicsBufferPtr)NewPtrClear(sizeof(GraphicsBuffer));	if (gb == NULL)		return(MemError());		// We're creating a GraphicsBuffer from window and monitor data, so we		// won't need to create a gworld.	gb->gworld = NULL;	gb->window = srcWind;	gb->type = kVideoMemoryBuffer;	/* Given the global bounds of the window, find the corresponding	   monitor; we'll assume the window lies wholly inside one monitor	   only and it doesn't intersect any other monitors */	monitor = GetDeviceList();	while (monitor != NULL) {		testRect = (**monitor).gdRect;		if (SectRect(bounds, &testRect, &testRect))			break;		monitor = GetNextDevice(monitor);	}	if (monitor == NULL)		return(paramErr);	gb->pixmap = (**monitor).gdPMap;	gb->realRowBytes = (0x7FFF & (**(gb->pixmap)).rowBytes);	gb->rowBytesDiv4 = gb->realRowBytes >> 2;	gb->rowBytesDiv2 = gb->realRowBytes >> 1;	gb->videoBounds = (**monitor).gdRect; // or (**gb->pixmap).bounds;	gb->localBounds = *bounds;	gb->globBounds = *bounds;	OffsetRect(&gb->localBounds, -gb->localBounds.left,		-gb->localBounds.top);	if (gb->globBounds.left != 0 || gb->globBounds.top != 0)		gb->bufferFlushedTopLeft = false;	else		gb->bufferFlushedTopLeft = true;	if (cache) {		short bufferHeight = gb->videoBounds.bottom - gb->videoBounds.top;		gb->isCached = true;		// Create our pre-calculated "realRowBytes * vertCoords"		gb->rowAddressOffsets = (unsigned long*)NewPtr			(sizeof(unsigned long) * (bufferHeight));		if (gb->rowAddressOffsets == NULL)			return(MemError());			for (i = 0; i < bufferHeight; i++)			gb->rowAddressOffsets[i] = gb->realRowBytes * (long)i;	}	else {		gb->isCached = false;		gb->rowAddressOffsets = NULL;	}	*buffer = gb;	return(noErr);} // END Convert2GraphicsBuffer// ---------------------------------------------------------------------------void SetGraphicsBuffer(GraphicsBufferPtr buffer) {/*	You can call this yourself to remove the overhead...	Analogous to SetGWorld()*/	if (buffer->gworld != NULL)		SetGWorld(buffer->gworld, NULL);} // END SetGraphicsBuffer// ---------------------------------------------------------------------------Boolean LockGraphicsBuffer(GraphicsBufferPtr buffer) {/*	You can call this yourself to remove the overhead...	Analogous to LockGWorld()*/	if (buffer->gworld != NULL)		return(LockPixels(buffer->pixmap));	else		return(false);} // END LockGraphicsBuffer// ---------------------------------------------------------------------------void UnlockGraphicsBuffer(GraphicsBufferPtr buffer) {/*	You can call this yourself to remove the overhead...	Analogous to UnlockGWorld()*/	if (buffer->gworld != NULL)		UnlockPixels(buffer->pixmap);} // END UnlockGraphicsBuffer// ---------------------------------------------------------------------------void CopyGraphicsBuffer(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer,						Rect *srcR, Rect *destR) {	if (destBuffer->gworld != NULL)		// Just copying between pixmaps.		CopyBits((BitMap*)(*srcBuffer->pixmap),			(BitMap*)(*destBuffer->pixmap), srcR, destR, srcCopy, NULL);	else if (destBuffer->window != NULL)		// Copying to window		CopyBits((BitMap*)(*srcBuffer->pixmap),			(&destBuffer->window->portBits), srcR, destR, srcCopy, NULL);	else {		// do nothing...		SysBeep(10);	}} // END CopyGraphicsBuffervoid CopyGraphicsBuffer2Window(GraphicsBufferPtr srcBuffer, WindowPtr destWind,								Rect *srcR, Rect *destR) {	if (srcBuffer->gworld != NULL)		CopyBits((BitMap*)(*srcBuffer->pixmap), &destWind->portBits, 				 srcR, destR, srcCopy, NULL);	else if (srcBuffer->window != NULL)		CopyBits((&srcBuffer->window->portBits), &destWind->portBits, 				 srcR, destR, srcCopy, NULL);	else {		SysBeep(10);	}} // END CopyGraphicsBuffer2Windowvoid CopyWindow2GraphicsBuffer(WindowPtr srcWind, GraphicsBufferPtr destBuffer,								Rect *srcR, Rect *destR) {	if (destBuffer->gworld != NULL)		CopyBits(&srcWind->portBits, (BitMap*)(*destBuffer->pixmap), 				 srcR, destR, srcCopy, NULL);	else if (destBuffer->window != NULL)		CopyBits(&srcWind->portBits, (&destBuffer->window->portBits), 				 srcR, destR, srcCopy, NULL);	else {		SysBeep(10);	}} // END CopyWindow2GraphicsBuffer// ---------------------------------------------------------------------------void CopyGraphicsBufferRegion(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer,						  Rect *srcR, Rect *destR, RgnHandle maskRgn) {	if (destBuffer->gworld != NULL)		CopyBits((BitMap*)(*srcBuffer->pixmap),			(BitMap*)(*destBuffer->pixmap), srcR, destR, srcCopy, maskRgn);	else if (destBuffer->window != NULL)		CopyBits((BitMap*)(*srcBuffer->pixmap),			(&destBuffer->window->portBits), srcR, destR, srcCopy, maskRgn);} // END CopyGraphicsBufferRegionvoid CopyGraphicsBufferMask(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer,						Rect *srcR, Rect *destR, GraphicsBufferPtr maskBuffer) {	if (destBuffer->gworld != NULL)		CopyMask((BitMap*)(*srcBuffer->pixmap),			(BitMap*)(*maskBuffer->pixmap),			(BitMap*)(*destBuffer->pixmap), srcR, srcR, destR);	else if (destBuffer->window != NULL)		CopyMask((BitMap*)(*srcBuffer->pixmap),			(BitMap*)(*maskBuffer->pixmap),			(&destBuffer->window->portBits), srcR, srcR, destR);} // END CopyGraphicsBufferMaskvoid CopyGraphicsBufferTransparent(GraphicsBufferPtr srcBuffer, GraphicsBufferPtr destBuffer,						Rect *srcR, Rect *destR, GraphicsBufferPtr _notUsed) {	if (destBuffer->gworld != NULL)		// Just copying between pixmaps.		CopyBits((BitMap*)(*srcBuffer->pixmap),			(BitMap*)(*destBuffer->pixmap), srcR, destR, transparent, NULL);	else if (destBuffer->window != NULL)		// Copying to window		CopyBits((BitMap*)(*srcBuffer->pixmap),			(&destBuffer->window->portBits), srcR, destR, transparent, NULL);	else {		// do nothing...	}} // END CopyGraphicsBufferTransparent// ==========================================================================// Comment out if you don't need clipping (you're sure your rect won't// be out of bounds of the pixmap's boundaries; if so you'll be writing// to other areas of memory, a dangerous situation).#define BLIT_CLIPPING// Comment out if you're sure the rects you pass to the blitters// aren't empty. If they are, the blitters will loop forever!#define BLIT_CHECKEMPTY// ---------------------------------------------------------------------------#ifdef BLIT_CLIPPING	#define BlitClipBounds(srcRect, destRect, buffer)						\		if (destRect.top < buffer->localBounds.top) {						\			srcRect.top += buffer->localBounds.top - destRect.top;			\			destRect.top = buffer->localBounds.top;							\			if (destRect.top >= destRect.bottom) return;					\		}																	\		else if (destRect.bottom > buffer->localBounds.bottom) {			\			srcRect.bottom -= destRect.bottom - buffer->localBounds.bottom; \			destRect.bottom = buffer->localBounds.bottom;					\			if (destRect.bottom <= destRect.top) return;					\		}																	\		if (destRect.left < buffer->localBounds.left) {						\			srcRect.left += buffer->localBounds.left - destRect.left;		\			destRect.left = buffer->localBounds.left;						\			if (destRect.left >= destRect.right) return;					\		}																	\		else if (destRect.right > buffer->localBounds.right) {				\			srcRect.right -= destRect.right - buffer->localBounds.right;	\			destRect.right = buffer->localBounds.right;						\			if (destRect.right <= destRect.left ) return;					\		}																	\		if (buffer->type == kVideoMemoryBuffer && 							\			buffer->bufferFlushedTopLeft == false) { 						\			FastOffsetRect(destRect, buffer->globBounds.left, buffer->globBounds.top);\		}#else	#define BlitClipBounds(srcRect, destRect, buffer)#endif#ifdef BLIT_CHECKEMPTY	#define CheckEmptyRect(destRect)				\		if (destRect.right <= destRect.left ||		\			destRect.bottom <= destRect.top) return#else	#define CheckEmptyRect(destRect)#endif// ---------------------------------------------------------------------------void BlitGraphicsBuffer_8bit(	GraphicsBufferPtr srcBuffer,	GraphicsBufferPtr destBuffer,	Rect *srcR,	Rect *destR)/*	Assumes: 8 bit! (256 colors)			 srcR and destR are the same size, dimensions.			 Width is a multiple of 4 [pixels]!			 If destBuffer is to screen, make sure cursor is hidden!*/{	register long* srcMem;	register long* destMem;	register long rowsToCopy;	register unsigned long loopsPerRow;	register unsigned long srcRowOffset;	register unsigned long destRowOffset;	register long numRowLongs;	register unsigned long numBytesPerRow;	Rect srcRect = *srcR;	Rect destRect = *destR;		// Clip off edges so we don't draw more than we have to		// (besides, not doing so we might draw into other areas		// of memory, a big no-no).	BlitClipBounds(srcRect, destRect, destBuffer);	CheckEmptyRect(destRect);	{		SignedByte mmuMode;			// Calculate starting addresses		srcMem = (long*)(GetPixBaseAddr(srcBuffer->pixmap) +				(srcBuffer->rowAddressOffsets[srcRect.top]) + srcRect.left);		destMem = (long*)(GetPixBaseAddr(destBuffer->pixmap) +				(destBuffer->rowAddressOffsets[destRect.top]) + destRect.left);			// Calculate the nu     T   T   F0hoç@xĞŸVLPê }®oR@=@¶=FrTestBed.cpp   TEXTMMCC         TEXTMMCC                       «òª
  XĞ  šĞfÍYMX0R@=@y<.Ík2UBA,O0"<   €FÀ8 á©›0_@g@ gV@€ ”k Ò¸?. /<CNTL?, NºìêJŸWÀJ € ´V¸9™ ‹ìÌ" JWÁÀ€    H 	Monaco                             ( 
Â€ ( 
Â€¬r      µ           T   T   F §Î€ê    F MPSR   MWBB   íÿÿ        ğÿÿ   L     = (long)(numBytesPerRow & 3);			// Calculate the offset from one end of one row to			// beginning of next ro     )  )   p                      GameUtils.c++   TEXTMMCC  P    TEXTMMCC  P                    ¥2‡{  ;  ™                                                                                             Yô_8?å20        ©µ©&¦©m Lî   
Logger.pdº Hiep Dam 1 GameUtils.c++ ''  ''    t   .  .     —	GetRandom  u  €HideMenuBar  J  JPicToOffscreen   x  …SetToMenuRect  Ñ  ÜShowMenuBar   H 	Monaco                   MMCC       #include "TilePict.h"void TilePict(PicHandle thePicture, GWorldPtr destGWorld, Rect *gworldBounds){	Rect drawR, picR;	GWorldPtr saveWorld; GDHandle saveDev;	short destH, destV, hReps, vReps, patWidth, patHeight;	short i, j;	SignedByte picStatus;	GetGWorld(&saveWorld, &saveDev);	picStatus = HGetState((Handle)thePicture);	HLock((Handle)thePicture);	SetGWorld(destGWorld, nil);	picR = (**thePicture).picFrame;	OffsetRect(&picR, -picR.left, -picR.top);	DrawPicture(thePicture, &picR          â€      µ” ÅéIn Compressed  	TestBed.µ   MMPRMMCC           MMPRMMCC                       «ï}j    ô        ğ>
New Dialog     T¶}d©ÿíÿNº  Hn     
 PAúÿşÿüÿøX g  ` ?. 0.f  ng/.N\BgB§/ P ÿúp fB'ÿöÿô=@f l Ì ÿÿÿê         J  	Monaco                             ( 
Â€ ( 
Â€                    5 A0A1A2A3A4A5A6A7D0D1D2D3D4D5D6D7SP   (  ÿÿ        ÿÿ              x4     0       MacHeaders68K                            
  // This may look like C code, but it is really -*- C++ -*-/* ************************************************************************ * *			   Grayscale Image * *		Perform the median filtration of the image *	 * Algorithm *	For every pixel of the source image x[i,j] compute the *	pixel y[i,j] of the filtrated image according to the *	rule *	y[i,j] = median_of( x[i+p,j+l] ), p,l = -ws...0...ws * *	where 2*ws+1 is the window size. The median of the sequence *	is the middle term of the order