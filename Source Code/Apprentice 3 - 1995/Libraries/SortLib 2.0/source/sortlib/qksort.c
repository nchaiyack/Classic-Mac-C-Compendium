/* This implementation of the quick sort algorithm incorporates   several improvements over a simple recursive version. These   improvements should reduce execution time by around 20%-30%.   Call qksort in precisely the same way as the standard qsort.   It is identical to qsort except that it should be faster   than many implementations of qsort. Also, qksort is written   in ANSI C, and so should be portable to almost any ANSI   compiler.     Based on information in "Algorithms", by Robert Sedgewick,   2nd ed., Addison-Wesley, 1988, p. 116-126.     List of improvements to naive quick sort algorithm:     - Tail recursion eliminated.      - A private stack is used instead of recursive calls.     - The smaller subfile is sorted first (larger is placed on stack),   reducing the size of the stack.     - The last two improvements ensure that the stack will   never be larger than O(lg(n)), so we need very little extra   memory to execute the sort (naive quick sort could   use stack space O(n^2) in the worst case).     - Insertion sort on small subfiles (this alone speeds   execution by around 20%).     - Median of three selection of the partition item. This makes   worst case of O(n^2) very unlikely.      - Use of pointers, instead of array indexes. This eliminates   redundant multiplications to get an item. On the Macintosh   Plus this just about halved execution time.      - Partitioning is done within the same function, instead of   calling a separate partition function, thus reducing the number   of function calls.      - Careful coding of inner loops.      DISCUSSION OF FURTHER OPTIMIZATIONS      The greatest amount of time is spent calling the comparison   function, which is executed on average about 1.38*n*lg(n) times.   Since the comparison function accounts for 70%-90% of the   execution time, there isn't much point in trying to reduce the   amount of time spent in the quick sort function. For instance,   by writing the comparison function as a macro, execution time was   reduced by around 50%. Within the quick sort function, about   75% of the time is spent on the partitioning stage, so this   would be the part to optimize if additional gains were required.      One should concentrate on avoiding detrioration to the worst   case of O(n^2), and on reducing the complexity of the algorithm   (so that less instructions are required). It is also possible   to reduce the number of comparisons for very large files, so that   it approaches n*lg(n), but this seems fairly complicated (see   Knuth for a mention of this method).      In summary, it appears that this implemetation is near the   limits of efficiency possible with the quick sort algorithm   and the constraints of compatability with the standard library's   implementation. The user's effort would best be spent on   optimizing the comparison function and on finding a more   efficient sorting algorithm for a specific problem.   93/10/31 aih - changed so SMALL ranges from 1 up, rather than 2 up */#include <assert.h>#include <stddef.h>#include <limits.h>#include "sort_private.h"#define SMALL	(10) /* Size of smallest subfile sorted by quick sort. We sort			subfiles smaller than this by executing a single			insertion sort on the entire array after the			quick sort has finished. The value of SMALL should			be between 5 and 25. If SMALL is 1 then the insertion			sort has no effect, since the array will have been			sorted entirely by quick sort. SMALL must not be			smaller than 1. */#define MAXSTK	(sizeof(size_t) * CHAR_BIT)		     /* Size of quick sort's stack. The stack must be			at least lg(n), where n is the maximum number of			items to sort. This value should be equal to the			number of bits in the data type size_t. *//* macros for handling the pushdown stack */#define push(stk, n)	    ((*(stk)++ = (n)))#define pop(stk)	    (*--(stk))#define push2(stk, a, b)    ((void) (push((stk), (a)), push((stk), (b))))#define pop2(stk, a, b)	    ((void) (((a) = pop(stk)), ((b) = pop(stk))))#define stkempty(base, stk) ((base) >= (stk))/* execute the quick sort algorithm */void qksort(void *base, size_t nmemb, register size_t size,	    register int (*compar)(const void *, const void *)){  register char *middle;/* The middle item of the array. During partitioning  			   we compare left and right to this item. */  register char *left;	/* This starts at the left end of the subfile, and  			   during partioning advances to the right. When  			   left crosses right we've finished partitioning. */  register char *right; /* This starts at the right end of the subfile,  			   and during partitioning advances to the left.  			   When we've finished partitioning, it will be  			   equal to the item to split the array on. This  			   item is sometimes called the "pivot" item. */  char *last;		/* The last element in the subfile. Used for  			   finding the median of three items. */  char *lo;	        /* First item in the current subfile. */  char *hi;		/* Last item in the current subfile. */  char **top;		/* Top of stack of subfiles. */  char *stack[MAXSTK];  /* Storage for stack of subfiles. */  ptrdiff_t small;	/* Size, in bytes, of small subfiles to skip. */    assert(SMALL > 0);    lo = get(0);  hi = get(nmemb);  top = stack;  push2(top, lo, hi);  small = SMALL * size;    do {        /* Skip subfiles smaller than some limit. When we're done, we'll       run a single insertion sort on the entire array. */    if (hi - lo <= small) {      pop2(top, hi, lo);      continue;    }        /* Exchange the median of the left, right, and middle items with       the middle item. The purpose of this is to avoid worst case       performance, which could occur if the array was already sorted.       This code is somewhat ugly due to the use of macros. */    middle = lo + size * ((hi - lo) / (size<<1)); /* not same as lo+(hi-lo)/2 */    last = pred(hi);    if (COMPARE(lo, middle) <= 0) {      if (COMPARE(middle, last) <= 0) {	;      }      else if (COMPARE(lo, last) < 0) {	SWAP(last, middle, size);      }      else {	SWAP(lo, middle, size);      }    }    else if (COMPARE(lo, last) < 0) {      SWAP(lo, middle, size);    }    else if (COMPARE(last, middle) > 0) {      SWAP(last, middle, size);    }    	    /* Partition the array. This is the most time consuming       part of the algorithm, since, as you can see, we're       dealing with two while loops embedded in a for loop       which itself is embedded in a do...while loop. Anything       that can reduce the number of instructions in the       inner loops is desirable. */    left = pred(lo); right = hi;    for (;;) {      if (left < middle)	while (COMPARE(left = succ(left), middle) < 0)	  ;      if (right > middle)	while (COMPARE(right = pred(right), middle) > 0)	  ;      if (left >= right)	break;      SWAP(left, right, size);      if (left == middle)	middle = right;      else if (right == middle)	middle = left;    }        /* assert([lo...middle-1] <= middle <= [middle+1...hi]); */        /* Put larger subfile on stack and sort smaller subfile first.       Using a stack instead of recursive calls leads to       some improvement on most machines. By sorting       the smaller subfile first, we ensure that the stack       will never be larger than lg(n). We also only place       subfiles larger than SMALL items onto the stack. */    if (middle - lo > hi - middle - size) {      if (middle - lo > small)	push2(top, lo, middle);	        /* qksort(lo, middle) */      lo = succ(middle);		/* qksort(middle+1, hi) */    }    else {      if (hi - middle - size > small)	push2(top, succ(middle), hi);	/* qksort(middle+1, hi) */      hi = middle;		        /* qksort(lo, middle) */    }      } while (! stkempty(stack, top));    /* All items in the array are within SMALL items of their final position,     so insertion sort is the best way to complete the sort. */  _insort(base, nmemb, size, compar, SMALL);}LE LAW OR AGREED TO INWRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFYAND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOUFOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL ORCONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THELIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEINGRENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR AFAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IFSUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCHDAMAGES.		     END OF TERMS AND CONDITIONS     Appendix: How to Apply These Terms to Your New Libraries  If you develop a new library, and you want it to be of the greatestpossible use to the public, we recommend making it free software thateveryone can redistribute and change.  You can do so by permittingredistribution under these terms (or, alternatively, under the terms of theordinary General Public License).  To apply these terms, attach the following notices to the library.  It issafest to attach them to the start of each source file to most effectivelyconvey the exclusion of warranty; and each file should have at least the"copyright" line and a pointer to where the full notice is found.    <one line to give the library's name and a brief idea of what it does.>    Copyright (C) <year>  <name of author>    This library is free software; you can redistribute it and/or    modify it under the terms of the GNU Library General Public    License as published by the Free Software Foundation; either    version 2 of the License, or (at your option) any later version.    This library is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU    Library General Public License for more details.    You should have received a copy of the GNU Library General Public    License along with this library; if not, write to the Free    Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.Also add information on how to contact you by electronic and paper mail.You should also get your employer (if you work as a programmer) or yourschool, if any, to sign a "copyright disclaimer" for the library, ifnecessary.  Here is a sample; alter the names:  Yoyodyne, Inc., hereby disclaims all copyright interest in the  library `Frob' (a library for tweaking knobs) written by James Random Hacker.  <signature of Ty Coon>, 1 April 1990  Ty Coon, President of ViceThat's all there is to it!· ™≈     —                        § Q § Q •Q   •Q   •Q  •i ®}   ®}   ®}  ®ï L ®· | ©]   ©]   ©} x ®}   ©ı   ™  ™R * ™|   •Q     ™R   ™- % ™R   ™R   ™| I ™R   ™R   ™R   ™R   ™R   ™R    Sprite Animation Toolkitby Ingemar RagnemalmA programmer's library for making sprite-based animation (especially games).For Think Pascal ,Think C or CodeWarrior on the Macintosh.Copyright © 1992-1995 by Ingemar Ragnemalm. All rights reserved.Version 2.3b4 PJMMntents  program Assignment5;	uses{$ifc UNDEFINED THINK_PASCAL}		Types, QuickDraw, Menus, Windows, TextEdit, Fonts, Dialogs, Memory, OSEvents, {}{$endc}		SAT;	const		kSpeed = 5;	var		ignore: SpritePtr;		direction: Integer;		theSound: Handle;	procedure HandleSprite (me: SpritePtr);	begin		GetMouse(me^.position);	end; {HandleSprite}	procedure SetupSprite (me: SpritePtr);	begin		me^.task := @HandleSprite;		me^.face := SATGetFace(128);		SetRect(me^.hotRect, 0, 0, 32, 32);           2  ê	waitfor.h   TEXTMMCC   @README ser v3   TEXTttxt    @  TEXTttxt    @                  ¨"   õ  L         ñ t           ätcp low level                     ñAddressXlation.hd   TEXTMPS  ˇˇˇˇ    ó    Ë       ö   †U                                2 5h‹    2  styl   
 Äˇˇ     5‹  SpritePtr);	begin		if him^.task = @HandleSprite then {Chack what we hit!}			begin				me^.task := nil;				ignore := SATNewSprite(-1, 0, SATRand(gSAT.offSizeV), @SetupTarget);{We could also r     v   v   Rq¶uñÖáïï }•ÜÖáëLwg vföu•îóvñvïip.cÅ   TEXTMMCC ˇˇˇˇ    Hj    TEXTMMCC ˇˇˇˇ                  ™Ç‡†  W8  »ßÜáw¿÷Ägxw†Zwvs∂áñfávÖá02 JxfvwáÜxvvÜ•gówá  ávfYgYwjeÜxîwàwx√ÜÜvà#váÜ  ñwwv  Ω ÄñÖïÜáuàwáWxvÜvñO 	áÜvwÜxxW@Ö•PÜÖÜS òx∞    R ﬂ/ P  ›=  >             H 	Monaco                             k 	‹| k 	‹|´ÚyŒ  ?  ?               v   v   R V¶Hí    R MPSR  MWBB   *ˇˇ        Ìˇˇ   "    ˇˇ   n    re(false, kVPositionSort, kForwardCo lMMCCn, 32)  /* * time.h * * unixlike time stuff * */#ifndef __IPTIMEH__#define __IPTIMEH__struct timeval {     long  tv_sec;       /* seconds since Jan. 1, 1970 */     long  tv_usec;      /* and microseconds */};struct timezone {        int             tz_minuteswest; /* minutes west of Greenwich */        int             tz_dsttime;     /* type of dst correction */};#endif	/* __IPTIMEH__ */ animations on the Macintosh, especially arcade games with animation over a background. Since the Mac does not have any hardware sMMCCes, th  /* 		File:		DNR.c 		Contains:	DNR library for MPW  	Copyright:	© 1989-1995 by Apple Computer, Inc., all rights reserved	Version:	Technology:			Networking				Package:			Use with MacTCP 2.0.6 and the Universal									Interfaces 2.1b1				Change History (most recent first):		<3>	 1/23/95	rrk  	implemented use of universal procptrs		 						Changed selector name HINFO to HXINFO		 						due to conflict of name in MacTCP header		 						Removed u eMMCCTrapAv  cool        ˙     P      ò  0  Lib                                       0  (Src                                      0  (rsrc                                           ˇˇ   i    Project Version  N}R¿      R†R¿     O@N}   J  	MonR†                   ` 
 p d               ANSI (2i) C.68K.Lib                            û          ˝–      p†             ñ ò                  dnr.c                                          ´ï¡¿   ´ï¡¿   #´ï¡¿   "´ª˛y     ïRSED $´ï¡¿       Á  Á   ¸ Û}/MDayd.m68k.rsrc   rsrcRSED ˇˇ  rsrcRSED ˇˇˇˇ                  ™©e{      ˝ˇˇˇˇˇˇˇ0     õ —° ñ           ° ö     Z   
 4  d ∆, 	 Geneva  +@The Built-In Digitizer cannot +
display video whi   - Ä        ˇˇˇ˚About Day Server…    -         Å        ˇˇˇˇFileQuit Q      H Ç        ˇˇˇ˙EditUndo Z  -    Cut X  Copy C  Paste V  Clear        : É        ˇˇˇˇ
ConnectionServing… S  Local Numbers… L        L   L   2 ˇˇ        ˇˇ      Bß/<TEXTDistribution†   TEXTMPS  ˇˇˇˇ  TEXTMPS  ˇˇˇˇ                  ´wÚ  p-  ~0<®TèBgHnˇ0<®TèB-˝Ç+nˇ^˝~=nˇd N^ _OÔ N–NVˇnBnˇt-m˝~ˇn| ˝ÇB-ëAÌ˝ép C˙ H–ﬁ¯=@ˇr=@ˇtg.J-ëgBnˇtn'ˇrg  ÙN≠íJ@g  ÍBß?.   H 	Monaco                             * m= 8 f|´Ç   G   G           L   L   2 Üo¿     2  MPSR   
Ìˇˇ     Ünêy Michael Trent, 1995.       V j ”Ç         É    
  Ä Å Ç É   Ü      Y o m ©OK     ( s 8	      < s L	à      
 
  ñàDaytime Server - TCP     ( 
 8 làLocal Address:     < 
 L kàLocal Name:     T F ÂÜ        Ñ    ¶      s Ñ á æStop     ( Ç 86à      ; Ç K6à      N Ç ^6à      
 
  ùàDaytime Server - TCP     (  8 {àClient Address:      ; > K {àPort:      N > ^ {àTime:      Á  Á  WJ4¨    Ú MENU  "DLOG  RDITL  éMBAR     Äˇˇ        Åˇˇ  1     Çˇˇ  R     Éˇˇ  û     Äˇˇ   ‹WI Åˇˇ   ıWI Ç   ˙WG É   sWG Ñ    $WI  Åˇˇ       Äˇˇ  h     Çˇˇ  öWFÏ Éˇˇ       Ñˇˇ  =     Äˇˇ å    Serving WindowLocal NumbersAbout…sXlation.h               ´ÑÄŒ          	@     M cKAHLommonT  Sortlib, Version 1.0, Copyright (c) 1990, Ari I. HalberstadtCompiled on Oct 29 1990 at 21:02:06Preparing data...Creating 131072 random integersPresorting dataRunning tests. If you see any failure messages then it's time to fix something.qsort	random	131072	4.621qksort	random	131072	4.488hpsort	random	131072	13.136mgsort	random	131072	7.917shsort	random	16384	1.484insort	random	4096	0.109bisort	random	4096	0.227qsort	sorted	131072	2.574qksort	sorted	1