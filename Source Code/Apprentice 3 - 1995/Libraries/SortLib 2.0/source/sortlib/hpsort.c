/* Heap sort. Based on information in "Algorithms", by Robert Sedgewick,   2nd ed., Addison-Wesley, 1988. */#include <stdlib.h>#include <string.h>#include "sort_private.h"static void hpsort1(void *base, size_t n, size_t size,		    int (*compar)(const void *, const void *), void *v);static void downheap1(void *base, size_t n, size_t size,		      int (*compar)(const void *, const void *),		      void *v, size_t i);static void hpsort2(void *base, size_t nmemb, size_t size,		    int (*compar)(const void *, const void *));static void downheap2(void *base, size_t n, size_t size,		      int (*compar)(const void *, const void *), size_t i);/* Call hpsort just like you would the standard library routine qsort.   First, hpsort tries to allocate a temporary variable; if this   is succesful, then it uses the function hpsort1, which performs   about 1/3 of the data moves of hpsort2. Otherwise, it uses hpsort2,   which uses the swap function. */ void hpsort(void *base, size_t n, size_t size,	    int (*compar)(const void *, const void *)){  void *v;  if (size > 1) {    v = SORT_MALLOC(size);    if (v) {      hpsort1(base, n, size, compar, v);      SORT_FREE(v);    }    else      hpsort2(base, n, size, compar);  }}/* Sort the array using heap sort. There are more comments for hpsort2. */static void hpsort1(void *base, size_t n, size_t size,		    int (*compar)(const void *, const void *), void *v){  size_t i;    i = n / 2;  while (i > 0)    downheap1(base, n, size, compar, v, --i);  while (n > 1) {    void *g0 = get(0);    void *gn = get(--n);    SWAP(g0, gn, size);    downheap1(base, n, size, compar, v, 0);  }}/* Move the i'th item down the heap until heap order is restored. Use   The temporary variable 'v' to stash a copy of the i'th item, so that   we avoid making unnecessary swaps. */static void downheap1(void *base, size_t n, size_t size,		      int (*compar)(const void *, const void *),		      void *v, size_t i){  size_t j;  void *pj;    COPY(v, get(i), size);  for (; i < n / 2; i = j) {    j = i + i + 1;    pj = get(j);    if (j + 1 < n && COMPARE(pj, succ(pj)) < 0)  {      j += 1;      pj = succ(pj);    }    if (COMPARE(v, pj) >= 0)      break;    COPY(get(i), pj, size);  }  COPY(get(i), v, size);}/* Sort the array using heap sort. We repair the heap using swaps,   which does more data moving than hpsort1, but will work even if   we can't allocate any memory for a temporary variable. */static void hpsort2(void *base, size_t n, size_t size,		    int (*compar)(const void *, const void *)){  size_t i;  /* At this point the array can be in any random order. */  /* The first stage of heap sort is to construct the initial     heap. This results in n/2 calls to downheap, with each     call causing the heap to grow by one. */  i = n / 2;  while (i-- > 0)    downheap2(base, n, size, compar, i);      /* At this point the entire array is a valid heap. */    /* The next stage is to swap the largest item, which is at     the top of the heap, with the item which is at the end     of the array. This ensures that the largest item is     in its correct position. Then, repair the heap     which has now shrunk by one (since the last item is     already in place). This results in n-1 calls to downheap,     with each call causing the heap to shrink by one. */  while (n > 1) {    void *g0 = get(0);    void *gn = get(--n);    SWAP(g0, gn, size);    downheap2(base, n, size, compar, 0);  }    /* At this point the array is sorted, after having made     (n + n/2 - 1) calls to downheap. */}/* Move the i'th item down the heap until heap order is restored. */static void downheap2(void *base, size_t n, size_t size,		      int (*compar)(const void *, const void *), size_t i){  size_t j;	  /* Index to child of i */  void *pi, *pj;  /* Pointers to i and j. This is just hand-done common  		     subexpression elimination, which wouldn't be  		     necessary if all compilers used half-decent  		     optimization algorithms. */    for (; i < n / 2; i = j) {      j = i + i + 1; /* calculate index to left child of i'th element */        /* choose larger of left and right children of i */    pj = get(j);    if (j+1 < n && COMPARE(pj, succ(pj)) < 0) {      j += 1;      pj = succ(pj);    }        /* check for violation of heap order */    if (COMPARE(pi=get(i), pj) >= 0)      break; /* no violation: heap is ok */        /* swap i'th element with child */    SWAP(pi, pj, size);  }} their UNIX counterparts.These differences will be explained later in this document.The following files must be added to one's project: butil.c, ip.c, iperr.c, andiplow.c.  ipdr.c is optional, and is probably only necessary if you are portingsome existing UNIX code to the Macintosh.The file MacTCPCommonTypes.h must be #included before any ip files are.  Forbasic socket support, one would include:	 #include <MacTCPCommonTypes.h>	 	 #include "ip.h"	 #include "iperr.h" The Simple Sockets library must be initialized at run time before any socketroutines are called.  The routine "InitMacTCP" opens the MacTCP driver andperforms some additional house-keeping.  It shouldn't hurt to place InitMacTCP inyour ToolBoxInit (or whatever) procedure.Before the program terminates, it must make sure that all active sockets areclosed. If a program quits without letting MacTCP know a stream is free, MacTCPcan (and will!) crash the entire machine in a blaze of glory (if you don'tbelieve me, force quit NCSA Telnet a few times).  To be safe, you can call"DisposeMacTCP" before quitting; DisposeMacTCP will close all remaining streamsfor you.  (Tip: Make sure you call this at the end of the program, and before any"ExitToShell" calls!)All socket calls are asynchronous.  While a program is waiting for some networktransaction to take place, the computer continues multi-tasking away.  This isprovided in part by a secondary event loop (called a "Spin Routine"), which callsWaitNextEvent and provides basic event processing.  In order to provide spinningcursors or Dialogs with "Cancel" buttons, you must define your own Spin Routine;see "Making Your Own Spin Routines" below for more information.5. Simple Socket Routines~~~~~~~~~~~~~~~~~~~~~~~~~At this time, only the routines in ip.c and ipdr.c are documented in this manual.Routines in other files are either fairly straight forward (IMHO) or theyshouldn't be of much use to other people (e.g., iplow.c).  Other files may bedocumented here in the future.GENERAL ROUTINESInitMacTCP	OSErr InitMacTCP(void)InitMacTCP must be called by the application before making other calls toroutines in the Simple Sockets library.  It initializes the MacTCP driver, clearsthe socket list, and sets the default spin routine.DisposeMacTCP	void DisposeMacTCP(void)DisposeMacTCP should be called before an application terminates, or when it isdone with the MacTCP driver.  DisposeMacTCP closes all initialized sockets, anddisposes sockets' buffer memory.SetSpin	void SetSpin(Spin spinRoutine)SetSpin sets the spin routine.  The spin routine is a secondary event loop calledrepeatedly by iplow.c while waiting for MacTCP calls to complete.  This allowsother processes on the Macintosh to continue operating in their co-operativemulti-tasking environment.  For information on writing your own spin routine, see"Making Your Own Spin Routines" below.ADDRESS CONVERSION AND LOOKUP ROUTINESnum2dot	void num2dot(unsigned long ip, char *dot)num2dot is a small routine to convert an unsigned long ip number into thehuman-readable dot notation (e.g., 2421762054 becomes "144.89.40.6").  To besafe, dot should point to at least 16 bytes of memory.num2dot isn't part of BSD UNIX sockets.ConvertStrToAddr	OSErr ConvertStrToAddr(char *name, unsigned long *ipNum)This routine converts strings to unsigned long ip numbers.  The string cancontain either a dot notation ip address (e.g., "144.89.40.6"), or a DNS hostname (e.g., "stu.beloit.edu").  It returns an OSErr passed on from MacTCP.ConvertStrToAddr isn't part of BSD UNIX sockets.GetHostByName	unsigned long GetHostByName(char *name)GetHostByName emulates the UNIX routine by the same name (gethostbyname is#defined as GetHostByName).  Given a string containing a DNS name or a dotseparated number, GetHostByName will return that host's unsigned long ip number. If an error occurs, GetHostByName will return 0.GetProtoByName	int GetProtoByName(char *name)GetProtoByName roughly emulates the UNIX routine by the same name (getprotobynameis #defined as GetProtoByName in ip.h).  Given a string containing the name of anetwork protocol, GetProtoByName will return the integer corresponding to it'sprotocol; it will return 0 if it doesn't recognize the protocol.  Currently,GetProtoByName only understands "tcp" and "udp".This routine differs from the UNIX routine in that it returns a simple int,rather than a record of information.  This is largely because MacTCP onlyunderstands TCP/IP and UDP/IP.GetHostName	int GetHostName(char *name, int namelen)GetHostName emulates the UNIX routine by the same name (gethostname is #definedas GetHostName). GetHostName returns the name of the local computer in name.  Theroutine returns 0 if successful; it will return -1 if an error occurred.Note: Since any given Macintosh may not have a local name (unlike UNIX machineswhich DO have local names), GetHostName will return the local host'sdot-separated IP number if no DNS name exists for the local machine.Warning: Currently, namelen is unused, provided only for UNIX compatibility. name must point to a "sufficiently large" amount of memory.  This should be fixedin the future.GetHostNameOnly	int GetHostNameOnly(char *name)GetHostNameOnly is a spinoff of GetHostName.  It is identical to GetHostNameexcept that if the local host doesn't have a DNS name, GetHostNameOnly will fail,rather than returning a dot-separated IP number.  name should point to a"sufficiently large" amount of memory.  GetHostNameOnly returns 0 if successful;otherwise it returns -1.GetMyIPDot	int GetMyIPDot(char *num)GetMyIPDot returns the dot-separated IP address of the local machine in num.  numshould point to at least 16 bytes of memory.  GetMyIPDot returns 0 if successful;otherwise it returns -1.GetMyIPDot isn't part of BSD UNIX sockets.GetMyIPNum	unsigned long GetMyIPNum(void)GetMyIPNum returns the unsigned long IP address of the local machine; it returns-1 if an error occurs.GetMyIPNum isn't part of BSD UNIX sockets.getsockname	int getsockname (int sock, struct sockaddr_in *localaddr, int *addrlen)getsockname is identical to the UNIX function with the same name, exceptlocaladdr is a struct sockaddr_in * rather than a struct sockaddr *.  localaddrpoints to a sockaddr_in struct containing the port and ip numbers of the localhost. *addrlen will be set to the size of the sockaddr_in struct.  getsocknamereturns 0 if successful; otherwise it returns -1.This routine was originally contributed by Lim Wai Kong David<limwaiko@iscs.nus.sg>.GENERAL IP ROUTINESsocket	int socket(int family, int type, int protocol)socket roughly emulates the UNIX function with the same name.  The variablesfamily and type are not used, they are provided solely for compatibility withUNIX code. The variable protocol must be either IPPROTO_TCP or IPPROTO_UDP.socket also reserves some memory for use by MacTCP.  socket returns a socketnumber (currently between 0 and 31 inclusive) if successful; otherwise it returns-1.connect	int connect(int sock, struct sockaddr_in *raddr, int alen)connect roughly emulates the UNIX function with the same name, except localaddris a struct sockaddr_in * rather than a struct sockaddr *.  If sock is a TCPsocket,  connect will open a connection from the local host to the remote hostspecified in *raddr.  If sock is a UDP socket, the destination specified in raddris recorded for use in other routines.  connect returns 0 if successful; itreturns -1 if an error occurs.Note: The variable alen is not used, it is provided solely for compatibility withUNIX code.bind	int bind (int sock, struct sockaddr_in *name, int alen)bind roughly emulates the UNIX function with the same name.  bind specifies aport for a server to listen to.  sock may be either a UDP or TCP socket.  A portmay be bound to twice; once with a TCP socket, once with a UDP socket.  bindreturns 0 if successful; it returns -1 if an error occurs.Note: bind differs from the UNIX bind in several ways. First of all, name is astruct sockaddr_in * rather than a struct sockaddr *.  Secondly, name->sin_addrtraditionally is set to INADDR_ANY or the local system address; name->sin_addr isignored in this implementation.  Thirdly, in UNIX systems, ports 0 - 1023(inclusive) are reserved for privilaged processes; this implementation does notpreserve the notion of reserved ports.  Lastly, the variable alen is not used, itis provided solely for compatibility with UNIX code.listen	int listen(int socket, int queuelen)listen is a dummy routine; provided only for UNIX compatibility.  Both variablesare completely ignored.  listen always returns 0.If anyone can think of a way to REALLY implement listen, I'd be glad to hear it.write	int write (int sock, Ptr data, int len)write is identical to the UNIX function with the same name.  write sends lenbytes pointed to by data across the active connection referenced by sock.  sockmust be a valid, connected socket;  it can be either a TCP or UDP socket.  writereturns the number of bytes successfully written to the remote host; it returns-1 if an error prevents any data from being sent.read	int read (int sock, Ptr buf, int len)read is identical to the UNIX function with the same name.  read reads at mostlen bytes pointed to by data from the active connection referenced by sock.  sockmust be a valid, connected socket;  it can be either a TCP or UDP socket.  Ifthere is no data outstanding, read will block until new data is received. readreturns the number of bytes successfully read from the remote host; it returns -1if an error prevents any data from being read.close	int close(int sock)close is identical to the UNIX function with the same name.  close closes anactive socket and releases its memory.  close returns 0; it can return -1 if anerror occurs.select	int select (int nfds, unsigned long *readfs, struct timeval *timeout)select is used to find out if any unread data is outstanding on a socket beforeblocking the process with a read() or similar call.  The argument list is atruncated version of the original UNIX; I've kept only the aspects of the callthat are important to socket programmers (at least I believe I have).nfds is the number of file descriptors available on the system.  While this canvary from UNIX system to UNIX system, you can count on the number of filedescriptors known by Simple Sockets being 32 Ñ as defined in ip.h as kNumSockets.Always pass this constant in as nfds.*readfs specifies the sockets one wants to query.  It is no coincidence thatwhile there are 32 socket descriptors in Simple Sockets, there are 32 bits in anunsigned long number.  To specify a particular socket, set it's corresponding bitto 1; set all other bits to 0.  When select returns, *readfs identifies socketswith incomming data outstanding in the same way.One can specify a length of time to wait for via *timeout.  If *timeout is nil,select will poll once before returning, whether or not there is unread data.  If*timeout is not nil, its fields describe the maximum amount of time select shouldwait b f r   iKAHL up an  Sortlib, Version 1.0, Copyright (c) 1990, Ari I. HalberstadtCompiled on Nov 5 1990 at 13:10:57Operating System:  Macintosh 6.0.5, Finder 6.0.5, MultiFinder 6.0.5Compiler:          MPW 3.1Hardware:          Macintosh IIfxPreparing data...Creating 32768 random integersPresorting dataRunning tests. If you see any failure messages then it's time to fix something.   qsort   random    32768 4.783  qksort   random    32768 3.517  hpsort   random    32768 11.600  mgsort   random    32768 4.633  shsort