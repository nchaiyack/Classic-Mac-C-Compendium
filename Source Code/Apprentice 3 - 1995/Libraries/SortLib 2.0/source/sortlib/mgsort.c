/* Merge sort. Based on information in "Algorithms", by Robert   Sedgewick, 2nd ed., Addison-Wesley, 1988. */#include <assert.h>#include <stdlib.h>#include <string.h>#include "sort_private.h"#define SMALL (1) /* Size of small subfiles to sort using insertion sort		     before merging the entire file. This didn't actually		     save much, even when I coded the insertion sort		     in-line to avoid function calls. I'm leaving in the		     code just in case I missed something trivial. SMALL		     would normally be around 10 or 16. */#define MIN(a, b)	((a) < (b) ? (a) : (b))#define mget(a, i)	((void*)((char*)a + size * (i)))static void _mgsort(void *base, size_t nmemb, size_t size,		    int (*compar)(const void *, const void *), void *aux);static void merge(char *a, size_t na, char *b, size_t nb, char *aux,		  size_t size, int (*compar)(const void *, const void *));/* You can call mgsort just as you would the standard qsort. This   implementation does a bottom up merge sort on the array,   using O(n*lg(n)) comparisons, O(n*lg(n)) copy operations,   and an auxiliary array of size n, or size*nmemb bytes.   If the auxiliary array could not be allocated, then we   call heap sort instead. While heap sort will be slower,   its performance, even in the worst case, is still   O(n*lg(n)). */void mgsort(void *base, size_t nmemb, size_t size,	    int (*compar)(const void *, const void *)){  void *aux;    aux = SORT_MALLOC(nmemb * size);  if (aux) {    _mgsort(base, nmemb, size, compar, aux);    SORT_FREE(aux);  }  else    hpsort(base, nmemb, size, compar);}/* Sort the array pointed to by 'base' using the auxiliary array   of the same size. This function could be improved by doing   an insertion sort on small subfiles. */static void _mgsort(void *base, size_t n, size_t size,		    int (*compar)(const void *, const void *), void *aux){  size_t sz;	/* Size of current subfile. We merge subfiles		   of size 1, 2, 4 ... n. */  size_t i;	/* Offset of first subfile to merge. */  void *src;	/* Instead of only merging from the original array		   into the auxiliary array, we alternate merging:		   once we merge from the source into the auxiliary,		   and then from the auxiliary into the source. This		   eliminates an extra copy of the data from the inner		   loop. */  void *tmp;	/* We use this to swap the source and auxiliary pointers. */    #if SMALL > 1    /* first, do an insertion sort on small subfiles */    for (i = 0; i < n; i += SMALL) {      sz = (i + SMALL < n ? SMALL : n - i);      insort(mget(base, i), sz, size, compar);    }  #endif  /* merge succesively larger subfiles */  src = base;  for (sz = SMALL; sz < n; sz *= 2) {        /* merge all adjacent subfiles of size 'sz' */    for (i = 0; i < n; i += 2*sz) {      size_t offset = i+sz < n ? i+sz : 0;      merge(mget(src, i), MIN(sz, n - i),	    mget(src, offset), offset ? MIN(sz, n - i - sz) : 0,	    mget(aux, i), size, compar);    }        /* Swap the source array with the auxiliary array. This eliminates       the need to copy the merged array from the auxiliary array       back into the source array. Instead, we alternate: once we       merge the source into the auxiliary, then we merge the       auxiliary into the source. */    tmp = src; src = aux; aux = tmp;      }    /* If there were an odd number of subfiles then the sorted array     is currently in the auxiliary array. All that remains is to     copy back into the original array. */  if (src != base)    memcpy(base, src, size * n);}/* Merge the first 'na' items of 'a' with the first 'nb' items of 'b'   and place the result in 'aux'. */static void merge(char *a, size_t na, char *b, size_t nb, char *aux,		  size_t size, int (*compar)(const void *, const void *)){  char *end_a;  char *end_b;  size_t i;    end_a = mget(a, na);  end_b = mget(b, nb);  while (a < end_a && b < end_b) {    i = size;    if (COMPARE(a, b) <= 0) {      COPY(aux, a, size);      a += size;    }    else {      COPY(aux, b, size);      b += size;    }    aux += size;  }  while (a < end_a) {    COPY(aux, a, size);    aux += size;    a += size;  }  while (b < end_b) {    COPY(aux, b, size);    aux += size;    b += size;  }}    HUnlock(codeHndl);    DisposHandle(codeHndl);    dnr = nil;    return(noErr);}typedef OSErr (*StrToAddrProcPtr)(long selector, char* hostName, struct hostInfo* rtnStruct,                                    long resultProc, char* userData);enum {    uppStrToAddrProcInfo = kCStackBased         | RESULT_SIZE(SIZE_CODE(sizeof(long)))         | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))         | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char *)))         | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct hostInfo *)))         | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long)))         | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(char *)))};#if USESROUTINEDESCRIPTORStypedef UniversalProcPtr StrToAddrUPP;#define NewStrToAddrProc(userRoutine)                       \        (StrToAddrUPP) NewRoutineDescriptor(userRoutine, uppStrToAddrProcInfo, GetCurrentISA())#define CallStrToAddrProc(userRoutine, selector, hostName, rtnStruct, resultProc, userData) \        CallUniversalProc(userRoutine, uppStrToAddrProcInfo, selector, hostName, rtnStruct, resultProc, userData)#elsetypedef StrToAddrProcPtr StrToAddrUPP;#define NewStrToAddrProc(userRoutine)                       \        (StrToAddrUPP)(userRoutine)#define CallStrToAddrProc(userRoutine, selector, hostName, rtnStruct, resultProc, userData) \        (*userRoutine)(selector, hostName, rtnStruct, resultProc, userData)#endif/*pascal*/ OSErr StrToAddr(hostName, rtnStruct, resultproc, userDataPtr) //MDTchar *hostName;struct hostInfo *rtnStruct;long resultproc;char *userDataPtr;{    if (dnr == nil)        /* resolver not loaded error */        return(notOpenErr);    return(CallStrToAddrProc((StrToAddrUPP) dnr, STRTOADDR, hostName, (void*) rtnStruct,                            resultproc, userDataPtr));}typedef OSErr (*AddrToStrProcPtr)(long selector, long address, char* hostName);enum {    uppAddrToStrProcInfo = kCStackBased         | RESULT_SIZE(SIZE_CODE(sizeof(long)))         | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))         | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(unsigned long)))         | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(char *)))};#if USESROUTINEDESCRIPTORStypedef UniversalProcPtr AddrToStrUPP;#define NewAddrToStrProc(userRoutine)                       \        (AddrToStrUPP) NewRoutineDescriptor(userRoutine, uppAddrToStrProcInfo, GetCurrentISA())#define CallAddrToStrProc(userRoutine, selector, address, hostName) \        CallUniversalProc(userRoutine, uppAddrToStrProcInfo, selector, address, hostName)#elsetypedef AddrToStrProcPtr AddrToStrUPP;#define NewAddrToStrProc(userRoutine)                       \        (AddrToStrUPP)(userRoutine)#define CallAddrToStrProc(userRoutine, selector, address, hostName) \        (*userRoutine)(selector, address, hostName)#endifpascal OSErr AddrToStr(addr, addrStr)unsigned long addr;char *addrStr;{    if (dnr == nil)        /* resolver not loaded error */        return(notOpenErr);    CallAddrToStrProc((AddrToStrUPP) dnr, ADDRTOSTR, addr, addrStr);    return(noErr);}typedef OSErr (*EnumCacheProcPtr)(long selector, long result, char* userData);enum {    uppEnumCacheProcInfo = kCStackBased         | RESULT_SIZE(SIZE_CODE(sizeof(long)))         | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))         | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(long)))         | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(char *)))};#if USESROUTINEDESCRIPTORStypedef UniversalProcPtr EnumCacheUPP;#define NewEnumCacheProc(userRoutine)                       \        (EnumCacheUPP) NewRoutineDescriptor(userRoutine, uppEnumCacheProcInfo, GetCurrentISA())#define CallEnumCacheProc(userRoutine, selector, result, userData)  \        CallUniversalProc(userRoutine, uppEnumCacheProcInfo, selector, result, userData)#elsetypedef EnumCacheProcPtr EnumCacheUPP;#define NewEnumCacheProc(userRoutine)                       \        (EnumCacheUPP)(userRoutine)#define CallEnumCacheProc(userRoutine, selector, result, userData)  \        (*userRoutine)(selector, result, userData)#endifpascal OSErr EnumCache(resultproc, userDataPtr)long resultproc;char *userDataPtr;{    if (dnr == nil)        /* resolver not loaded error */        return(notOpenErr);    return(CallEnumCacheProc((EnumCacheUPP) dnr, ENUMCACHE, resultproc, userDataPtr));}typedef OSErr (*AddrToNameProcPtr)(long selector, unsigned long addr, struct hostInfo* rtnStruct,                                    long resultProc, char* userData);enum {    uppAddrToNameProcInfo = kCStackBased         | RESULT_SIZE(SIZE_CODE(sizeof(long)))         | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))         | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(unsigned long)))         | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct hostInfo *)))         | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long)))         | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(char *)))};#if USESROUTINEDESCRIPTORStypedef UniversalProcPtr AddrToNameUPP;#define NewAddrToNameProc(userRoutine)                      \        (AddrToNameUPP) NewRoutineDescriptor(userRoutine, uppAddrToNameProcInfo, GetCurrentISA())#define CallAddrToNameProc(userRoutine, selector, addr, rtnStruct, resultProc, userData)    \        CallUniversalProc(userRoutine, uppAddrToNameProcInfo, selector, addr, rtnStruct, resultProc, userData)#elsetypedef AddrToNameProcPtr AddrToNameUPP;#define NewAddrToNameProc(userRoutine)                      \        (AddrToNameUPP)(userRoutine)#define CallAddrToNameProc(userRoutine, selector, addr, rtnStruct, resultProc, userData)    \        (*userRoutine)(selector, addr, rtnStruct, resultProc, userData)#endif/*pascal*/ OSErr AddrToName(addr, rtnStruct, resultproc, userDataPtr)  //MDTunsigned long addr;struct hostInfo *rtnStruct;long resultproc;char *userDataPtr;{    if (dnr == nil)        /* resolver not loaded error */        return(notOpenErr);    return(CallAddrToNameProc((AddrToNameUPP) dnr, ADDRTONAME, addr, rtnStruct, resultproc, userDataPtr));}typedef OSErr (*HInfoProcPtr)(long selector, char* hostName, struct returnRec* returnRecPtr,                                long resultProc, char* userData);enum {    uppHInfoProcInfo = kCStackBased         | RESULT_SIZE(SIZE_CODE(sizeof(long)))         | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))         | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char *)))         | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct returnRec *)))         | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long)))         | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(char *)))};#if USESROUTINEDESCRIPTORStypedef UniversalProcPtr HInfoUPP;#define NewHInfoProc(userRoutine)                       \        (HInfoUPP) NewRoutineDescriptor(userRoutine, uppHInfoProcInfo, GetCurrentISA())#define CallHInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userData)  \        CallUniversalProc(userRoutine, uppHInfoProcInfo, selector, hostName, returnRecPtr, resultProc, userData)#elsetypedef HInfoProcPtr HInfoUPP;#define NewHInfoProc(userRoutine)                       \        (HInfoUPP)(userRoutine)#define CallHInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userData)  \        (*userRoutine)(selector, hostName, returnRecPtr, resultProc, userData)#endifpascal  OSErr HInfo(hostName, returnRecPtr, resultProc, userDataPtr)char *hostName;struct returnRec *returnRecPtr;long resultProc;char *userDataPtr;{    if (dnr == nil)        /* resolver not loaded error */        return(notOpenErr);    return(CallHInfoProc((HInfoUPP) dnr, HINFO, hostName, (void*) returnRecPtr,                        resultProc, userDataPtr));}typedef OSErr (*MXInfoProcPtr)(long selector, char* hostName, struct returnRec* returnRecPtr,                                long resultProc, char* userData);enum {    uppMXInfoProcInfo = kCStackBased         | RESULT_SIZE(SIZE_CODE(sizeof(long)))         | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(sizeof(short)))         | STACK_ROUTINE_PARAMETER(2, SIZE_CODE(sizeof(char *)))         | STACK_ROUTINE_PARAMETER(3, SIZE_CODE(sizeof(struct returnRec *)))         | STACK_ROUTINE_PARAMETER(4, SIZE_CODE(sizeof(long)))         | STACK_ROUTINE_PARAMETER(5, SIZE_CODE(sizeof(char *)))};#if USESROUTINEDESCRIPTORStypedef UniversalProcPtr MXInfoUPP;#define NewMXInfoProc(userRoutine)                      \        (MXInfoUPP) NewRoutineDescriptor(userRoutine, uppMXInfoProcInfo, GetCurrentISA())#define CallMXInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userData) \        CallUniversalProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userData)#elsetypedef MXInfoProcPtr MXInfoUPP;#define NewMXInfoProc(userRoutine)                      \        (MXInfoUPP)(userRoutine)#define CallMXInfoProc(userRoutine, selector, hostName, returnRecPtr, resultProc, userData) \        (*userRoutine)(selector, hostName, returnRecPtr, resultProc, userData)#endifpascal  OSErr MXInfo(hostName, returnRecPtr, resultProc, userDataPtr)char *hostName;struct returnRec *returnRecPtr;long resultProc;char *userDataPtr;{    if (dnr == nil)        /* resolver not loaded error */        return(notOpenErr);    return(CallMXInfoProc((MXInfoUPP) dnr, MXINFO, hostName, returnRecPtr, resultProc,      D¢  C¢  J                                day.fat   APPL???? ÿÿÿÿ    H  APPL???? ÿÿÿÿ                  «"b  T¶  Eì                                                                                                                                     - €        ÿÿÿûAbout Day ClientÉ    -                 ÿÿÿÿFileQuit Q      H ‚        ÿÿÿúEditUndo Z  -    Cut X  Copy C  Paste V  Clear        ; ƒ        ÿÿÿÿ
Connection	Get TimeÉ G  Local NumbersÉ L       V j Ó‚         €     V jMMCC      cool        Â  Þ   P      ˜  0  Sources 11˜ÿÿÿÿ @•@•F~ÝÝÝÝÝÝÝÝ          0   (	Resources1˜reL
ÓÚ@•F~ÝÝÝÝÝÝÝÝ           0  	Libraries1˜§                               ( øÿð     Ô”      2Æ  
ËX                 menu    $ íÿ               Clear File menu    -      @    	MacOS.lib                      «Åt*              	MacDayd.c                      «·¯         @    butil.c                        «­‘ò         @    ip.c                 MPS         -------License-------For the purposes of this license, Sort Library shall be referred to as"the software". This includes the source code, the object code, andany supporting files such as resource files and documentation.You can use the software in any freely distributed product. Theprecise terms are detailed in the GNU Library General Public License(GLGPL), a copy of which is included following this notice. Thisnotice grants you some additional distribution rights.Except for the exclusions granted below, this document must beincluded in its original form in any distribution of the software.This document is "Ari Halberstadt's General Public License", v1.1,November 1994.(c) Copyright 1994, Ari Halberstadt-----------------Freeware Products-----------------To use the software in your product, in addition to the terms of theGLGPL, you must provide appropriate credit in your application's aboutbox or in your product's documentation. A notice such as:	"The Software © Copyright 1994 Ari Halberstadt"would suffice. (Replace "The Software"  iKAHLhe nam  Sortlib, Version 1.0, Copyright (c) 1990, Ari I. HalberstadtCompiled on Nov  5 1990 at 12:11:15Operating System:  Macintosh 6.0.5, Finder 6.1.4, MultiFinder 6.1b7Compiler:          THINK C 4.0.2Hardware:          Macintosh IIcxPreparing data...Creating 4096 random integersPresorting dataRunning tests. If you see any failure messages then it's time to fix something.   qsort   random     4096 3.167  qksort   random     4096 0.617  hpsort   random     4096 3.083  mgsort