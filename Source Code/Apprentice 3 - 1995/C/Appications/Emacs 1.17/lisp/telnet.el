;; Copyright (C) 1985 Free Software Foundation;; This file is part of GNU Emacs.;; GNU Emacs is free software; you can redistribute it and/or modify;; it under the terms of the GNU General Public License as published by;; the Free Software Foundation; either version 1, or (at your option);; any later version.;; GNU Emacs is distributed in the hope that it will be useful,;; but WITHOUT ANY WARRANTY; without even the implied warranty of;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the;; GNU General Public License for more details.;; You should have received a copy of the GNU General Public License;; along with GNU Emacs; see the file COPYING.  If not, write to;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.;; Author William F. Schelter;;to do fix software types for lispm:;;to eval current expression.  Also to try to send escape keys correctly.;;essentially we'll want the rubout-handler off.(defvar telnet-new-line "\r")(defvar telnet-mode-map nil)(defvar telnet-prompt-pattern "^[^#$%>]*[#$%>] *")(defvar telnet-interrupt-string "\^c" "String sent by C-c.")(defvar telnet-count 0)(defvar telnet-replace-c-g nil)(defvar telnet-remote-echoes nil)(defun telnet-interrupt-subjob ()  (interactive)  "Interrupt the program running through telnet on the remote host."  (send-string nil telnet-interrupt-string))(defun telnet-c-z ()  (interactive)  (send-string nil ""))(defun send-process-next-char ()  (interactive)  (send-string nil	       (char-to-string		(let ((inhibit-quit t))		  (prog1 (read-char)		    (setq quit-flag nil))))))(setq telnet-mode-map (make-sparse-keymap))(progn  (define-key telnet-mode-map "\C-m" 'telnet-send-input)  (define-key telnet-mode-map "\C-j" 'telnet-send-input)  (define-key telnet-mode-map "\C-c\C-d" 'shell-send-eof)  (define-key telnet-mode-map "\C-c\C-q" 'send-process-next-char)  (define-key telnet-mode-map "\C-c\C-c" 'telnet-interrupt-subjob)   (define-key telnet-mode-map "\C-c\C-z" 'telnet-c-z)  (define-key telnet-mode-map "\C-c\C-u" 'kill-shell-input)  (define-key telnet-mode-map "\C-c\C-w" 'backward-kill-word)  (define-key telnet-mode-map "\C-c\C-o" 'kill-output-from-shell)  (define-key telnet-mode-map "\C-c\C-r" 'show-output-from-shell));;maybe should have a flag for when have found type(defun telnet-check-software-type-initialize (string)  "Tries to put correct initializations in.  Needs work."  (cond ((string-match "unix" string)	 (setq telnet-prompt-pattern shell-prompt-pattern)	 (setq telnet-new-line "\n"))	((string-match "tops-20" string) ;;maybe add telnet-replace-c-g	 (setq telnet-prompt-pattern  "[@>]*"))	((string-match "its" string)	 (setq telnet-prompt-pattern  "^[^*>]*[*>] *"))	((string-match "explorer" string)  ;;explorer telnet needs work	 (setq telnet-replace-c-g ?\n))	))(defun telnet-initial-filter (proc string)  ;For reading up to and including password; also will get machine type.  (cond ((string-match "No such host" string)	 (kill-buffer (process-buffer proc))	 (error "No such host."))	((string-match "passw" string)	 (telnet-filter proc string)	 (let* ((echo-keystrokes 0)		(password (read-password)))	   (setq telnet-count 0)	   (send-string proc (concat password  telnet-new-line))))	(t (telnet-check-software-type-initialize string)	   (telnet-filter proc string)	   (cond ((> telnet-count 4)		  (set-process-filter proc 'telnet-filter))		 (t (setq telnet-count (1+ telnet-count)))))))(defun telnet-filter (proc string)  (save-excursion    (set-buffer (process-buffer proc))    (goto-char (point-max))    (let ((now (point)))      (insert string)      (subst-char-in-region now (point) ?\^m ?\ )      (and telnet-replace-c-g	   (subst-char-in-region now (point) ?\^g telnet-replace-c-g)))    (if (process-mark proc)	(set-marker (process-mark proc) (point)))    (if (and (integer-or-marker-p last-input-start)	     (marker-position last-input-start)	     telnet-remote-echoes)	(delete-region last-input-start last-input-end)))  (if (eq (process-buffer proc)	  (current-buffer))      (goto-char (point-max))))(defun delete-char-or-send-eof (arg killp)  "At end of buffer, send eof to subshell.  Otherwise delete character."  (interactive "p\nP")  (if (and (eobp) (not killp))      (process-send-eof)    (delete-char arg killp)))(defun telnet-send-input ()  "Send input to remote hostAt end of buffer, sends all text after last outputas input to the telnet, including a telnet-new-line inserted at the end.Not at end, copies current line to the end of the buffer and sends it,after first attempting to discard any prompt at the beginning of the lineby matching the regexp that is the value of telnet-prompt-pattern if possible." (interactive) (let (copied)  (end-of-line)  (if (eobp)      (progn	(move-marker last-input-start		     (process-mark (get-buffer-process (current-buffer))))	(move-marker last-input-end (point)))    (beginning-of-line)    (re-search-forward telnet-prompt-pattern nil t)    (let ((copy (buffer-substring (point)				  (progn (forward-line 1) (point)))))      (goto-char (point-max))      (move-marker last-input-start (point))      (insert copy) (setq copied t)      (move-marker last-input-end (point))))  (save-excursion    (goto-char last-input-start)    (let ((process (get-buffer-process (current-buffer))))      (send-region process last-input-start last-input-end)      (if (not copied) (send-string process telnet-new-line))      (set-marker (process-mark process) (point))))))(defun telnet (arg)  "Open a network login connection to host named HOST (a string).Communication with HOST is recorded in a buffer *HOST-telnet*.Normally input is edited in Emacs and sent a line at a time."  (interactive "sOpen telnet connection to host: ")  (require 'shell)  (let ((name (concat arg "-telnet" )))    (switch-to-buffer (make-shell name "telnet"))    (set-process-filter (get-process name) 'telnet-initial-filter)    (accept-process-output (get-process name))    (erase-buffer)    (send-string  name (concat "open " arg "\n"))    (telnet-mode)    (setq telnet-count -16)))(defun read-password ()  (let ((answ "") tem)    (while (prog1 (not (memq (setq tem (read-char))			     '(?\C-m ?\n ?\C-g)))	     (setq quit-flag nil))      (setq answ (concat answ (char-to-string tem))))    answ))(defun telnet-mode ()  "This mode is for use during telnet from a buffer to anotherhost. It has most of the same commands as shell mode.There is a variable `telnet-interrupt-string' which is the charactersent to try to stop execution of a job on the remote host.Data is sent to the remote host when `return' is typed.Thus if you may need to edit the data before sending youshould use c-n to move down a line.  Then you can returnto alter a previous line.  Of course you should not use thismode of telnet if you want to run emacs like programs on theremote host (at least not yet!).The following commands imitate the usual Unix interrupt andediting control characters:\\{telnet-mode-map}Bugs:--Replace  by a space, really should remove.--For Unix interacts poorly with tcsh although csh,sh,ksh are ok."  (interactive)  (kill-all-local-variables)  (setq major-mode 'telnet-mode)  (setq mode-name "Telnet")  (setq mode-line-process '(": %s"))  (make-local-variable 'last-input-start)  (use-local-map telnet-mode-map)  (let ((tem telnet-prompt-pattern))    (make-local-variable 'telnet-prompt-pattern)    (setq telnet-prompt-pattern tem))  (make-local-variable 'telnet-interrupt-string)  (setq telnet-interrupt-string "")  (make-local-variable 'telnet-new-line)  (setq telnet-new-line "\r")  (make-local-variable 'last-input-start)  (setq last-input-start (make-marker))  (make-local-variable 'last-input-end)  (setq last-input-end (make-marker))  (make-local-variable 'telnet-remote-echoes)  (setq telnet-remote-echoes t)  (make-local-variable 'telnet-replace-c-g)  (setq telnet-replace-c-g nil))nctions callable in this region."  (let* ((region (or region (sm::window-region (list w x y))))	 (mlist (mapcar (function mouse-help-menu)			(sm::event-bindings region)))	 (menu (menu-create (cons (list (symbol-name region)) mlist)))	 (item (sun-menu-evaluate w 0 y menu))	 )));;;;;; Menu interface functions;;;;;; use defmenu, because this interface is subject to change;;; really need a menu-p, but we use vectorp and the context...;;;(defun menu-create (items)  "Functional form for defmenu, given a list of ITEMS returns a menu.Each ITEM is a (STRING . VALUE) pair."  (apply 'vector items)  )(defmacro defmenu (menu &rest itemlist)  "Defines MENU to be a menu, the ITEMS are (STRING . VALUE) pairs.See sun-menu-evaluate for interpretation of ITEMS."  (list 'defconst menu (funcall 'menu-create itemlist))  )(defun sun-menu-evaluate (*menu-window* *menu-x* *menu-y* menu)  "Display a pop-up menu in WINDOW at X Y and evaluate selected itemof MENU.  MENU (or its symbol-value) should be a menu defined by defmenu.  A menu ITEM is a (STRING . FORM) pair;the FORM associated with the selected STRING is evaluated,and the resulting value is returned.  Generally these FORMs areevaluated for their side-effects rather than their values.  If the selected form is a menu or a symbol whose value is a menu, then it is displayed and evaluated as a pullright menu item.  If the the FORM of the first ITEM is nil, the STRING of the itemis used as a label for the menu, i.e. it's inverted and not selectible."  (if (symbolp menu) (setq menu (symbol-value menu)))  (eval (sun-menu-internal *menu-window* *menu-x* *menu-y* 4 menu)))(defun sun-get-frame-data (code)  "Sends the tty-sub-window escape sequence CODE to terminal,and returns a cons of the two numbers in returned escape sequence.That is it returns (cons <car> <cdr>) from \"\\E[n;<car>;<cdr>t\". CODE values: 13 = Tool-Position, 14 = Size-in-Pixels, 18 = Size-in-Chars."  (send-string-to-terminal (concat "\033[" (int-to-string code) "t"))  (let (char str x y)    (while (not (equal 116 (setq char (read-char)))) ; #\t = 116      (setq str (cons char str)))    (setq str (mapconcat 'char-to-string (nreverse str) ""))    (string-match ";[0-9]*" str)    (setq y (substring str (1+ (match-beginning 0)) (match-end 0)))    (setq str (substring str (match-end 0)))    (string-match ";[0-9]*" str)    (setq x (substring str (1+ (match-beginning 0)) (match-end 0)))    (cons (string-to-int y) (string-to-int x))))(defun sm::font-size ()  "Returns font size in pixels: (cons Ysize Xsize)"  (let ((pix (sun-get-frame-data 14))	; returns size in pixels	(chr (sun-get-frame-data 18)))	; returns size in chars    (cons (/ (car pix) (car chr)) (/ (cdr pix) (cdr chr)))))(defvar sm::menu-kludge-x nil   "Cached frame-to-window X-Offset for sm::menu-kludge")(defvar sm::menu-kludge-y nil   "Cached frame-to-window Y-Offset for sm::menu-kludge")(defun sm::menu-kludge ()  "If sunfns.c uses <Menu_Base_Kludge> this function must be here!"  (or sm::menu-kludge-y      (let ((fs (sm::font-size)))	(setq sm::menu-kludge-y (+ 8 (car fs))	; a title line and borders	      sm::menu-kludge-x 4)))	; best values depend on .defaults/Menu  (let ((wl (sun-get-frame-data 13)))		; returns frame location    (cons (+ (car wl) sm::menu-kludge-y)	  (+ (cdr wl) sm::menu-kludge-x))));;;;;;  Function interface to selection/region;;;  primative functions are defined in sunfns.c;;;(defun sunview-yank-stuff ()  "Set mark and yank the contents of the current TTYSW `STUFF' selectioninto the current buffer at point.  The STUFF selection contains the currentlyor previously highlighted text from a TTYSW."  (interactive "*")  (set-mark-command nil)  (insert-string (sun-get-selection)));;;(defun display-host ()  "Extract <host> from DISPLAY environment variable, or return nil if not specified."  (let ((display (getenv "DISPLAY")))    (if display	(let ((colon_at (string-match ":" display)))	  (if colon_at	      (if (not (zerop colon_at))		  (substring display 0 colon_at)		))))));;; get_selection has been extended to work in X;;; we extend to work on remote X display...(defun sunview-yank-clipboard ()  "Set mark and yank the contents of the SunView Clipboard into thecurrent buffer at point."  (interactive "*")  (set-mark-command nil)  (let ((host (display-host)))    (if host	(call-process "rsh" nil t t (display-host) "get_selection" "3")      (call-process "get_selection" nil t t "3")))  )(defun sunview-yank-current-selection ()  "Set mark and yank the contents of the current SunView selectioninto current buffer at point. The current selection is the currentlyhighlighted text in either a textsw or a ttysw."  (interactive "*")  (set-mark-command nil)  (let ((host (display-host)))    (if host	(call-process "rsh" nil t t (display-host) "get_selection")      (call-process "get_selection" nil t t))))(defun sunview-yank-any-selection (arg)  "Yank one of the sunview selections:with no arg, the current selection; with minus-only prefix, the clipboard;with any other arg, the ttysw STUFF."  (interactive "*P")  (cond ((null arg) (sunview-yank-current-selection))	((eq arg '-) (sunview-yank-clipboard))	(t (sunview-yank-stuff))));;; define the selection file used by this emacs;;; if not local machine, then automounter must find /net/<host>/tmp(defvar owselectionfilex nil "Cache path to ttysw selection file (a kludge!).");;; determine value at runtime, not when this file loaded into temacs(defun owselectionfile ()  (or owselectionfilex       (let* ((host (display-host))	     (filex 	      (if host		  (concat "/net/" host "/tmp/ttyselection")		"/tmp/ttyselection")))	(if (file-exists-p filex)	    (setq owselectionfilex filex)	  (progn	    (message "no TTYSW selection file")	    nil)	  ))))(defun xv-yank-selection ()  "Set mark and yank the contents of the current Xview selectioninto the current buffer at point.  The STUFF selection contains the currentlyor previously highlighted text from a TTYSW."  (interactive "*")  (if (owselectionfile)      (progn       (insert-file (owselectionfile))       (exchange-point-and-mark)))  )(defun xv-select-region (beg end)  "Set the TTYSW selection to the region in the current buffer."  (interactive "r")  (if (owselectionfile)      (write-region beg end (owselectionfile) nil 'noprint))  )(defun sun-yank-selection ()  "Set mark and yank the contents of the current TTYSW `STUFF' or Xview selectioninto the current buffer at point."  (interactive "*")  (if (getenv "DISPLAY")      (xv-yank-selection)      (sunview-yank-stuff))  )(defun sun-select-region (beg end)  "Set the TTYSW 'STUFF' or Xview selection to the region in the current buffer."  (interactive "r")  (if (getenv "DISPLAY")      (xv-select-region beg end)      (sun-set-selection (buffer-substring beg end)))  );;;;;; support for emacstool;;; This closes the window instead of stopping emacs.;;;(defun suspend-emacstool (&optional stuffstring)  "If running under as a detached process emacstool,you don't want to suspend  (there is no way to resume), just close the window, and wait for reopening."  (interactive)  (if (and (boundp 'suspend-hook) suspend-hook)      (funcall suspend-hook))  (if stuffstring (send-string-to-terminal stuffstring))  (send-string-to-terminal "\033[2t")	; To close EmacsTool window.  (if (and (boundp 'suspend-resume-hook) suspend-resume-hook)      (funcall suspend-resume-hook)));;;;;; initialize mouse maps;;;(make-variable-buffer-local 'current-local-mousemap)(setq-default current-local-mousemap nil)(defvar current-global-mousemap (make-mousemap))rmation on getting the latest version.
Type C-h t for a tutorial on using Emacs." substitute-command-keys "Type \\[help-command] for help; \\[advertised-undo] to undo changes.  (`C-' means use CTRL key.)

GNU Emacs comes with ABSOLUTELY NO WARRANTY; type \\[describe-no-warranty] for full details.
You may give out copies of Emacs; type \\[describe-copying] to see the conditions.
Type \\[describe-distribution] for information on getting the latest version.
Type \\[help-with-t                                                                                                            