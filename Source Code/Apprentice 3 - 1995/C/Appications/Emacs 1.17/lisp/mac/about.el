;;;
;;; This file is part of a Macintosh port of GNU Emacs.
;;; Copyright (C) 1993, 1994 Marc Parmet.  All rights reserved.
;;;
;;; GNU Emacs is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;;

(defun have-color-QuickDraw ()
  (let* ((response-string (make-string 4 0))
		 (err (Gestalt gestaltQuickdrawVersion response-string))
		 (response-int (c:value (c:deref (c:cast '(ptr . long) response-string)))))
    (and (zerop err) (>= response-int gestalt8BitQD))))

(defun main-device-depth ()
  (let* ((main-device (c:cast 'GDHandle (GetMainDevice)))
		 (pixmap (unwind-protect
					 (progn (HLock (c:value main-device))
							(c:deref (c:getf (c:deref main-device) 'gdPMap)))
				   (HUnlock (c:value main-device))))
		 (pixel-size (unwind-protect
						 (progn (HLock (c:value pixmap))
								(c:deref (c:getf (c:deref pixmap) 'pixelSize)))
					   (HUnlock (c:value pixmap)))))
	(c:value pixel-size)))

(c:defstruct vers (((array char 4) b)
				   (short country)
				   ((array unsigned-char 256) s1)
				   ((array unsigned-char 256) s2)))

(defun draw-version (d item)
  (let* ((type (make-string 2 0))
		 (h (make-string 4 0))
		 (box (make-rect)))
    (GetDItem d item type h box)
    (SetPort d)
    (TextFont times)
    (TextSize 14)
    (let* ((u (GetResource "STR " 129))
		   (x (unwind-protect
				  (progn (HLock u)
						 (extract-internal (deref u) 0 'pascal-string))
				(HUnlock u)))
		   (v (GetResource "vers" 1))
		   (w (unwind-protect
				  (progn (HLock v)
						 (let* ((vers-handle (c:cast '(ptr ptr . vers) v))
								(vers-str (c:deref (c:getf (c:deref vers-handle) 's1))))
						   (extract-internal (c:value vers-str) 0 'pascal-string)))
				(HUnlock v)))
		   (s (CtoPstr (concat x w))))
      (MoveTo (/ (- (+ (c:slotref 'Rect box 'left) (c:slotref 'Rect box 'right))
					(StringWidth s))
				 2)
			  (- (c:slotref 'Rect box 'bottom) 4))
      (DrawString s))))

(defun draw-copyright (d item)
  (let* ((type (make-string 2 0))
		 (h (make-string 4 0))
		 (box1 (make-rect))
		 (p (GetPicture 130))
		 (box2 (unwind-protect
				   (progn (HLock p)
						  (extract-internal (deref p) 2 'string (c:sizeof 'Rect)))
				 (HUnlock p))))
    (GetDItem d item type h box1)
    (SetPort d)
    (OffsetRect box2 (- (c:slotref 'Rect box1 'left) (c:slotref 'Rect box2 'left))
				(- (c:slotref 'Rect box1 'top) (c:slotref 'Rect box2 'top)))
    (if (and (have-color-QuickDraw) (>= (main-device-depth) 4))
		(let ((bitmap (make-string (c:sizeof 'BitMap) 0))
			  (bounds-rect (copy-sequence box2))
			  (port (NewPtr (c:sizeof 'GrafPort))))
		  (if (zerop (MemError))
			  (progn
				(OpenPort port)
				(OffsetRect bounds-rect (- (c:slotref 'Rect bounds-rect 'left))
							(- (c:slotref 'Rect bounds-rect 'top)))
				(c:slotset 'BitMap bitmap 'rowBytes (* (1+ (/ (1- (c:slotref 'Rect bounds-rect 'right)) 16)) 2))
				(c:slotset 'BitMap bitmap 'bounds bounds-rect)
				(let* ((baseAddr (NewPtr (* (c:slotref 'BitMap bitmap 'rowBytes)
											(c:slotref 'Rect (c:slotref 'BitMap bitmap 'bounds) 'bottom))))
					   (grey (let ((shade 55000)) (make-rgb shade shade shade)))
					   (white (let ((shade 65535)) (make-rgb shade shade shade))))
				  (if (zerop (MemError))
					  (progn
						(c:slotset 'BitMap bitmap 'baseAddr baseAddr)
						(SetPortBits bitmap)
						(EraseRect bounds-rect)
						(DrawPicture p bounds-rect)
						(SetPort d)
						(RGBBackColor grey)
						(CopyBits bitmap (c:slotref 'GrafPort d 'portBits)
								  bounds-rect box2 0 0)
						(RGBBackColor white)
						(DisposPtr baseAddr))))
				(ClosePort port)
				(DisposPtr port))))
      (DrawPicture p box2))
    (FrameRect box2)))

(defun about-filter (d e i)
  (cond
   ((= (c:slotref 'EventRecord e 'what) mouseDown)
    (SetPort d)
    (let ((pt (c:slotref 'EventRecord e 'where)))
      (GlobalToLocal pt)
      (if (PtInRect pt (c:slotref 'GrafPort d 'portRect))
		  (progn
			(while (not (zerop (WaitMouseUp)))
			  nil)
			(encode-internal i 0 'short 1)
			1)
		0)))
   ((= (c:slotref 'EventRecord e 'what) keyDown)
    (let ((c (logand (c:slotref 'EventRecord e 'message) charCodeMask)))
	  (if (or (= c 13) (= c 3))
		  (progn
			(encode-internal i 0 'short 1)
			1)
		0)))
   (t
    0)))

(defun do-about (menu item)
  (let ((d (GetNewDialog 128 0 -1))
		(type (make-string 2 0))
		(h (make-string 4 0))
		(box (make-rect))
		item)
	(setq item (NewPtr 2))
	(if (zerop (MemError))
		(progn
		  (setq dialog-user-item-callback-proc-list (list (cons 1 (function draw-version))
														  (cons 2 (function draw-copyright))))
		  (GetDItem d 1 type h box)
		  (SetDItem d 1 (extract-internal type 0 'short) dialog-user-item-callback box)
		  (GetDItem d 2 type h box)
		  (SetDItem d 2 (extract-internal type 0 'short) dialog-user-item-callback box)
		  (ShowWindow d)
		  (InitCursor)
		  (encode-internal item 0 'short 0)
		  (while (zerop (extract-internal item 0 'short))
			(ModalDialog (function about-filter) item))
		  (DisposPtr item)
		  (DisposeDialog d)))))
