/*	Harvest C	Copyright 1992 Eric W. Sink.  All rights reserved.		This file is part of Harvest C.		Harvest C is free software; you can redistribute it and/or modify	it under the terms of the GNU Generic Public License as published by	the Free Software Foundation; either version 2, or (at your option)	any later version.		Harvest C is distributed in the hope that it will be useful,	but WITHOUT ANY WARRANTY; without even the implied warranty of	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the	GNU General Public License for more details.		You should have received a copy of the GNU General Public License	along with Harvest C; see the file COPYING.  If not, write to	the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.		Harvest C is not in any way a product of the Free Software Foundation.	Harvest C is not GNU software.	Harvest C is not public domain.	This file may have other copyrights which are applicable as well.*//* * Harvest C *  * Copyright 1991 Eric W. Sink   All rights reserved. *  * This file implements operations on type records. *  */#include "Common.h"#include "assert.h"#include "CHarvestDoc.h"#include "CHarvestOptions.h"extern CHarvestDoc *gProject;#pragma segment TypeRecords#include "TypeRecord.h"#include "SymTable.h"#include "ParseTree.h"#include "AbsString.h"#include "DynArray.h"struct TypeRecord {    enum TypeRecordCode             typekind;    long                            typesize;    unsigned short                  typeflags;    ParseTreeVia_t                  trapvalue;    struct paramrec P__H           *Param;    enum StorageClassCode           type_qual;    enum SignCode                   sign;    SymListVia_t                    Members;    TypeRecordVia_t                 DerivedFrom;#ifdef Undefined    TypeRecordVia_t                 next;	/* Used to maintain a global						 * list of type records, for						 * deallocation upon exit. */#endif    AbsStringID                     nameID;};static int                      CountAllTypeRecords;static TypeRecordVia_t          PTRvoidTemplate;static TypeRecordVia_t          PTRlongdoubleTemplate;static TypeRecordVia_t          PTRfloatTemplate;static TypeRecordVia_t          PTRdoubleTemplate;static TypeRecordVia_t          PTRuintTemplate;static TypeRecordVia_t          PTRucharTemplate;static TypeRecordVia_t          PTRushortTemplate;static TypeRecordVia_t          PTRulongTemplate;static TypeRecordVia_t          PTRsintTemplate;static TypeRecordVia_t          PTRscharTemplate;static TypeRecordVia_t          PTRsshortTemplate;static TypeRecordVia_t          PTRslongTemplate;static TypeRecordVia_t          voidTemplate;static TypeRecordVia_t          longdoubleTemplate;static TypeRecordVia_t          floatTemplate;static TypeRecordVia_t          doubleTemplate;static TypeRecordVia_t          uintTemplate;static TypeRecordVia_t          ucharTemplate;static TypeRecordVia_t          ushortTemplate;static TypeRecordVia_t          ulongTemplate;static TypeRecordVia_t          sintTemplate;static TypeRecordVia_t          scharTemplate;static TypeRecordVia_t          sshortTemplate;static TypeRecordVia_t          slongTemplate;static TypeRecordVia_t          TypeRecordPile = 0;	/* The type record pile */static StringPoolVia_t          TypeRecordStrings = 0;static DynArrayVia_t            TypeRecordArray = 0;TypeRecord_t                   *TP_ID2Obj(TypeRecordVia_t tpid){    return GetObject(TypeRecordArray, tpid);}voidInitTypes(void){	TypeRecordArray = 0;	TypeRecordStrings = 0;    FreeTypeRecords();    TypeRecordStrings = RawStringPool(1000);    TypeRecordArray = RawDynArray(sizeof(TypeRecord_t), 4000);    CountAllTypeRecords = 0;    /* Globals for reused type records */    PTRfloatTemplate = 0;    PTRdoubleTemplate = 0;    PTRlongdoubleTemplate = 0;    PTRvoidTemplate = 0;    PTRucharTemplate = 0;    PTRushortTemplate = 0;    PTRuintTemplate = 0;    PTRulongTemplate = 0;    PTRscharTemplate = 0;    PTRsshortTemplate = 0;    PTRsintTemplate = 0;    PTRslongTemplate = 0;    floatTemplate = 0;    doubleTemplate = 0;    longdoubleTemplate = 0;    voidTemplate = 0;    ucharTemplate = 0;    ushortTemplate = 0;    uintTemplate = 0;    ulongTemplate = 0;    scharTemplate = 0;    sshortTemplate = 0;    sintTemplate = 0;    slongTemplate = 0;    /* Build the reusable type records */    floatTemplate = BuildTypeRecord(0, TRC_float, SGN_unknown);    doubleTemplate = BuildTypeRecord(0, TRC_double, SGN_unknown);    longdoubleTemplate = BuildTypeRecord(0, TRC_longdouble, SGN_unknown);    voidTemplate = BuildTypeRecord(0, TRC_void, SGN_unknown);    ucharTemplate = BuildTypeRecord(0, TRC_char, SGN_unsigned);    ushortTemplate = BuildTypeRecord(0, TRC_short, SGN_unsigned);    uintTemplate = BuildTypeRecord(0, TRC_int, SGN_unsigned);    ulongTemplate = BuildTypeRecord(0, TRC_long, SGN_unsigned);    scharTemplate = BuildTypeRecord(0, TRC_char, SGN_signed);    sshortTemplate = BuildTypeRecord(0, TRC_short, SGN_signed);    sintTemplate = BuildTypeRecord(0, TRC_int, SGN_signed);    slongTemplate = BuildTypeRecord(0, TRC_long, SGN_signed);    PTRfloatTemplate = BuildTypeRecord(floatTemplate, TRC_pointer, SGN_unknown);    PTRdoubleTemplate = BuildTypeRecord(doubleTemplate, TRC_pointer, SGN_unknown);    PTRlongdoubleTemplate = BuildTypeRecord(longdoubleTemplate, TRC_pointer, SGN_unknown);    PTRvoidTemplate = BuildTypeRecord(voidTemplate, TRC_pointer, SGN_unknown);    PTRucharTemplate = BuildTypeRecord(ucharTemplate, TRC_pointer, SGN_unknown);    PTRushortTemplate = BuildTypeRecord(ushortTemplate, TRC_pointer, SGN_unknown);    PTRuintTemplate = BuildTypeRecord(uintTemplate, TRC_pointer, SGN_unknown);    PTRulongTemplate = BuildTypeRecord(ulongTemplate, TRC_pointer, SGN_unknown);    PTRscharTemplate = BuildTypeRecord(scharTemplate, TRC_pointer, SGN_unknown);    PTRsshortTemplate = BuildTypeRecord(sshortTemplate, TRC_pointer, SGN_unknown);    PTRsintTemplate = BuildTypeRecord(sintTemplate, TRC_pointer, SGN_unknown);    PTRslongTemplate = BuildTypeRecord(slongTemplate, TRC_pointer, SGN_unknown);}#ifdef Undefinedstatic voidFreeTypes(TypeRecordVia_t head){    TypeRecordVia_t                 nxt;    while (head) {	/*	 * We do NOT free the trapvalue because a copy is left in the Symbol	 * record	 */	if (GetTPMembers(head)) {	    FreeSymbolList(GetTPMembers(head), 0);	}	nxt = Via(head)->next;	Efree(head);	head = nxt;    }}#endifvoidFreeTypeRecords(void){    int                             i;#ifdef Undefined    if (TypeRecordPile)	FreeTypes(TypeRecordPile);    TypeRecordPile = 0;#else    if (TypeRecordArray) {	for (i = 1; i <= CountAllTypeRecords; i++) {	    TypeRecordVia_t                 tp;	    tp = i * sizeof(TypeRecord_t);	    FreeSymbolList(GetTPMembers(tp), 0);	}	KillDynArray(TypeRecordArray);    }    TypeRecordArray = 0;    CountAllTypeRecords = 0;    if (TypeRecordStrings)	KillStringPool(TypeRecordStrings);    TypeRecordStrings = 0;#endif}TypeRecordVia_tStripTypedef(TypeRecordVia_t a){    TypeRecordVia_t                 result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_typedef:	    return StripTypedef(GetTPBase(a));	    break;	default:	    return a;	}    }    return result;}intSameType(TypeRecordVia_t a, TypeRecordVia_t b){    /*     * If the two TypeRecords are equivalent, then this routine returns 1,     * else 0     */    /*     * This routine is strict.  Coercion routines handle border cases.     * Assignment of (unsigned int *) = (int *) should not produce an error.     * The MOVE instruction between address regs should be generated, but it     * should produce a warning, because the pointers are not of identical     * type. In other words, the warnings for pointers of identical type use     * stricter type checking.  Also, (unsigned int) = (int) should not     * produce an error or a warning, but the compiler has to recognize a     * difference in type so it can generate type conversion code.  Also.     * structs should have their arg lists checked as well.     */    int                             result;    result = 0;    if (a && b) {	if (a == b) {	    return 1;	}	if (GetTPKind(a) == TRC_typedef) {	    if (GetTPKind(b) == TRC_typedef) {		result = SameType(GetTPBase(a), GetTPBase(b));	    } else {		result = SameType(GetTPBase(a), b);	    }	} else if (GetTPKind(b) == TRC_typedef) {	    result = SameType(a, GetTPBase(b));	} else {	    if (GetTPKind(a) == GetTPKind(b)) {		if (isIntegralType(a)) {		    if (GetTPSign(a) == GetTPSign(b)) {			result = 1;			if (GetTPBase(a) && GetTPBase(b)) {			    result = SameType(GetTPBase(a), GetTPBase(b));			}		    }		} else if (isStructUnionType(a) || isEnumType(a) ||			   isFunctionType(a)) {		    TypeRecordVia_t                 a1;		    TypeRecordVia_t                 b1;		    a1 = StripTypedef(a);		    b1 = StripTypedef(b);		    if (SameTable(GetTPMembers(a1), GetTPMembers(b1))) {			result = 1;		    } else {			result = 0;		    }		    /* QQQQ Can I make this assumption ?? */		    if (isStructUnionType(a) && isStructUnionType(b)) {			if (a != b)			    result = 0;			else			    result = 1;		    } else if (GetTPBase(a) && GetTPBase(b)) {			result = result && SameType(GetTPBase(a), GetTPBase(b));		    }		} else {		    result = 1;		    if (GetTPBase(a) && GetTPBase(b)) {			result = SameType(GetTPBase(a), GetTPBase(b));		    }		}	    } else {		result = 0;	    }	}    }    return result;}TypeRecordVia_tisPointerType(TypeRecor){    /*     * If the arg a is a pointer to type X, then this routine returns type X,     * else 0.     */    TypeRecordVia_t                 result;    result = 0;    if (a) {	if (GetTPKind(a) == TRC_pointer) {	    result = GetTPBase(a);	} else {	    if (GetTPKind(a) == TRC_typedef) {		result = isPointerType(GetTPBase(a));	    } else {		result = 0;	    }	}    }    return result;}intisIncompleteType(TypeRecordVia_t a){    int                             result;    result = 0;    result = (GetTPFlags(a) & INCOMPLETEMASK);    return result;}intisVoidType(TypeRecordVia_t a){    int                             result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_void:	    result = 1;	    break;	case TRC_typedef:	    result = isVoidType(GetTPBase(a));	    break;	default:	    result = 0;	    break;	}    }    return result;}intisVoidPointerType(TypeRecordVia_t a){    TypeRecordVia_t                 temp;    int                             result;    result = 0;    temp = isPointerType(a);    if (temp) {	result = isVoidType(temp);    }    return result;}intisIntegralType(TypeRecordVia_t a){    /*     * If the arg a is any integer type or char type, this routine returns 1,     * else 0.     */    int                             result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_char:	case TRC_short:	case TRC_int:	case TRC_long:	case TRC_bitfield:	case TRC_comp:	case TRC_enum:	    result = 1;	    break;	case TRC_typedef:	    result = isIntegralType(GetTPBase(a));	    break;	default:	    result = 0;	    break;	}    }    return result;}intisFloatingType(TypeRecordVia_t a){    /*     * If the arg a is a float, double, or long double, this routine returns     * 1, else 0.     */    int                             result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_float:	case TRC_double:	case TRC_longdouble:	    result = 1;	    break;	case TRC_typedef:	    resuÆ÷Ñ    loatingType(GetTPBase(a));	    break;	default:	    result = 0;	    break;	}    }    return result;}intisExtendedFloatingType(TypeRecordVia_t tp){    if (GetTPKind(tp) == TRC_longdouble)	return 1;    else	return 0;}intisLongFloatingType(TypeRecordVia_t tp){    if (GetTPKind(tp) == TRC_double)	return 1;    else	return 0;}intisShortFloatingType(TypeRecordVia_t tp){    if (GetTPKind(tp) == TRC_float)	return 1;    else	return 0;}intisArithmeticType(TypeRecordVia_t a){    /*     * If the arg a is any floating type, any char, enum, or any kind of int,     * then this routine returns 1, else 0.     */    int                             result;    result = 0;    if (a) {	if (isIntegralType(a) || isFloatingType(a)) {	    result = 1;	} else {	    result = 0;	}    }    return result;}intisBooleanType(TypeRecordVia_t a){    /*     * If the arg a is any floating type, any char, enum, or any kind of int,     * then this routine returns 1, else 0.     */    int                             result;    result = 0;    if (a) {	if (isArithmeticType(a) || isPointerType(a)) {	    result = 1;	} else {	    result = 0;	}    }    return result;}SymListVia_tisStructUnionType(TypeRecordVia_t a){    /*     * If the arg a is a struct/union, this routine returns 1, else 0.     */    SymListVia_t                    result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_struct:	case TRC_union:	    result = GetTPMembers(a);	    break;	case TRC_typedef:	    result = isStructUnionType(GetTPBase(a));	    break;	default:	    result = 0;	    break;	}    }    return result;}TypeRecordVia_tisArrayType(TypeRecordVia_t a){    /*     * If the type in the arg is an array of type X, then this routine     * returns type X, else 0.     */    TypeRecordVia_t                 result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_array:	    result = GetTPBase(a);	    break;	case TRC_typedef:	    result = isArrayType(GÙ‹«9    (a));	    break;	default:	    result = 0;	    break;	}    }    return result;}intisLongType(TypeRecordVia_t a){    /*     * If the type in the arg is long, then this routine returns 1, else 0.     */    int                             result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_long:	    result = 1;	    break;	case TRC_typedef:	    result = isLongType(GetTPBase(a));	    break;	default:	    result = 0;	    break;	}    }    return result;}intisCharType(TypeRecordVia_t a){    /*     * If the type in the arg is char, then this routine returns 1, else 0.     */    int                             result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_char:	    result = 1;	    break;	case TRC_typedef:	    result = isCharType(GetTPBase(a));	    break;	default:	    result = 0;	    break;	}    }    return result;}intisSignedType(TypeRecordVia_t a){    /*     * If the type in the arg is signed, then this routine returns 1, else 0.     */    int                             result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_typedef:	    result = isSignedType(GetTPBase(a));	    break;	default:	    result = (GetTPSign(a) == SGN_signed);	    break;	}    }    return result;}intisUnsignedType(TypeRecordVia_t a){    /*     * If the type in the arg is unsigned, then this routine returns 1, else     * 0.     */    int                             result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_typedef:	    result = isUnsignedType(GetTPBase(a));	    break;	default:	    result = (GetTPSign(a) == SGN_unsigned);	    break;	}    }    return result;}intisBitFieldType(TypeRecordVia_t a){    /*     * If the type in the arg is bit field, then this routine returns 1, else     * 0.     */    int                             result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_bitfield:	    result = 1;	    break;	case TRC_typedef:	    res¼q|    BitFieldType(GetTPBase(a));	    break;	default:	    result = 0;	    break;	}    }    return result;}intisEnumType(TypeRecordVia_t a){    /*     * If the type in the arg is enum, then this routine returns 1, else 0.     */    int                             result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_enum:	    result = 1;	    break;	case TRC_typedef:	    result = isEnumType(GetTPBase(a));	    break;	default:	    result = 0;	    break;	}    }    return result;}TypeRecordVia_tGetFuncType(TypeRecordVia_t a){    TypeRecordVia_t                 result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_ANSIfunction:	case TRC_ANSIELLIPSISfunction:	case TRC_OLDfunction:	case TRC_NOARGSfunction:	    result = a;	    break;	case TRC_typedef:	    result = GetFuncType(GetTPBase(a));	    break;	default:	    result = 0;	    break;	}    }    return result;}intCountFuncArgs(TypeRecordVia_t a){    TypeRecordVia_t                 b;    b = GetFuncType(a);    if (b)	return Via(GetTPMembers(b))->count;    else	return 0;}TypeRecordVia_tisFunctionType(TypeRecordVia_t a){    /*     * If the type in the arg is a function return type X, then this routine     * returns type X, else 0.     */    TypeRecordVia_t                 result;    result = 0;    if (a) {	switch (GetTPKind(a)) {	case TRC_ANSIfunction:	case TRC_ANSIELLIPSISfunction:	case TRC_OLDfunction:	case TRC_NOARGSfunction:	    result = GetTPBase(a);	    break;	case TRC_typedef:	    result = isFunctionType(GetTPBase(a));	    break;	default:	    result = 0;	    break;	}    }    return result;}SYMVia_tisMemberOf(TypeRecordVia_t a, char *id){    /*     * If the arg a is a struct/union, and the arg id is a member of a, then     * this routine returns the type of that member, else 0.     */    SYMVia_t                        result;    SYMVia_t                        found;    SymListVia_t                    members;    result = 0;    if ('Ú³=     = isStructUnionType(a)) != 0) {		found = TableSearch(members, id);		if (found) {		    result = found;		}    } else {		return NULL;    }    return result;}intStartLValue(TypeRecordVia_t a)/* Initializes the LValue field for a primary expression. */{    int                             result = 0;    if (GetTPQual(a) == SCC_const) {		return 0;    }    switch (GetTPKind(a)) {    case TRC_char:    case TRC_short:    case TRC_int:    case TRC_long:    case TRC_enum:		/* Valid for enum variables, not constants. */    case TRC_float:    case TRC_double:    case TRC_longdouble:    case TRC_pointer:    case TRC_struct:		/* QQQQ Should this be here ? */    case TRC_union:		/* QQQQ Should this be here ? */	result = 1;	break;    case TRC_void:	VeryBadParseError("An identifier with type void");	break;    case TRC_typedef:	result = StartLValue(GetTPBase(a));	break;    default:	result = 0;	break;    }    return result;}static                          TypeRecordVia_tRawTypeRecord(char *tag){    register TypeRecordVia_t        raw;    AbsStringID                     s;    TypeRecord_t                   *obj;    raw = AddObject(TypeRecordArray);#ifdef Undefined    raw = Ealloc(sizeof(TypeRecord_t));    Via(raw)->typekind = 0;    Via(raw)->typesize = 0;	/* This should be overridden in all cases. */    Via(raw)->trapvalue = 0;    Via(raw)->Param = 0;    Via(raw)->typeflags = 0;    Via(raw)->type_qual = 0;    SetTPSign(raw, SGN_unknown);    Via(raw)->Members = 0;    if (tag) {	Via(raw)->nameID = PutString(TypeRecordStrings, tag);    } else	Via(raw)->nameID = 0;    Via(raw)->DerivedFrom = 0;    Via(raw)->next = TypeRecordPile;    TypeRecordPile = raw;#endif    SetTPSign(raw, SGN_unknown);    s = PutString(TypeRecordStrings, tag);    Éöj = TP_UD2Obj(raw);    obj->nameID = s;    CountAllTypeRecords++;    return raw;}TypeRecordVia_tInheritTypeRec(TypeRecordVia_t kvperclaus){    return 0;			/* TODO */}Typ3ecordViC_tCopäTypeRecoVd(TypeR½cordViaG&$‹        /    ÚO The ríle is : w+eneveV¡you moô	fy a type record, make a copy and only     * modify yourhcopy.F This ïöutine does not use struct assignment,     * because the "next" field should nZ be ch§®ged. º   */ øÿ TypeRÚBordViat                 raw;    char                         &  nm[6Æ;    eItern                          SymListVia_t                                   uCopySymÁable(SymListVia!à table;    raw = 0;    if (old) {	GetAbsString(TypeRecordStrings, ¼žtTPName\D(old), nm);	raw = RawTypeRecord(nm);	SetTPKind(raw, GetTPKind(old));	SetTPSize(raw  GetTPSize(old));	SetT¼Trap(raw, GetTPTrap(old));	SetTPFlags(raw, GetTPFlags(old));	SetTPQual¨raw, GetTPQual(old));	[etTPSign(raw, GetTPSign(old));	SetT«Members(raw, CopySymTabô=(GetTPMembers(old)));	SetTPBase(raw, GetTPBase(old));    }    returnraw;}voidSetTypeSize(TypeRecordVia_t rec){    /*     * This routine accepts a tperecorË, and sets the ’Üze of phat type     * record according to the typekind specified     O/    fÔitch (GetTPKind(rec)) {	case TRC_char:	SetTPSize(rec, 1);	SetTPFlags(rec, G-tTPFlagõ(rec) | SIZEDON  ;	breÌk;    ðase TRC_short:	SetTPSize(rec, 2);	SetTPFlags(rec, GetT4Flags(ªèc) | SIÖEDONE);	break;    case TRC_int:    	if (gProject) {		if (gProject->itsOptins->int2byte)		    SetÁSize(rÈc, 2)>•		else		    SetTPSize(rec, 4);	}	else {		    SetTPSiïó(rec, 4T;	}¬SetTPFlags(rec, GetTPFlags(rec) | SIZEDONE);	break;    case TRC_long:	SetTPSiše(reci 4);	SpOTPFlags(Sec, GæTPFlago¨rec) | SIZEDONE);	break;    case TRC_comp:	SetTPSize(r>c, 8)+	SetT,¿lags(rec,!GetTåFlags(re) | SIZEDONE);	break;    case TRC_float:	SetTPSize(]åc, 4);ì	SetTPFlags(rec GetTPF™gs(recé | SIZEDONE);	break;    case TRC_double:	SetTPSize(re{, 8);²ˆetTPFlaus(rec, GetTPFlags(rec) | SIZEDONE);	break;    case TRC_longdouble:	if (gProject) {		if (gProject->itsOptions->useMC68881)		    SetTPSize(rec, 12);		else		    SetTPSize(rec, 10);	}	else {	    SetTPSize(rec, 10);	}	SetTPFlags(rec, GetTP¸Fþë    c) | SIZEDONE);	break;    case TRC_enum:    	if (gProject) {		if (gProject->itsOptions->int2byte)		    SetTPSize(rec, 2);		else		    SetTPSize(rec, 4);	}	else {	    SetTPSize(rec, 4);	}	SetTPFlags(rec, GetTPFlags(rec) | SIZEDONE);	break;    case TRC_void:	SetTPSize(rec, 1);	/* QQQQ Is this right ? */	SetTPFlags(rec, GetTPFlags(rec) | SIZEDONE);	break;    case TRC_pointer:	SetTPSize(rec, 4);	SetTPFlags(rec, GetTPFlags(rec) | SIZEDONE);	break;    case TRC_typedef:	SetTPSize(rec, GetTPSize(GetTPBase(rec)));	break;    case TRC_array:    case TRC_ANSIfunction:    case TRC_NOARGSfunction:    case TRC_OLDfunction:    case TRC_struct:    case TRC_union:	break;    default:	SetTPSize(rec, 4);	break;    }}SymListVia_tGetTPMembers(TypeRecordVia_t t){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    return obj->Members;}voidSetTPMembers(TypeRecordVia_t t, SymListVia_t m){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    obj->Members = m;}TypeRecordVia_tGetTPBase(TypeRecordVia_t t){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    return obj->DerivedFrom;}voidSetTPBase(TypeRecordVia_t t, TypeRecordVia_t b){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    obj->DerivedFrom = b;}intGetTPSize(TypeRecordVia_t t){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    switch (GetTPKind(t)) {    case TRC_typedef:	return GetTPSize(obj->DerivedFrom);	break;    default:	return obj->typesize;    }}intGetTPKind(TypeRecordVia_t t){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    return obj->typekind;}voidSetTPKind(TypeRecordVia_t t, int k){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    obj->typekind =¶(}    ntGetTPFlags(TypeRecordVia_t t){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    return obj->typeflags;}enum SignCodeGetTPSign(TypeRecordVia_t t){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    return obj->sign;}voidSetTPSign(TypeRecordVia_t t, enum SignCode s){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    obj->sign = s;}AbsStringIDGetTPNameID(TypeRecordVia_t t){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    return obj->nameID;}voidGetTPName(TypeRecordVia_t t, char *nm){    assert(t);    assert(nm);    GetAbsString(TypeRecordStrings, GetTPNameID(t), nm);}ParamRecVia_tGetTPParam(TypeRecordVia_t t){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    return obj->Param;}voidSetTPParam(TypeRecordVia_t t, ParamRecVia_t p){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    obj->Param = p;}ParseTreeVia_tGetTPTrap(TypeRecordVia_t t){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    return obj->trapvalue;}voidSetTPTrap(TypeRecordVia_t t, ParseTreeVia_t p){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    obj->trapvalue = p;}enum StorageClassCodeGetTPQual(TypeRecordVia_t t){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    return obj->type_qual;}voidSetTPQual(TypeRecordVia_t t, enum StorageClassCode q){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    obj->type_qual = q;}voidSetTPSize(TypeRecordVia_t t, int sz){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    obj->typesize = sz;}voidS%üÜI    s(TypeRecordVia_t t, int f){    TypeRecord_t                   *obj;    assert(t);    obj = TP_ID2Obj(t);    assert(obj);    obj->typeflags = f;}TypeRecordVia_tBuildTypeRecord(TypeRecordVia_t base, enum TypeRecordCode kind, enum SignCode sign)/* * This is the principal routine used for building type records. */{    TypeRecordVia_t                 build;    assert(sign);    build = 0;    switch (kind) {    case TRC_char:	if (sign == SGN_signed) {	    if (scharTemplate) {		return scharTemplate;	    }	} else {	    if (ucharTemplate) {		return ucharTemplate;	    }	}	break;    case TRC_int:	if (sign == SGN_signed) {	    if (sintTemplate) {		return sintTemplate;	    }	} else {	    if (uintTemplate) {		return uintTemplate;	    }	}	break;    case TRC_short:	if (sign == SGN_signed) {	    if (sshortTemplate) {		return sshortTemplate;	    }	} else {	    if (ushortTemplate) {		return ushortTemplate;	    }	}	break;    case TRC_long:	if (sign == SGN_signed) {	    if (slongTemplate) {		return slongTemplate;	    }	} else {	    if (ulongTemplate) {		return ulongTemplate;	    }	}	break;    case TRC_void:	if (voidTemplate) {	    return voidTemplate;	}	break;    case TRC_float:	if (floatTemplate) {	    return floatTemplate;	}	break;    case TRC_double:	if (doubleTemplate) {	    return doubleTemplate;	}	break;    case TRC_longdouble:	if (longdoubleTemplate) {	    return longdoubleTemplate;	}	break;    case TRC_pointer:	if (base == voidTemplate) {	    if (PTRvoidTemplate) {		return PTRvoidTemplate;	    }	}	if (base == floatTemplate) {	    if (PTRfloatTemplate) {		return PTRfloatTemplate;	    }	}	if (base == doubleTemplate) {	    if (PTRdoubleTemplate) {		return PTRdoubleTemplate;	    }	}	if (base == longdoubleTemplate) {	    if (PTRlongdoubleTemplate) {		return PTRlongdoubleTemplate;	    }	}	if (base == ucharTemplate) {	    if (PTRucharTemplate) {		return PTRucharTemplate;	    }	}	if (base == ushortTemplate) {	    if (öÜˆ    PTRushortTemplate) {		return PTRushortTemplate;	    }	}	if (base == uintTemplate) {	    if (PTRuintTemplate) {		return PTRuintTemplate;	    }	}	if (base == ulongTemplate) {	    if (PTRulongTemplate) {		return PTRulongTemplate;	    }	}	if (base == scharTemplate) {	    if (PTRscharTemplate) {		return PTRscharTemplate;	    }	}	if (base == sshortTemplate) {	    if (PTRsshortTemplate) {		return PTRsshortTemplate;	    }	}	if (base == sintTemplate) {	    if (PTRsintTemplate) {		return PTRsintTemplate;	    }	}	if (base == slongTemplate) {	    if (PTRslongTemplate) {		return PTRslongTemplate;	    }	}	break;    default:	break;    }    build = RawTypeRecord(0);    SetTPBase(build, base);    SetTPKind(build, kind);    SetTPSign(build, sign);    if (kind == TRC_typedef) {	SetTPSign(build, GetTPSign(base));    }    if (base)	SetTPFlags(build, GetTPFlags(base));    SetTypeSize(build);    return build;}TypeRecordVia_tBuildTagTypeRecord(TypeRecordVia_t base, enum TypeRecordCode kind, char *tag){    TypeRecordVia_t                 build;    enum SignCode                   sign = SGN_unknown;    build = 0;    switch (kind) {    case TRC_typedef:	break;    case TRC_struct:	break;    case TRC_union:	break;    case TRC_enum:	sign = SGN_signed;	break;    default:	break;    }    build = RawTypeRecord(tag);    SetTPBase(build, base);    SetTPKind(build, kind);    SetTPSign(build, sign);    if (kind == TRC_typedef) {	SetTPSign(build, GetTPSign(base));    }    if (base)	SetTPFlags(build, GetTPFlags(base));    SetTypeSize(build);    return build;}