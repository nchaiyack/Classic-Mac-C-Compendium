//	Includes//	========#include "Gabi481Includes"#include "Gabi481.h"//	Functions//	=========void	Debug(Str255 arg){	DebugStr(arg);}short	RoundFiltConv(short maxvalue, double argdouble){									short	erg = 0;	double	fraction=0,			ip=0;	if (argdouble < 0)		return(erg);	fraction = modf(argdouble, &ip);	if (ip > (double)maxvalue)		return(maxvalue);	if (fraction >= (double) 0.5)		erg = (short)ceil(argdouble);	else 		erg = (short)floor(argdouble);	return (erg);}void	SetPrinterLineWidth(short Value1,short Value2){			OSErr	err = noErr;	Handle	myLineWid;			myLineWid = NewHandle(sizeof(Point));	err = MemError();	if(err)		ErrorHandler(rMemError);	if(myLineWid != 0L)	{		HLock(myLineWid);		SetPt((Point *)*myLineWid, (short)Value1, (short)Value2);		//HIER WIRD DAS VERH€LTNIS FESTGELEGT:		//MacPt : PrinterPt		HUnlock(myLineWid);		//PicComment(SetLineWidth, 4, myLineWid);		//=PicComment(182, 4, myLineWid); 		//Hier mu§ immer 4 stehen, da Size!																			PicComment(182, 4, myLineWid);		DisposHandle(myLineWid);	}}OSErr	Read_In(void){	OSErr 	err=noErr;	long	ByteCnt=0,			*ByteCntPtr=&ByteCnt;		err = HOpen(InFSS.vRefNum, InFSS.parID, InFSS.name, fsRdPerm, (short *)&fRefNum);	if (!err)		err = GetEOF(fRefNum, ByteCntPtr);	else 		return(err);	if (!err){		err = SetFPos(fRefNum, fsFromStart, 0L);	}	else 		return(err);	if (!err){		MemStr = (char *) calloc(ByteCnt, sizeof(char));		err = (NULL == MemStr);	}	else 		return(err);	if (!err)		err = FSRead(fRefNum, ByteCntPtr, (Ptr)MemStr);	else 		return(err);	if (!err)		err = FSClose(fRefNum);	return(err);}OSErr	Compute_Out(void){	OSErr 	err=noErr;	char	*AktStr=NULL,			Delims[5] = {9,10,13,127,0}, //LineFeed und CarriageReturn			Abbruch=0;	long	i=0L,			j=0L,			ByteCnt=0;	FILE	*fp = NULL;			if (!err)		err = (NULL == (fivex = (double *) malloc(sizeof(double))));	if (!err)		err = (NULL == (sevex = (double *) malloc(sizeof(double))));	if (!err)		err = (NULL == (ninex = (double *) malloc(sizeof(double))));	if (!err)		err = (NULL == (fivey = (double *) malloc(sizeof(double))));	if (!err)		err = (NULL == (sevey = (double *) malloc(sizeof(double))));	if (!err)		err = (NULL == (niney = (double *) malloc(sizeof(double))));	if (!err)		err = (NULL == (fivery = (double *) malloc(sizeof(double))));	if (!err)		err = (NULL == (severy = (double *) malloc(sizeof(double))));	if (!err)		err = (NULL == (ninery = (double *) malloc(sizeof(double))));	if (!err)		err = (NULL == (ergx = (double *) malloc(sizeof(double))));	if (!err)		err = (NULL == (ergy = (double *) malloc(sizeof(double))));	if (!err)		err = (NULL == (ergqy = (double *) malloc(sizeof(double))));	if(err)		ErrorHandler(rMemError);	ts = 60/46.5;	i=0L;	AktStr = strtok(MemStr, Delims);	do{		if ((!err) && (AktStr != NULL)){			err = (!sscanf(AktStr,"%le",(fivex+i)));			*(ninex+i) = *(sevex+i) = *(fivex+i);		}		if (!err)			AktStr = strtok(NULL, Delims);		if ((!err) && (AktStr != NULL))			err = (!sscanf(AktStr,"%le",(fivey+i)));		if (!err)			AktStr = strtok(NULL, Delims);		if ((!err) && (AktStr != NULL))			err = (!sscanf(AktStr,"%le",(sevey+i)));		if (!err)			AktStr = strtok(NULL, Delims);		if ((!err) && (AktStr != NULL))			err = (!sscanf(AktStr,"%le",(niney+i)));		if (!err)			AktStr = strtok(NULL, Delims);/*		if(err)			ErrorHandler(rInError);*///	Berechnungen		if (!err){			//	Berechnung des Mittelwertes der Zeit in Sekunden			ergx[i] = ts * ((fivex[i] + sevex[i] + ninex[i])/3);			if (ergx[i] <= 0)				ergx[i] = 0;			//	Berechnung des Summenwertes aller drei y-Werte			// ergqy[i] = fivey[i] + sevey[i] + niney[i];			// Expression too complex???			// Fehler hŠngt mit Automatic Register Assignment (Compiler Einstellung)			// zusammen, nicht genug Register!			ergqy[i] = fivey[i];			ergqy[i] += sevey[i];			ergqy[i] += niney[i];			//  Berechnung der relativen Werte			if ((ergqy[i] > 0) && (fivey[i] > 0))				fivery[i] = fivey[i] / ergqy[i];			else 				fivery[i] = 0;			if ((ergqy[i] > 0) && (sevey[i] > 0))				severy[i] = sevey[i] / ergqy[i];			else 				severy[i] = 0;			if ((ergqy[i] > 0) && (niney[i] > 0))				ninery[i] = niney[i] / ergqy[i];			else 				ninery[i] = 0;			//	Berechnung des logarithmierten relativen Wertes			if ((ergqy[i] <= 0) || (niney[i] <= 0)){				ergy[i] = 0;			}			else				ergy[i] = log10((100 * niney[i]) / ergqy[i]);		}	i++;	if (!err)		err = (NULL == (fivex = (double *) realloc(fivex, (i+1) * sizeof(double))));	if (!err)		err = (NULL == (sevex = (double *) realloc(sevex, (i+1) * sizeof(double))));	if (!err)		err = (NULL == (ninex = (double *) realloc(ninex, (i+1) * sizeof(double))));	if (!err)		err = (NULL == (fivey = (double *) realloc(fivey, (i+1) * sizeof(double))));	if (!err)		err = (NULL == (sevey = (double *) realloc(sevey, (i+1) * sizeof(double))));	if (!err)		err = (NULL == (niney = (double *) realloc(niney, (i+1) * sizeof(double))));	if (!err)		err = (NULL == (fivery = (double *) realloc(fivery, (i+1) * sizeof(double))));	if (!err)		err = (NULL == (severy = (double *) realloc(severy, (i+1) * sizeof(double))));	if (!err)		err = (NULL == (ninery = (double *) realloc(ninery, (i+1) * sizeof(double))));	if (!err)		err = (NULL == (ergx = (double *) realloc(ergx, (i+1) * sizeof(double))));	if (!err)		err = (NULL == (ergy = (double *) realloc(ergy, (i+1) * sizeof(double))));	if (!err)		err = (NULL == (ergqy = (double *) realloc(ergqy, (i+1) * sizeof(double))));	if(err)		ErrorHandler(rMemError);	if(!AktStr)		Abbruch++;	}while (!Abbruch);	n=i;// TestOut#ifdef TEST	fp = fopen("TestOut","w");	fprintf(fp,"%f\n",t);	fprintf(fp,"%f\n",A1);	fprintf(fp,"%f\n",A2);	fprintf(fp,"%f\n",A3);	fprintf(fp,"%f\n",A4);	fprintf(fp,"%ld\n",n);	for(i=0;i<n;i++){		fprintf(fp,"%f\n",*(fivex+i));		fprintf(fp,"%f\n",*(fivey+i));		fprintf(fp,"%f\n",*(sevex+i));		fprintf(fp,"%f\n",*(sevey+i));		fprintf(fp,"%f\n",*(ninex+i));		fprintf(fp,"%f\n",*(niney+i));	}	fclose(fp);#endif// TestOut Ende	return(err);}OSErr	Create_Out_File(FSSpec argFSS){	OSErr 	err=noErr;	Str63	CFileName;		OutFSS.vRefNum = argFSS.vRefNum;	OutFSS.parID = argFSS.parID;	strcpy((char *)CFileName, (const char *)PtoCstr(argFSS.name));	if(28 <= (short)strlen((const char*) CFileName))		ErrorHandler(rFileNameError);			strcat((char *)CFileName, (const char *)".PICT");	strcpy((char *)OutFSS.name, (const char *)CFileName);	CtoPstr((char *)OutFSS.name);	if (!err){		err = HCreate(OutFSS.vRefNum, OutFSS.parID, OutFSS.name, OutFCreat, OutFType);		if (err == dupFNErr)			err = 0;			//Falls Datei schon da wird sie eben Ÿberschrieben!	}	if (!err)		err = HOpen(OutFSS.vRefNum, OutFSS.parID, OutFSS.name, fsWrPerm, (short *)&fRefNum);	if (!err)		err = SetEOF(fRefNum, 0);	if (!err)		err = FSClose(fRefNum);	return(err);}OSErr	Create_Out_Port(void){		OSErr	err=noErr;		//SetRect(&theRect, RL, RT, RR, RB);		//SetRect(&theRect, rLeft, rTop, rRight, rBottom);	if (!err)		Port = NewWindow(NULL, &PageRect, "\p", FALSE, 0, NULL, FALSE, 0);	err = MemError();	if(err)		ErrorHandler(rMemError);	if (!err)		GetPort(&SavePort);	if (!err){		SetPort(Port);		if (!err)			ClipRect(&thePort->portRect);		if (!err){			PenSize(1,1);			PenMode(patCopy);			PenPat(black);			ForeColor(blackColor);			BackColor(whiteColor);		}	}	return(err);}OSErr	Draw_Axes(void){		OSErr	err = noErr;	int 	i=0;	TextFont(helvetica);	TextFace(0);	TextSize(10);	//SetRect(&theRect,G1RL, G1RT, G1RR, G1RB);	FrameRect(&G1Rect);	//SetRect(&theRect,G2RL, G2RT, G2RR, G2RB);	FrameRect(&G2Rect);	for(i = 1; i <= G1YSUC; i++){		MoveTo(G1RL, ((G1RB - 1) - (i * G1YSU)));		LineTo((G1RL + GSL), ((G1RB - 1) - (i * G1YSU)));		MoveTo((G1RL - YASSOX), (((G1RB - 1) - (i * G1YSU)) + YASSOY));		if (i != G1YSUC)			sprintf((char *)IOStr, "%3i", (10 * i));		else			sprintf((char *)IOStr, "[%%]");		DrawText((Ptr) IOStr, 0, (short)strlen((const char *)IOStr));	}	//SetPrinterLineWidth(4, 1);	for(i = 1; i <= G2YSUC; i++){		// MoveTo(x+1,725 - (i*15)); // FŸr dŸnnere Linien		MoveTo(G2RL, ((G2RB - 1) - (i * G2YSU)));		LineTo((G2RL + GSL), ((G2RB - 1) - (i * G2YSU)));		MoveTo((G2RL - YASSOX), (((G2RB - 1) - (i * G2YSU)) + YASSOY));		if (i != G2YSUC)			sprintf((char *)IOStr, "%3.1f", (float)( 1 + (((float)i) / 10)));		else			sprintf((char *)IOStr, "Log");		DrawText((Ptr) IOStr, 0, (short)strlen((const char *)IOStr));	}	for(i = 1; i <= G1XSUC; i++){		MoveTo(G1RL + (i * G1XSU), G1RB - 1);		LineTo(G1RL + (i * G1XSU), G1RB - GSL);		MoveTo(((G1RL + (i * G1XSU)) - XASSOX), (G1RB - 1) + XASSOY);		if (i != G1XSUC)			sprintf((char *)IOStr, "%1i", i);		else			sprintf((char *)IOStr, "[min]");		DrawText((Ptr) IOStr, 0, (short)strlen((const char *)IOStr));	}	for(i = 1; i <= G2XSUC; i++){		MoveTo(G2RL + (i * G2XSU), G2RB - 1);		LineTo(G2RL + (i * G2XSU), G2RB - GSL);		MoveTo(((G2RL + (i * G2XSU)) - XASSOX), (G2RB - 1) + XASSOY);		if (i != G2XSUC)			sprintf((char *)IOStr, "%1i", i);		else			sprintf((char *)IOStr, "[min]");		DrawText((Ptr) IOStr, 0, (short)strlen((const char *)IOStr));	}	//SetPrinterLineWidth(1, 4);	return(err);}void	Draw_Strings(void){		TextFont(helvetica);		TextFace(bold);		TextSize(12);		MoveTo(GreetStrX, GreetStrY);		DrawText((Ptr) GreetStr, 0, (short) strlen((const char *) GreetStr));		DrawString(InFSS.name);		TextFace(0);		TextSize(10);		MoveTo(RelStrX, RelStrY);		DrawText((Ptr) RelStr, 0, (short) strlen((const char *) RelStr));		MoveTo(AStrX, AStrY);		DrawText((Ptr) AStr, 0, (short) strlen((const char *) AStr));}OSErr	Draw_Values(void){	OSErr	err = noErr;	long	i = 0L;		err = (NULL == (Dlog = (Point *) calloc(n, sizeof(Point))));	if (!err)		err = (NULL == (Dfive = (Point *) calloc(n, sizeof(Point))));	if (!err)		err = (NULL == (Dseve = (Point *) calloc(n, sizeof(Point))));	if (!err)		err = (NULL == (Dnine = (Point *) calloc(n, sizeof(Point))));	if(err)		ErrorHandler(rMemError);	SetPrinterLineWidth(4, 1);	for(i=0;i<n;i++){		(Dlog+i)->v  = (short) (G2RB - RoundFiltConv(G2Y, ((*(ergy+i) - 1) * G2Y / MaxValY2)));		(Dfive+i)->v = (short) (G1RB - RoundFiltConv(G1Y, (*(fivery+i) * G1Y / MaxValY1)));		(Dseve+i)->v = (short) (G1RB - RoundFiltConv(G1Y, (*(severy+i) * G1Y /MaxValY1)));		Dnine[i].v = (short) (G1RB - RoundFiltConv(G1Y, (ninery[i] * G1Y / MaxValY1)));				(Dlog+i)->h = (short) (G2RL + RoundFiltConv(G2X, (*(ergx+i) * G2X / MaxValX2)));		(Dfive+i)->h = 		(Dseve+i)->h = 		Dnine[i].h = (short)(G1RL + RoundFiltConv(G1X, (ergx[i] * G1X / MaxValX1)));	}		ClipRect((Rect *)&G2Rect);//	if(PtInRect(*Dlog, (Rect *)&G2Rect)){		MoveTo(Dlog->h, Dlog->v);//	}		for(i=1;i<n;i++){//		if(PtInRect(*(Dlog+i), (Rect *)&G2Rect))			LineTo((Dlog+i)->h, (Dlog+i)->v);	}		ClipRect((Rect *)&G1Rect);	//ForeColor(redColor);	RGBForeColor(&RGBRed);//	if(PtInRect(*Dfive, (Rect *)&G1Rect)){		MoveTo(Dfive->h, Dfive->v);		SetRect((Rect *)&ArcRect, Dfive->h - CircRad, Dfive->v - CircRad, Dfive->h + CircRad, Dfive->v + CircRad);		//Pt2Rect(*Dfive, *Dfive, (Rect *)&ArcRect);		//InsetRect((Rect *)&ArcRect, -CircRad, -CircRad);		//OffsetRect((Rect *)&ArcRect, 0, 1);		//FrameArc((Rect *)&ArcRect, 0, 360);		//FillRect((Rect *)&ArcRect, black);		//FrameRect((Rect *)&ArcRect);		//FrameArc((Rect *)&ArcRect, 0, 360);		FrameRect((Rect *)&ArcRect);//	}		for(i=1;i<n;i++){//		if(PtInRect(*(Dfive+i), (Rect *)&G1Rect)){			LineTo((Dfive+i)->h, (Dfive+i)->v);			SetRect((Rect *)&ArcRect, (Dfive+i)->h - CircRad, (Dfive+i)->v - CircRad, (Dfive+i)->h + CircRad, (Dfive+i)->v + CircRad);			//Pt2Rect(*(Dfive+i), *(Dfive+i), (Rect *)&ArcRect);			//OffsetRect((Rect *)&ArcRect, 0, 1);			//InsetRect((Rect *)&ArcRect, -CircRad, -CircRad);			//FrameArc((Rect *)&ArcRect, 0, 360);			//FillRect((Rect *)&ArcRect, black);			//FrameRect((Rect *)&ArcRect);			//FrameArc((Rect *)&ArcRect, 0, 360);			FrameRect((Rect *)&ArcRect);//		}	}	//TextMode(srcXor);	// Geht nur auf Schirm und sieht doof aus!	DrawText((Ptr) M45Str, 0, (short) strlen((const char *) M45Str));	//ForeColor(greenColor);	RGBForeColor(&RGBGreen);//	if(PtInRect(*Dseve, (Rect *)&G1Rect)){		MoveTo(Dseve->h, Dseve->v);		SetRect((Rect *)&ArcRect, Dseve->h - CircRad, Dseve->v - CircRad, Dseve->h + CircRad, Dseve->v + CircRad);		FrameRect((Rect *)&ArcRect);//	}		for(i=1;i<n;i++){//		if(PtInRect(*(Dseve+i), (Rect *)&G1Rect))			LineTo((Dseve+i)->h, (Dseve+i)->v);			SetRect((Rect *)&ArcRect, (Dseve+i)->h - CircRad, (Dseve+i)->v - CircRad, (Dseve+i)->h + CircRad, (Dseve+i)->v + CircRad);			FrameRect((Rect *)&ArcRect);	}	DrawText((Ptr) M47Str, 0, (short) strlen((const char *) M47Str));	//ForeColor(blueColor);	RGBForeColor(&RGBBlue);//	if(PtInRect(*Dnine, (Rect *)&G1Rect)){		MoveTo(Dnine->h, Dnine->v);		SetRect((Rect *)&ArcRect, Dnine->h - CircRad, Dnine->v - CircRad, Dnine->h + CircRad, Dnine->v + CircRad);		FrameRect((Rect *)&ArcRect);//	}		for(i=1;i<n;i++){//		if(PtInRect(*(Dnine+i), (Rect *)&G1Rect))			LineTo((Dnine+i)->h, (Dnine+i)->v);			SetRect((Rect *)&ArcRect, (Dnine+i)->h - CircRad, (Dnine+i)->v - CircRad, (Dnine+i)->h + CircRad, (Dnine+i)->v + CircRad);			FrameRect((Rect *)&ArcRect);	}	DrawText((Ptr) M49Str, 0, (short) strlen((const char *) M49Str));	//TextMode(srcOr);	// Geht nur auf Schirm und sieht doof aus!		SetPrinterLineWidth(1, 4);}OSErr 	Draw_Chart(void){	OSErr	err=noErr;	myPicture = OpenPicture(&PageRect);	err = MemError();	if(err)		ErrorHandler(rMemError);	if (!err){		err = Draw_Axes();		//SetPrinterLineWidth(4, 1);		Draw_Strings();		err = Draw_Values();	}	ClosePicture();	err = MemError();	return(err);}OSErr	Delete_Out_Port(void){OSErr	err=noErr;	SetPort(SavePort);	err = MemError();	if (!err)		DisposeWindow(Port);	err = MemError();	return(err);}OSErr	Write_Out_Pict(void){OSErr	err=noErr;Handle	myHandle;Size	myHandleSize;	err = HOpen(OutFSS.vRefNum, OutFSS.parID, OutFSS.name, fsCurPerm, (short *)&fRefNum);	if (!err)		myHandle = NewHandleClear(512);	err = MemError();	if(err)		ErrorHandler(rMemError);	if (!err)		err = GetEOF(fRefNum, &curEOF);	if (!err)		err = SetFPos(fRefNum, fsFromStart, 0L);	if (!err)		myHandleSize = GetHandleSize(myHandle);	err = MemError();	if (!err) 		HLockHi(myHandle); 	err = MemError();	if (!err)		err = FSWrite(fRefNum, &myHandleSize, *myHandle);	if (!err)		HUnlock(myHandle);	err = MemError();	if (!err)		DisposeHandle(myHandle);	err = MemError();	if (!err)		err = GetEOF(fRefNum, &curEOF);	if (!err)		err = SetFPos(fRefNum, fsFromStart, 512L);	if (!err)		myHandleSize = GetHandleSize((Handle)myPicture);	err = MemError();	if (!err) 		HLockHi((Handle)myPicture); 	err = MemError();	if (!err)		err = FSWrite(fRefNum, &myHandleSize, *myPicture);	if (!err)		HUnlock((Handle)myPicture);	err = MemError();	if (!err)		err = FSClose(fRefNum);	if (!err)		KillPicture(myPicture);	err = MemError();	return(err);}OSErr	Reinit(void){OSErr	err=noErr;	if (fRefNum)		fRefNum = 0;	if (n)		n = 0L;	if (curEOF)		curEOF = 0L;	//if (FSSListLength)		//FSSListLength = 0L;	if (t)		t = 0;	if (A1)		A1 = 0;	if (A2)		A2 = 0;	if (A3)		A3 = 0;	if (A4)		A4 = 0;	if (MemStr != NULL){		free((void *)MemStr);		MemStr = NULL;	}	if (Dlog != NULL){		free((void *)Dlog);		Dlog = NULL;	}		if (Dfive != NULL){		free((void *)Dfive);		Dfive = NULL;	}		if (Dseve != NULL){		free((void *)Dseve);		Dseve = NULL;	}		if (Dnine != NULL){		free((void *)Dnine);		Dnine = NULL;	}		if (ergx != NULL){		free((void *)ergx);		ergx = NULL;	}		if (ergy != NULL){		free((void *)ergy);		ergy = NULL;	}		if (ergqy != NULL){		free((void *)ergy);		ergy = NULL;	}		if (fivex != NULL){		free((void *)fivex);		fivex = NULL;	}		if (sevex != NULL){		free((void *)sevex);		sevex = NULL;	}		if (ninex != NULL){		free((void *)ninex);		ninex = NULL;	}		if (fivey != NULL){		free((void *)fivey);		fivey = NULL;	}		if (sevey != NULL){		free((void *)sevey);		sevey = NULL;	}		if (niney != NULL){		free((void *)niney);			niney = NULL;	}	if (fivery != NULL){		free((void *)fivey);		fivey = NULL;	}		if (severy != NULL){		free((void *)sevey);		sevey = NULL;	}		if (ninery != NULL){		free((void *)niney);			niney = NULL;	}	//if (FSSList != NULL){	//	free((void *)FSSList);		//	FSSList = NULL;	//	FSSListPtr = NULL;	//}	return(err);}void	ErrorHandler(short errType){	short	AlID=0,			itemHit=0;	SysBeep(1);	switch(errType){	case 	rNoODocAlert:{							AlID = errType;						}							break;	case rMemError		:	case rInError		:	case rFileNameError	:	case rMiscError		:{							AlID = errType;							ParamText(InFSS.name,"\p" ,NULL ,0);						}						break;	}	if (AlID != 0){		do		{			itemHit = Alert(AlID, nil);		} while(itemHit != dOKButton);	}	else		SysBeep(3);	ExitToShell();}void	InitToolbox(){	InitGraf(&thePort);		// Standard initialization calls	InitFonts();	InitWindows();	InitMenus();	TEInit();	InitDialogs(nil);	InitCursor();}Boolean AppleEventsInstalled (){	OSErr err;	long  result;	// THINK C's MacTraps library provides glue for Gestalt, so	// it can be called safely under System 6. If an error is	// returned, then Gestalt for the AppleEvents Selector is	// not available (this also means that Apple Events are	// not available)	err = Gestalt (gestaltAppleEventsAttr, &result);	return (!err && ((result >> gestaltAppleEventsPresent) & 0x0001));											// return TRUE if there is no											// error and the proper bit of											// result is set}pascal OSErr  MyHandleODoc (AppleEvent *theAppleEvent, AppleEvent* reply, long														handlerRefCon){	AEDescList	docList;	OSErr		err;	long		index,				itemsInList;	Size		actualSize;	AEKeyword	keywd;	DescType	returnedType;	FSSpec		myFSS;	// get the direct parameter--a descriptor list--and put it into a docList	err = AEGetParamDesc (theAppleEvent, keyDirectObject, typeAEList,			&docList);	if (err)			return err;	// check for missing parameters	err = MyGotRequiredParams (theAppleEvent);	if (err)			return err;	// count the number of descriptor records in the list	err = AECountItems (&docList, &itemsInList);	// now get each descriptor record from the list, coerce the returned	// data to an FSSpec record, and open the associated file	err = (NULL == (FSSList = (FSSpec *) calloc (itemsInList, sizeof(FSSpec))));	if(err)		ErrorHandler(rMemError);	FSSListPtr = (FSSpec *) FSSList;	FSSListLength = itemsInList;	for (index = 1; index <= itemsInList; index++) {			err = AEGetNthPtr (&docList, index, typeFSS, &keywd,							&returnedType, (Ptr) &myFSS, sizeof(myFSS), &actualSize);			if (err)				return err;							(*FSSListPtr).vRefNum = myFSS.vRefNum;			(*FSSListPtr).parID = myFSS.parID;			memcpy((void *) &((*FSSListPtr).name), (const void *) &myFSS.name, (size_t) sizeof(Str63));			FSSListPtr++;			//Hier noch einlesen und verarbeiten!	}	FSSListPtr = FSSList;	err = AEDisposeDesc (&docList);	return err;}pascal OSErr  MyHandlePDoc (AppleEvent *theAppleEvent, AppleEvent *reply, long														handlerRefCon){	FSSpec	myFSS;	AEDescList	docList;	OSErr	err;	long	index,					itemsInList;	Size	actualSize;	AEKeyword	keywd;	DescType	returnedType;	// get the direct parameter--a descriptor list--and put it into a docList	err = AEGetParamDesc (theAppleEvent, keyDirectObject, typeAEList,									&docList);	if (err)			return err;	// check for missing parameters	err = MyGotRequiredParams (theAppleEvent);	if (err)			return err;	// count the number of descriptor records in the list	err = AECountItems (&docList, &itemsInList);	// now get each descriptor record from the list, coerce the returned	// data to an FSSpec record, and open the associated file	for (index = 1; index <= itemsInList; index++) {			err = AEGetNthPtr (&docList, index, typeFSS, &keywd,							&returnedType, (Ptr) &myFSS, sizeof(myFSS), &actualSize);			if (err)					return err;	}	err = AEDisposeDesc (&docList);	return noErr;}pascal OSErr  MyHandleOApp (AppleEvent *theAppleEvent, AppleEvent *reply, long														handlerRefCon){	ErrorHandler(rNoODocAlert);}OSErr MyGotRequiredParams (AppleEvent *theAppleEvent){	DescType	returnedType;	Size	actualSize;	OSErr	err;	err = AEGetAttributePtr (theAppleEvent, keyMissedKeywordAttr,									typeWildCard, &returnedType, nil, 0,									&actualSize);	if (err == errAEDescNotFound)	// you got all the required parameters			return noErr;	else if (!err)			// you missed a required parameter			return errAEEventNotHandled;	else					// the call to AEGetAttributePtr failed			return err;}main (){	Boolean		aEvents;	short 		doWhat;	short 		fileCnt;	long		i;	AppFile		fileStuff;	EventRecord	theEvent;	OSErr		err;	InitToolbox ();	aEvents = AppleEventsInstalled();	if (aEvents) {			err = AEInstallEventHandler (kCoreEventClass, kAEOpenDocuments,													MyHandleODoc,0, FALSE);			err = AEInstallEventHandler (kCoreEventClass, kAEOpenApplication,													MyHandleOApp,0, FALSE);			err = AEInstallEventHandler (kCoreEventClass, kAEPrintDocuments,													MyHandlePDoc,0, FALSE);			while (!gDone) {					if ( WaitNextEvent ( everyEvent, &theEvent, 0, nil ) ) {							switch (theEvent.what) {							case mouseDown:									gDone = TRUE;									break;							case kHighLevelEvent:									err = AEProcessAppleEvent (&theEvent);									FSSListPtr = FSSList;									for (i = 1; i <= FSSListLength; i++) {											InFSS.vRefNum = FSSListPtr->vRefNum;											InFSS.parID = FSSListPtr->parID;											memcpy((void *) InFSS.name, (const void *) &(FSSListPtr->name), (size_t)sizeof(Str63));											FSSListPtr++;											if (!err)												err = Read_In();											if (!err)												err = Compute_Out();											if (!err)												err = Create_Out_File(InFSS);											if (!err)												err = Create_Out_Port();											if (!err)												err = Draw_Chart();											if (!err)												err = Delete_Out_Port();											if (!err)												err = Write_Out_Pict();											if(!err)												Reinit();											if(err)												ErrorHandler(rMiscError);									}									gDone = TRUE;									break;							default:								break;							}					}			}	}	else {			//Get number of files double-clicked on by the user			SysBeep(10);			CountAppFiles ( &doWhat, &fileCnt );			if (fileCnt > 0) {	// if the user selected one or more files					if (doWhat == appOpen)	{							//printf ("Files to open:\n");							for (i = 1; i <= fileCnt; i++) {									GetAppFiles ( i, &fileStuff );									//printf ("%s\n", PtoCstr (fileStuff.fName));							}					}					else if (doWhat == appPrint) {							//printf ("Files to print:\n");							for (i = 1; i <= fileCnt; i++) {									GetAppFiles ( i, &fileStuff );									//printf ("%s\n", PtoCstr (fileStuff.fName));							}					}					for (i = 0; i < fileCnt; i++)							ClrAppFiles(i);					}			else					//printf ("No files to print or open\n");			while (!Button());	}	ExitToShell();}