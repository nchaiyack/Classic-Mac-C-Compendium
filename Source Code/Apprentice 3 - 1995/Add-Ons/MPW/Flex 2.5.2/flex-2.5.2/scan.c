#line 2 "scan.c"/*** * * A lexical scanner generated by flex * CEH - flex.skl modified by Christopher E. Hyde, 95-06-29 from v2.85 95/04/24 * ***/#define FLEX_SCANNER#define YY_FLEX_MAJOR_VERSION 2#define YY_FLEX_MINOR_VERSION 5#ifdef macintosh#pragma segment FlexScanner#endif#include <stdio.h>// cfront 1.2 defines "c_plusplus" instead of "__cplusplus"#if defined(c_plusplus) && !defined(__cplusplus)#define __cplusplus#endif#define	YY_C#define	YY_DECLARE(t)	static t #define	istream			FILE#define YY_USE_PROTOS	// Use prototypes in function declarations.#define YY_USE_CONST	// The "const" storage-class-modifier is valid.#ifdef __cplusplus#include <stdlib.h>//#include <unistd.h>#else	// ! __cplusplus#if __STDC__#endif	// __STDC__#endif	// ! __cplusplus#ifdef YY_USE_CONST#define yyconst const#else#define yyconst#endif#ifdef YY_USE_PROTOS#define YY_PROTO(proto) proto#else#define YY_PROTO(proto) ()#endif// Returned upon end-of-file.#define YY_NULL	0/* Promotes a possibly negative, possibly signed char to an unsigned * integer for use as an array index.  If the signed char is negative, * we want to instead treat it as an 8-bit unsigned char, hence the * double cast. */#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)/* Enter a start condition.  This macro really ought to take a parameter, * but we do it the disgusting crufty way forced on us by the ()-less * definition of BEGIN. */#define BEGIN yy_start = 1 + 2 */* Translate the current start state into a value that can be later handed * to BEGIN to return to the state.  The YYSTATE alias is for lex * compatibility. */#define YY_START ((yy_start - 1) / 2)#define YYSTATE YY_START// Action number for EOF rule of a given start state.#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)// Special action meaning "start processing a new file".#define YY_NEW_FILE yyrestart(yyin)#define YY_END_OF_BUFFER_CHAR 0// Size of default input buffer.#define YY_BUF_SIZE 16384typedef struct yy_buffer_state* YY_BUFFER_STATE;extern int yyleng;extern FILE *yyin, *yyout;#define EOB_ACT_CONTINUE_SCAN	0#define EOB_ACT_END_OF_FILE		1#define EOB_ACT_LAST_MATCH		2/* The funky do-while in the following #define is used to turn the definition * int a single C statement (which needs a semi-colon terminator).  This * avoids problems with code like: * * 	if (condition_holds) *		yyless(5); *	else *		do_something_else(); * * Prior to using the do-while the compiler would get upset at the * "else" because it interpreted the "if" statement as being all * done when it reached the ';' after the yyless() call. *//* Return all but the first 'n' matched characters back to the input stream. */#define yyless(n)	do { \		/* Undo effects of setting up yytext. */ \		*yy_cp = yy_hold_char; \		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \		YY_DO_BEFORE_ACTION; /* set up yytext again */ \	} while (0)#define unput(c)	yyunput(c, yytext_ptr)/* The following is because we cannot portably get our hands on size_t * (without autoconf's help, which isn't available because we want * flex-generated scanners to compile on their own). */typedef unsigned int yy_size_t;struct yy_buffer_state {	istream* yy_input_file;	char*	yy_ch_buf;		// input buffer	char*	yy_buf_pos;		// current position in input buffer	// Size of input buffer in bytes, not including room for EOB characters.	yy_size_t yy_buf_size;	// Number of characters read into yy_ch_buf, not including EOB characters.	int yy_n_chars;	/* Whether we "own" the buffer - i.e., we know we created it, and	 * can realloc() it to grow it, and should free() it to delete it.	 */	int yy_is_our_buffer;	/* Whether this is an "interactive" input source; if so, and if we're	 * using stdio for input, then we want to use getc() instead of	 * fread(), to make sure we stop fetching input after each newline.	 */	int yy_is_interactive;	/* Whether we're considered to be at the beginning of a line.	 * If so, '^' rules will be active on the next match, otherwise not.	 */	int yy_at_bol;	// Whether to try to fill the input buffer when we reach the end of it.	int yy_fill_buffer;	int yy_buffer_status;#define YY_BUFFER_NEW		0#define YY_BUFFER_NORMAL	1	/* When an EOF's been seen but there's still some text to process	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we	 * shouldn't try reading from the input source any more.  We might	 * still have a bunch of tokens to match, though, because of	 * possible backing-up.	 *	 * When we actually see the EOF, we change the status to "new"	 * (via yyrestart()), so that the user can continue scanning by	 * just pointing yyin at a new input file.	 */#define YY_BUFFER_EOF_PENDING 2};static YY_BUFFER_STATE yy_current_buffer = 0;/* We provide macros for accessing buffer states in case in the * future we want to put the buffer states in a more general * "scanner state". */#define YY_CURRENT_BUFFER yy_current_buffer// yy_hold_char holds the character lost when yytext is formed.static char yy_hold_char;static int yy_n_chars;		// number of characters read into yy_ch_bufint yyleng;// Points to current character in buffer.static char* yy_c_buf_p = (char*) 0;static int yy_init	= 1;	// whether we need to initializestatic int yy_start	= 0;	// start state number/* Flag which is used to allow yywrap()'s to do buffer switches * instead of setting up a fresh yyin.  A bit of a hack ... */static int yy_did_buffer_switch_on_eof;void yyrestart					(istream* input_file);void yy_switch_to_buffer		(YY_BUFFER_STATE new_buffer);void yy_load_buffer_state		(void);YY_BUFFER_STATE yy_create_buffer(istream* file, int size);void yy_delete_buffer			(YY_BUFFER_STATE b);void yy_init_buffer				(YY_BUFFER_STATE b, istream* file);void yy_flush_buffer			(YY_BUFFER_STATE b);#define YY_FLUSH_BUFFER yy_flush_buffer(yy_current_buffer)YY_BUFFER_STATE yy_scan_buffer	(char* base, yy_size_t size);YY_BUFFER_STATE yy_scan_string	(yyconst char* str);YY_BUFFER_STATE yy_scan_bytes	(yyconst char* bytes, int len);static void*	yy_flex_alloc	(yy_size_t);static void*	yy_flex_realloc	(void*, yy_size_t);static void		yy_flex_free	(void*);#define yy_new_buffer	yy_create_buffer#define yy_set_interactive(is_interactive)	{ \	if ( ! yy_current_buffer ) \		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \	yy_current_buffer->yy_is_interactive = is_interactive; \	}#define yy_set_bol(at_bol)	{ \	if ( ! yy_current_buffer ) \		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \	yy_current_buffer->yy_at_bol = at_bol; \	}#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)typedef unsigned char YY_CHAR;FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;typedef int yy_state_type;extern char *yytext;#define yytext_ptr yytextstatic yy_state_type	yy_get_previous_state	(void);static yy_state_type	yy_try_NUL_trans		(yy_state_type current_state);static int				yy_get_next_buffer		(void);static void				yy_fatal_error			(yyconst char msg[]);/* Done after the current pattern has been matched and before the * corresponding action - sets up yytext. */#define	YY_DO_BEFORE_ACTION	yytext_ptr = yy_bp; \	yyleng = (int) (yy_cp - yy_bp); \	yy_hold_char = *yy_cp; \	*yy_cp = '\0'; \	yy_c_buf_p = yy_cp;#define YY_NUM_RULES 165#define YY_END_OF_BUFFER 166// vvvvvvvvvvvvvvvvvvvvvvvvv Inserted in Place of static arrays vvvvvvvvvvvvvvvvvvvvvvvvv#include "Res.h"#define YY_USER_INIT	InitScanArrays()static const short int*	yy_accept;static const int*		yy_ec;static const int*		yy_meta;static const short int*	yy_base;static const short int*	yy_def;static const short int*	yy_nxt;static const short int*	yy_chk;voidInitScanArrays (void){	SLoad(yy_accept);	LLoad(yy_ec);	LLoad(yy_meta);	SLoad(yy_base);	SLoad(yy_def);	SLoad(yy_nxt);	SLoad(yy_chk);}// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^static yy_state_type yy_last_accepting_state;static char *yy_last_accepting_cpos;/* The intent behind this definition is that it'll catch * any uses of REJECT which flex missed. */#define REJECT reject_used_but_not_detected#define yymore() yymore_used_but_not_detected#define YY_MORE_ADJ 0char *yytext;#line 1 "scan.l"#define INITIAL 0/* scan.l - scanner for flex input */#line 4 "scan.l"/*- * Copyright (c) 1990 The Regents of the University of California. * All rights reserved. * * This code is derived from software contributed to Berkeley by * Vern Paxson. *  * The United States Government has rights in this work pursuant * to contract no. DE-AC03-76SF00098 between the United States * Department of Energy and the University of California. * * Redistribution and use in source and binary forms are permitted provided * that: (1) source distributions retain this entire copyright notice and * comment, and (2) distributions including binaries display the following * acknowledgement:  ``This product includes software developed by the * University of California, Berkeley and its contributors'' in the * documentation or other materials provided with the distribution and in * all advertising materials mentioning features or use of this software. * Neither the name of the University nor the names of its contributors may * be used to endorse or promote products derived from this software without * specific prior written permission. * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. *//* $Header: /home/daffy/u0/vern/flex/RCS/scan.l,v 2.56 95/04/24 12:17:19 vern Exp $ */#include "flexdef.h"#include "parse.h"#define ACTION_ECHO add_action( yytext )#define ACTION_IFDEF(def, should_define) \	{ \	if ( should_define ) \		action_define( def, 1 ); \	}#define MARK_END_OF_PROLOG mark_prolog();#define YY_DECL \	int flexscan()#define RETURNCHAR \	yylval = (unsigned char) yytext[0]; \	return CHAR;#define RETURNNAME \	strcpy( nmstr, yytext ); \	return NAME;#define PUT_BACK_STRING(str, start) \	for ( i = strlen( str ) - 1; i >= start; --i ) \		unput((str)[i])#define CHECK_REJECT(str) \	if ( all_upper( str ) ) \		reject = true;#define CHECK_YYMORE(str) \	if ( all_lower( str ) ) \		yymore_used = true;#define YY_STACK_USED 1#define YY_NO_TOP_STATE 1#define SECT2 1#define SECT2PROLOG 2#define SECT3 3#define CODEBLOCK 4#define PICKUPDEF 5#define SC 6#define CARETISBOL 7#define NUM 8#define QUOTE 9#define FIRSTCCL 10#define CCL 11#define ACTION 12#define RECOVER 13#define COMMENT 14#define ACTION_STRING 15#define PERCENT_BRACE_ACTION 16#define OPTION 17#define LINEDIR 18/*NL		\r?\n	changed to just \n by CEH */#line 1267 "scan.c"/* Macros after this point can all be overridden by user definitions in * section 1. */#ifndef YY_SKIP_YYWRAPextern YY_C int yywrap (void);#endif#ifndef YY_NO_UNPUTstatic void yyunput (int c, char* buf_ptr);#endif#ifndef yytext_ptrstatic void yy_flex_strncpy (char*, yyconst char*, int);#endif#ifndef YY_NO_INPUTstatic int yyinput (void);#endif#if YY_STACK_USEDstatic int yy_start_stack_ptr	= 0;static int yy_start_stack_depth	= 0;static int *yy_start_stack		= 0;#ifndef YY_NO_PUSH_STATEstatic void yy_push_state	(int new_state);#endif#ifndef YY_NO_POP_STATEstatic void yy_pop_state	(void);#endif#ifndef YY_NO_TOP_STATEstatic int yy_top_state		(void);#endif#else#define YY_NO_PUSH_STATE	1#define YY_NO_POP_STATE		1#define YY_NO_TOP_STATE		1#endif#ifdef YY_MALLOC_DECLYY_MALLOC_DECL#else#if __STDC__#ifndef __cplusplus#include <stdlib.h>#endif#else/* Just try to get by without declaring the routines.  This will fail * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int) * or sizeof(void*) != sizeof(int). */#endif#endif// Amount of stuff to slurp up with each read.#ifndef YY_READ_BUF_SIZE#define YY_READ_BUF_SIZE 8192#endif// Copy whatever the last rule matched to the standard output.#ifndef ECHO/* This used to be an fputs(), but since the string might contain NUL's, * we now use fwrite(). */#define ECHO	(void) fwrite(yytext, yyleng, 1, yyout)#endif/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL, * is returned in "result". */#ifndef YY_INPUT#define YY_INPUT(buf,result,max_size) \	if ( yy_current_buffer->yy_is_interactive ) \		{ \		int c = '*', n; \		for ( n = 0; n < max_size && \			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \			buf[n] = (char) c; \		if ( c == '\n' ) \			buf[n++] = (char) c; \		if ( c == EOF && ferror( yyin ) ) \			YY_FATAL_ERROR( "input in flex scanner failed" ); \		result = n; \		} \	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \		  && ferror( yyin ) ) \		YY_FATAL_ERROR( "input in flex scanner failed" );#endif/* No semi-colon after return; correct usage is to write "yyterminate();" - * we don't want an extra ';' after the "return" because that will cause * some compilers to complain about unreachable statements. */#ifndef yyterminate#define yyterminate() return YY_NULL#endif// Number of entries by which start-condition stack grows.#ifndef YY_START_STACK_INCR#define YY_START_STACK_INCR 25#endif// Report a fatal error.#ifndef YY_FATAL_ERROR#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)#endif/* Default declaration of generated scanner - a define so the user can * easily add parameters. */#ifndef YY_DECL#define YY_DECL	YY_DECLARE(int) yylex()#endif/* Code executed at the beginning of each rule, after yytext and yyleng * have been set up. */#ifndef YY_USER_ACTION#define YY_USER_ACTION#endif// Code executed at the end of each rule.#ifndef YY_BREAK#define YY_BREAK break;#endif#define YY_RULE_SETUP \	if ( yyleng > 0 ) \		yy_current_buffer->yy_at_bol = \				(yytext[yyleng - 1] == '\n'); \	YY_USER_ACTIONYY_DECL{	register yy_state_type yy_current_state;	register char *yy_cp, *yy_bp;	register int yy_act;#line 95 "scan.l"	static int bracelevel, didadef, indented_code;	static int doing_rule_action = false;	static int option_sense;	int doing_codeblock = false;	int i;	Char nmdef[MAXLINE] /* CEH , myesc() */;#line 1420 "scan.c"	if ( yy_init ) {		yy_init = 0;#ifdef YY_USER_INIT		YY_USER_INIT;#endif		if ( ! yy_start )			yy_start = 1;	/* first start state */		if ( ! yyin )			yyin = stdin;		if ( ! yyout )			yyout = stdout;		if ( ! yy_current_buffer )			yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );		yy_load_buffer_state();	}	while (1) {		// loops until end-of-file is reached		yy_cp = yy_c_buf_p;		// Support of yytext.		*yy_cp = yy_hold_char;		/* yy_bp points to the position in yy_ch_buf of the start of		 * the current run.		 */		yy_bp = yy_cp;		yy_current_state = yy_start;		yy_current_state += YY_AT_BOL();yy_match:		do			{			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];			if ( yy_accept[yy_current_state] )				{				yy_last_accepting_state = yy_current_state;				yy_last_accepting_cpos = yy_cp;				}			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )				{				yy_current_state = (int) yy_def[yy_current_state];				if ( yy_current_state >= 726 )					yy_c = yy_meta[(unsigned int) yy_c];				}			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];			++yy_cp;			}		while ( yy_base[yy_current_state] != 2598 );yy_find_action:		yy_act = yy_accept[yy_current_state];		if ( yy_act == 0 )			{ /* have to back up */			yy_cp = yy_last_accepting_cpos;			yy_current_state = yy_last_accepting_state;			yy_act = yy_accept[yy_current_state];			}		YY_DO_BEFORE_ACTION;do_action:	// This label is used only to access EOF actions.		switch (yy_act) { // beginning of action switch			case 0: /* must back up */			/* undo the effects of YY_DO_BEFORE_ACTION */			*yy_cp = yy_hold_char;			yy_cp = yy_last_accepting_cpos;			yy_current_state = yy_last_accepting_state;			goto yy_find_action;case 1:YY_RULE_SETUP#line 106 "scan.l"indented_code = true; BEGIN(CODEBLOCK);	YY_BREAKcase 2:YY_RULE_SETUP#line 107 "scan.l"ACTION_ECHO; yy_push_state( COMMENT );	YY_BREAKcase 3:YY_RULE_SETUP#line 108 "scan.l"yy_push_state( LINEDIR );	YY_BREAKcase 4:YY_RULE_SETUP#line 109 "scan.l"return SCDECL;	YY_BREAKcase 5:YY_RULE_SETUP#line 110 "scan.l"return XSCDECL;	YY_BREAKcase 6:YY_RULE_SETUP#line 111 "scan.l"{			++linenum;			line_directive_out( (FILE *) 0, 1 );			indented_code = false;			BEGIN(CODEBLOCK);			}	YY_BREAKcase 7:YY_RULE_SETUP#line 118 "scan.l"/* discard */	YY_BREAKcase 8:YY_RULE_SETUP#line 120 "scan.l"{			sectnum = 2;			bracelevel = 0;			mark_defs1();			line_directive_out( (FILE *) 0, 1 );			BEGIN(SECT2PROLOG);			return SECTEND;			}	YY_BREAKcase 9:YY_RULE_SETUP#line 129 "scan.l"yytext_is_array = false; ++linenum;	YY_BREAKcase 10:YY_RULE_SETUP#line 130 "scan.l"yytext_is_array = true; ++linenum;	YY_BREAKcase 11:YY_RULE_SETUP#line 132 "scan.l"BEGIN(OPTION); return OPTION_OP;	YY_BREAKcase 12:YY_RULE_SETUP#line 134 "scan.l"++linenum; /* ignore */	YY_BREAKcase 13:YY_RULE_SETUP#line 135 "scan.l"++linenum;	/* ignore */	YY_BREAKcase 14:YY_RULE_SETUP#line 137 "scan.l"synerr( _( "unrecognized '%' directive" ) );	YY_BREAKcase 15:YY_RULE_SETUP#line 139 "scan.l"{			strcpy( nmstr, yytext );			didadef = false;			BEGIN(PICKUPDEF);			}	YY_BREAKcase 16:YY_RULE_SETUP#line 145 "scan.l"RETURNNAME;	YY_BREAKcase 17:YY_RULE_SETUP#line 146 "scan.l"++linenum; /* allows blank lines in section 1 */	YY_BREAKcase 18:YY_RULE_SETUP#line 147 "scan.l"ACTION_ECHO; ++linenum; /* maybe end of comment line */	YY_BREAKcase 19:YY_RULE_SETUP#line 152 "scan.l"ACTION_ECHO; yy_pop_state();	YY_BREAKcase 20:YY_RULE_SETUP#line 153 "scan.l"ACTION_ECHO;	YY_BREAKcase 21:YY_RULE_SETUP#line 154 "scan.l"ACTION_ECHO;	YY_BREAKcase 22:YY_RULE_SETUP#line 155 "scan.l"++linenum; ACTION_ECHO;	YY_BREAKcase 23:YY_RULE_SETUP#line 159 "scan.l"yy_pop_state();	YY_BREAKcase 24:YY_RULE_SETUP#line 160 "scan.l"linenum = myctoi( yytext );	YY_BREAKcase 25:YY_RULE_SETUP#line 162 "scan.l"{			flex_free( (void *) infilename );			infilename = copy_string( yytext + 1 );			infilename[strlen( infilename ) - 1] = '\0';			}	YY_BREAKcase 26:YY_RULE_SETUP#line 167 "scan.l"/* ignore spurious characters */	YY_BREAKcase 27:YY_RULE_SETUP#line 171 "scan.l"++linenum; BEGIN(INITIAL);	YY_BREAKcase 28:YY_RULE_SETUP#line 173 "scan.l"ACTION_ECHO;	YY_BREAKcase 29:YY_RULE_SETUP#line 175 "scan.l"{			++linenum;			ACTION_ECHO;			if ( indented_code )				BEGIN(INITIAL);			}	YY_BREAKcase 30:YY_RULE_SETUP#line 185 "scan.l"/* separates name and definition */	YY_BREAKcase 31:YY_RULE_SETUP#line 187 "scan.l"{			strcpy( (char *) nmdef, yytext );			/* Skip trailing whitespace. */			for ( i = strlen( (char *) nmdef ) - 1;			      i >= 0 && (nmdef[i] == ' ' || nmdef[i] == '\t');			      --i )				;			nmdef[i + 1] = '\0';			ndinstal( nmstr, nmdef );			didadef = true;			}	YY_BREAKcase 32:YY_RULE_SETUP#line 202 "scan.l"{			if ( ! didadef )				synerr( _( "incomplete name definition" ) );			BEGIN(INITIAL);			++linenum;			}	YY_BREAKcase 33:YY_RULE_SETUP#line 212 "scan.l"++linenum; BEGIN(INITIAL);	YY_BREAKcase 34:YY_RULE_SETUP#line 213 "scan.l"option_sense = true;	YY_BREAKcase 35:YY_RULE_SETUP#line 215 "scan.l"return '=';	YY_BREAKcase 36:YY_RULE_SETUP#line 217 "scan.l"option_sense = ! option_sense;	YY_BREAKcase 37:YY_RULE_SETUP#line 219 "scan.l"csize = option_sense ? 128 : 256;	YY_BREAKcase 38:YY_RULE_SETUP#line 220 "scan.l"csize = option_sense ? 256 : 128;	YY_BREAKcase 39:YY_RULE_SETUP#line 222 "scan.l"long_align = option_sense;	YY_BREAKcase 40:YY_RULE_SETUP#line 223 "scan.l"{			action_define( "YY_ALWAYS_INTERACTIVE", option_sense );			}	YY_BREAKcase 41:YY_RULE_SETUP#line 226 "scan.l"yytext_is_array = option_sense;	YY_BREAKcase 42:YY_RULE_SETUP#line 227 "scan.l"backing_up_report = option_sense;	YY_BREAKcase 43:YY_RULE_SETUP#line 228 "scan.l"interactive = ! option_sense;	YY_BREAKcase 44:YY_RULE_SETUP#line 229 "scan.l"C_plus_plus = option_sense;	YY_BREAKcase 45:YY_RULE_SETUP#line 230 "scan.l"caseins = ! option_sense;	YY_BREAKcase 46:YY_RULE_SETUP#line 231 "scan.l"caseins = option_sense;	YY_BREAKcase 47:YY_RULE_SETUP#line 232 "scan.l"ddebug = option_sense;	YY_BREAKcase 48:YY_RULE_SETUP#line 233 "scan.l"spprdflt = ! option_sense;	YY_BREAKcase 49:YY_RULE_SETUP#line 234 "scan.l"useecs = option_sense;	YY_BREAKcase 50:YY_RULE_SETUP#line 235 "scan.l"{			useecs = usemecs = false;			use_read = fullspd = true;			}	YY_BREAKcase 51:YY_RULE_SETUP#line 239 "scan.l"{			useecs = usemecs = false;			use_read = fulltbl = true;			}	YY_BREAKcase 52:YY_RULE_SETUP#line 243 "scan.l"ACTION_IFDEF("YY_NO_INPUT", ! option_sense);	YY_BREAKcase 53:YY_RULE_SETUP#line 244 "scan.l"interactive = option_sense;	YY_BREAKcase 54:YY_RULE_SETUP#line 245 "scan.l"lex_compat = option_sense;	YY_BREAKcase 55:YY_RULE_SETUP#line 246 "scan.l"{			action_define( "YY_MAIN", option_sense );			do_yywrap = ! option_sense;			}	YY_BREAKcase 56:YY_RULE_SETUP#line 250 "scan.l"usemecs = option_sense;	YY_BREAKcase 57:YY_RULE_SETUP#line 251 "scan.l"{			action_define( "YY_NEVER_INTERACTIVE", option_sense );			}	YY_BREAKcase 58:YY_RULE_SETUP#line 254 "scan.l"performance_report += option_sense ? 1 : -1;	YY_BREAKcase 59:YY_RULE_SETUP#line 255 "scan.l"yytext_is_array = ! option_sense;	YY_BREAKcase 60:YY_RULE_SETUP#line 256 "scan.l"use_read = option_sense;	YY_BREAKcase 61:YY_RULE_SETUP#line 257 "scan.l"reject_really_used = option_sense;	YY_BREAKcase 62:YY_RULE_SETUP#line 258 "scan.l"action_define( "YY_STACK_USED", option_sense );	YY_BREAKcase 63:YY_RULE_SETUP#line 259 "scan.l"do_stdinit = option_sense;	YY_BREAKcase 64:YY_RULE_SETUP#line 260 "scan.l"use_stdout = option_sense;	YY_BREAKcase 65:YY_RULE_SETUP#line 261 "scan.l"ACTION_IFDEF("YY_NO_UNPUT", ! option_sense);	YY_BREAKcase 66:YY_RULE_SETUP#line 262 "scan.l"printstats = option_sense;	YY_BREAKcase 67:YY_RULE_SETUP#line 263 "scan.l"nowarn = ! option_sense;	YY_BREAKcase 68:YY_RULE_SETUP#line 264 "scan.l"do_yylineno = option_sense;	YY_BREAKcase 69:YY_RULE_SETUP#line 265 "scan.l"yymore_really_used = option_sense;	YY_BREAKcase 70:YY_RULE_SETUP#line 266 "scan.l"do_yywrap = option_sense;	YY_BREAKcase 71:YY_RULE_SETUP#line 268 "scan.l"ACTION_IFDEF("YY_NO_PUSH_STATE", ! option_sense);	YY_BREAKcase 72:YY_RULE_SETUP#line 269 "scan.l"ACTION_IFDEF("YY_NO_POP_STATE", ! option_sense);	YY_BREAKcase 73:YY_RULE_SETUP#line 270 "scan.l"ACTION_IFDEF("YY_NO_TOP_STATE", ! option_sense);	YY_BREAKcase 74:YY_RULE_SETUP#line 272 "scan.l"ACTION_IFDEF("YY_NO_SCAN_BUFFER", ! option_sense);	YY_BREAKcase 75:YY_RULE_SETUP#line 273 "scan.l"ACTION_IFDEF("YY_NO_SCAN_BYTES", ! option_sense);	YY_BREAKcase 76:YY_RULE_SETUP#line 274 "scan.l"ACTION_IFDEF("YY_NO_SCAN_STRING", ! option_sense);	YY_BREAKcase 77:YY_RULE_SETUP#line 276 "scan.l"return OPT_OUTFILE;	YY_BREAKcase 78:YY_RULE_SETUP#line 277 "scan.l"return OPT_PREFIX;	YY_BREAKcase 79:YY_RULE_SETUP#line 278 "scan.l"return OPT_YYCLASS;	YY_BREAKcase 80:YY_RULE_SETUP#line 280 "scan.l"{			strcpy( nmstr, yytext + 1 );			nmstr[strlen( nmstr ) - 1] = '\0';			return NAME;			}	YY_BREAKcase 81:YY_RULE_SETUP#line 286 "scan.l"{			format_synerr( _( "unrecognized %%option: %s" ),				yytext );			BEGIN(RECOVER);			}	YY_BREAKcase 82:YY_RULE_SETUP#line 293 "scan.l"++linenum; BEGIN(INITIAL);	YY_BREAKcase 83:YY_RULE_SETUP#line 297 "scan.l"++bracelevel; yyless( 2 );	/* eat only %{ */	YY_BREAKcase 84:YY_RULE_SETUP#line 298 "scan.l"--bracelevel; yyless( 2 );	/* eat only %} */	YY_BREAKcase 85:YY_RULE_SETUP#line 300 "scan.l"ACTION_ECHO;	/* indented code in prolog */	YY_BREAKcase 86:YY_RULE_SETUP#line 302 "scan.l"{	/* non-indented code */			if ( bracelevel <= 0 )				{ /* not in %{ ... %} */				yyless( 0 );	/* put it all back */				yy_set_bol( 1 );				mark_prolog();				BEGIN(SECT2);				}			else				ACTION_ECHO;			}	YY_BREAKcase 87:YY_RULE_SETUP#line 314 "scan.l"ACTION_ECHO;	YY_BREAKcase 88:YY_RULE_SETUP#line 315 "scan.l"++linenum; ACTION_ECHO;	YY_BREAKcase YY_STATE_EOF(SECT2PROLOG):#line 317 "scan.l"{			mark_prolog();			sectnum = 0;			yyterminate(); /* to stop the parser */			}	YY_BREAKcase 89:YY_RULE_SETUP#line 325 "scan.l"++linenum; /* allow blank lines in section 2 */	YY_BREAKcase 90:YY_RULE_SETUP#line 327 "scan.l"{			indented_code = false;			doing_codeblock = true;			bracelevel = 1;			BEGIN(PERCENT_BRACE_ACTION);			}	YY_BREAKcase 91:YY_RULE_SETUP#line 334 "scan.l"BEGIN(SC); return '<';	YY_BREAKcase 92:YY_RULE_SETUP#line 335 "scan.l"return '^';	YY_BREAKcase 93:YY_RULE_SETUP#line 336 "scan.l"BEGIN(QUOTE); return '"';	YY_BREAKcase 94:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */yy_c_buf_p = yy_cp = yy_bp + 1;YY_DO_BEFORE_ACTION; /* set up yytext again */YY_RULE_SETUP#line 337 "scan.l"BEGIN(NUM); return '{';	YY_BREAKcase 95:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */yy_c_buf_p = yy_cp = yy_bp + 1;YY_DO_BEFORE_ACTION; /* set up yytext again */YY_RULE_SETUP#line 338 "scan.l"return '$';	YY_BREAKcase 96:YY_RULE_SETUP#line 340 "scan.l"{			bracelevel = 1;			BEGIN(PERCENT_BRACE_ACTION);			if ( in_rule )				{				doing_rule_action = true;				in_rule = false;				return '\n';				}			}	YY_BREAKcase 97:YY_RULE_SETUP#line 351 "scan.l"continued_action = true; ++linenum; return '\n';	YY_BREAKcase 98:YY_RULE_SETUP#line 353 "scan.l"{			yyless( yyleng - 2 );	/* put back '/', '*' */			bracelevel = 0;			continued_action = false;			BEGIN(ACTION);			}	YY_BREAKcase 99:YY_RULE_SETUP#line 360 "scan.l"/* allow indented rules */	YY_BREAKcase 100:YY_RULE_SETUP#line 362 "scan.l"{			/* This rule is separate from the one below because			 * otherwise we get variable trailing context, so			 * we can't build the scanner using -{f,F}.			 */			bracelevel = 0;			continued_action = false;			BEGIN(ACTION);			if ( in_rule )				{				doing_rule_action = true;				in_rule = false;				return '\n';				}			}	YY_BREAKcase 101:YY_RULE_SETUP#line 379 "scan.l"{			bracelevel = 0;			continued_action = false;			BEGIN(ACTION);			unput( '\n' );	/* so <ACTION> sees it */			if ( in_rule )				{				doing_rule_action = true;				in_rule = false;				return '\n';				}			}	YY_BREAKcase 102:#line 394 "scan.l"case 103:YY_RULE_SETUP#line 394 "scan.l"return EOF_OP;	YY_BREAKcase 104:YY_RULE_SETUP#line 396 "scan.l"{			sectnum = 3;			BEGIN(SECT3);			yyterminate(); /* to stop the parser */			}	YY_BREAKcase 105:YY_RULE_SETUP#line 402 "scan.l"{			int cclval;			strcpy( nmstr, yytext );			/* Check to see if we've already encountered this			 * ccl.			 */			if ( (cclval = ccllookup( (Char *) nmstr )) != 0 )				{				if ( yyinput() != ']' ) /* CEH */					synerr( _( "bad character class" ) );				yylval = cclval;				++cclreuse;				return PREVCCL;				}			else				{				/* We fudge a bit.  We know that this ccl will				 * soon be numbered as lastccl + 1 by cclinit.				 */				cclinstal( (Char *) nmstr, lastccl + 1 );				/* Push back everything but the leading bracket				 * so the ccl can be rescanned.				 */				yyless( 1 );				BEGIN(FIRSTCCL);				return '[';				}			}	YY_BREAKcase 106:YY_RULE_SETUP#line 436 "scan.l"{			register Char *nmdefptr;	/* CEH		Char *ndlookup(); */			strcpy( nmstr, yytext + 1 );			nmstr[yyleng - 2] = '\0';  /* chop trailing brace */			if ( (nmdefptr = ndlookup( nmstr )) == 0 )				format_synerr(					_( "undefined definition {%s}" ),						nmstr );			else				{ /* push back name surrounded by ()'s */				int len = strlen( (char *) nmdefptr );				if ( lex_compat || nmdefptr[0] == '^' ||				     (len > 0 && nmdefptr[len - 1] == '$') )					{ /* don't use ()'s after all */					PUT_BACK_STRING((char *) nmdefptr, 0);					if ( nmdefptr[0] == '^' )						BEGIN(CARETISBOL);					}				else					{					unput(')');					PUT_BACK_STRING((char *) nmdefptr, 0);					unput('(');					}				}			}	YY_BREAKcase 107:YY_RULE_SETUP#line 470 "scan.l"return (unsigned char) yytext[0];	YY_BREAKcase 108:YY_RULE_SETUP#line 471 "scan.l"RETURNCHAR;	YY_BREAKcase 109:YY_RULE_SETUP#line 476 "scan.l"return (unsigned char) yytext[0];	YY_BREAKcase 110:YY_RULE_SETUP#line 477 "scan.l"BEGIN(SECT2); return '>';	YY_BREAKcase 111:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */yy_c_buf_p = yy_cp = yy_bp + 1;YY_DO_BEFORE_ACTION; /* set up yytext again */YY_RULE_SETUP#line 478 "scan.l"BEGIN(CARETISBOL); return '>';	YY_BREAKcase 112:YY_RULE_SETUP#line 479 "scan.l"RETURNNAME;	YY_BREAKcase 113:YY_RULE_SETUP#line 480 "scan.l"{			format_synerr( _( "bad <start condition>: %s" ),				yytext );			}	YY_BREAKcase 114:YY_RULE_SETUP#line 486 "scan.l"BEGIN(SECT2); return '^';	YY_BREAKcase 115:YY_RULE_SETUP#line 490 "scan.l"RETURNCHAR;	YY_BREAKcase 116:YY_RULE_SETUP#line 491 "scan.l"BEGIN(SECT2); return '"';	YY_BREAKcase 117:YY_RULE_SETUP#line 493 "scan.l"{			synerr( _( "missing quote" ) );			BEGIN(SECT2);			++linenum;			return '"';			}	YY_BREAKcase 118:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */yy_c_buf_p = yy_cp = yy_bp + 1;YY_DO_BEFORE_ACTION; /* set up yytext again */YY_RULE_SETUP#line 503 "scan.l"BEGIN(CCL); return '^';	YY_BREAKcase 119:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */yy_c_buf_p = yy_cp = yy_bp + 1;YY_DO_BEFORE_ACTION; /* set up yytext again */YY_RULE_SETUP#line 504 "scan.l"return '^';	YY_BREAKcase 120:YY_RULE_SETUP#line 505 "scan.l"BEGIN(CCL); RETURNCHAR;	YY_BREAKcase 121:*yy_cp = yy_hold_char; /* undo effects of setting up yytext */yy_c_buf_p = yy_cp = yy_bp + 1;YY_DO_BEFORE_ACTION; /* set up yytext again */YY_RULE_SETUP#line 509 "scan.l"return '-';	YY_BREAKcase 122:YY_RULE_SETUP#line 510 "scan.l"RETURNCHAR;	YY_BREAKcase 123:YY_RULE_SETUP#line 511 "scan.l"BEGIN(SECT2); return ']';	YY_BREAKcase 124:YY_RULE_SETUP#line 512 "scan.l"{			synerr( _( "bad character class" ) );			BEGIN(SECT2);			return ']';			}	YY_BREAKcase 125:YY_RULE_SETUP#line 520 "scan.l"BEGIN(CCL); return CCE_ALNUM;	YY_BREAKcase 126:YY_RULE_SETUP#line 521 "scan.l"BEGIN(CCL); return CCE_ALPHA;	YY_BREAKcase 127:YY_RULE_SETUP#line 522 "scan.l"BEGIN(CCL); return CCE_BLANK;	YY_BREAKcase 128:YY_RULE_SETUP#line 523 "scan.l"BEGIN(CCL); return CCE_CNTRL;	YY_BREAKcase 129:YY_RULE_SETUP#line 524 "scan.l"BEGIN(CCL); return CCE_DIGIT;	YY_BREAKcase 130:YY_RULE_SETUP#line 525 "scan.l"BEGIN(CCL); return CCE_GRAPH;	YY_BREAKcase 131:YY_RULE_SETUP#line 526 "scan.l"BEGIN(CCL); return CCE_LOWER;	YY_BREAKcase 132:YY_RULE_SETUP#line 527 "scan.l"BEGIN(CCL); return CCE_PRINT;	YY_BREAKcase 133:YY_RULE_SETUP#line 528 "scan.l"BEGIN(CCL); return CCE_PUNCT;	YY_BREAKcase 134:YY_RULE_SETUP#line 529 "scan.l"BEGIN(CCL); return CCE_SPACE;	YY_BREAKcase 135:YY_RULE_SETUP#line 530 "scan.l"BEGIN(CCL); return CCE_UPPER;	YY_BREAKcase 136:YY_RULE_SETUP#line 531 "scan.l"BEGIN(CCL); return CCE_XDIGIT;	YY_BREAKcase 137:YY_RULE_SETUP#line 532 "scan.l"{			format_synerr(				_( "bad character class expression: %s" ),					yytext );			BEGIN(CCL); return CCE_ALNUM;			}	YY_BREAKcase 138:YY_RULE_SETUP#line 541 "scan.l"{			yylval = myctoi( yytext );			return NUMBER;			}	YY_BREAKcase 139:YY_RULE_SETUP#line 546 "scan.l"return ',';	YY_BREAKcase 140:YY_RULE_SETUP#line 547 "scan.l"BEGIN(SECT2); return '}';	YY_BREAKcase 141:YY_RULE_SETUP#line 549 "scan.l"{			synerr( _( "bad character inside {}'s" ) );			BEGIN(SECT2);			return '}';			}	YY_BREAKcase 142:YY_RULE_SETUP#line 555 "scan.l"{			synerr( _( "missing }" ) );			BEGIN(SECT2);			++linenum;			return '}';			}	YY_BREAKcase 143:YY_RULE_SETUP#line 565 "scan.l"bracelevel = 0;	YY_BREAKcase 144:YY_RULE_SETUP#line 567 "scan.l"ACTION_ECHO; yy_push_state( COMMENT );	YY_BREAKcase 145:YY_RULE_SETUP#line 570 "scan.l"{			ACTION_ECHO;			CHECK_REJECT(yytext);			}	YY_BREAKcase 146:YY_RULE_SETUP#line 574 "scan.l"{			ACTION_ECHO;			CHECK_YYMORE(yytext);			}	YY_BREAKcase 147:YY_RULE_SETUP#line 580 "scan.l"ACTION_ECHO;	YY_BREAKcase 148:YY_RULE_SETUP#line 581 "scan.l"{			++linenum;			ACTION_ECHO;			if ( bracelevel == 0 ||			     (doing_codeblock && indented_code) )				{				if ( doing_rule_action )					add_action( "\tYY_BREAK\n" );				doing_rule_action = doing_codeblock = false;				BEGIN(SECT2);				}			}	YY_BREAK/* Reject and YYmore() are checked for above, in PERCENT_BRACE_ACTION */case 149:YY_RULE_SETUP#line 599 "scan.l"ACTION_ECHO; ++bracelevel;	YY_BREAKcase 150:YY_RULE_SETUP#line 600 "scan.l"ACTION_ECHO; --bracelevel;	YY_BREAKcase 151:YY_RULE_SETUP#line 601 "scan.l"ACTION_ECHO;	YY_BREAKcase 152:YY_RULE_SETUP#line 602 "scan.l"ACTION_ECHO;	YY_BREAKcase 153:YY_RULE_SETUP#line 603 "scan.l"ACTION_ECHO; /* character constant */	YY_BREAKcase 154:YY_RULE_SETUP#line 604 "scan.l"ACTION_ECHO; BEGIN(ACTION_STRING);	YY_BREAKcase 155:YY_RULE_SETUP#line 605 "scan.l"{			++linenum;			ACTION_ECHO;			if ( bracelevel == 0 )				{				if ( doing_rule_action )					add_action( "\tYY_BREAK\n" );				doing_rule_action = false;				BEGIN(SECT2);				}			}	YY_BREAKcase 156:YY_RULE_SETUP#line 617 "scan.l"ACTION_ECHO;	YY_BREAKcase 157:YY_RULE_SETUP#line 621 "scan.l"ACTION_ECHO;	YY_BREAKcase 158:YY_RULE_SETUP#line 622 "scan.l"ACTION_ECHO;	YY_BREAKcase 159:YY_RULE_SETUP#line 623 "scan.l"++linenum; ACTION_ECHO;	YY_BREAKcase 160:YY_RULE_SETUP#line 624 "scan.l"ACTION_ECHO; BEGIN(ACTION);	YY_BREAKcase 161:YY_RULE_SETUP#line 625 "scan.l"ACTION_ECHO;	YY_BREAKcase YY_STATE_EOF(COMMENT):case YY_STATE_EOF(ACTION):case YY_STATE_EOF(ACTION_STRING):#line 628 "scan.l"{			synerr( _( "EOF encountered inside an action" ) );			yyterminate();			}	YY_BREAKcase 162:YY_RULE_SETUP#line 634 "scan.l"{			yylval = myesc( (Char *) yytext );			if ( YY_START == FIRSTCCL )				BEGIN(CCL);			return CHAR;			}	YY_BREAKcase 163:YY_RULE_SETUP#line 645 "scan.l"ECHO;	YY_BREAKcase YY_STATE_EOF(SECT3):#line 646 "scan.l"sectnum = 0; yyterminate();	YY_BREAKcase 164:YY_RULE_SETUP#line 649 "scan.l"format_synerr( _( "bad character: %s" ), yytext );	YY_BREAKcase 165:YY_RULE_SETUP#line 651 "scan.l"YY_FATAL_ERROR( "flex scanner jammed" );	YY_BREAK#line 2654 "scan.c"case YY_STATE_EOF(INITIAL):case YY_STATE_EOF(SECT2):case YY_STATE_EOF(CODEBLOCK):case YY_STATE_EOF(PICKUPDEF):case YY_STATE_EOF(SC):case YY_STATE_EOF(CARETISBOL):case YY_STATE_EOF(NUM):case YY_STATE_EOF(QUOTE):case YY_STATE_EOF(FIRSTCCL):case YY_STATE_EOF(CCL):case YY_STATE_EOF(RECOVER):case YY_STATE_EOF(PERCENT_BRACE_ACTION):case YY_STATE_EOF(OPTION):case YY_STATE_EOF(LINEDIR):	yyterminate();	case YY_END_OF_BUFFER: {		// Amount of text matched not including the EOB char.		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;		// Undo the effects of YY_DO_BEFORE_ACTION.		*yy_cp = yy_hold_char;		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW ) {			/* We're scanning a new file or input source.  It's			 * possible that this happened because the user			 * just pointed yyin at a new source and called			 * yylex().  If so, then we have to assure			 * consistency between yy_current_buffer and our			 * globals.  Here is the right place to do so, because			 * this is the first action (other than possibly a			 * back-up) that will match for the new input source.			 */			yy_n_chars = yy_current_buffer->yy_n_chars;			yy_current_buffer->yy_input_file = yyin;			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;		}		/* Note that here we test for yy_c_buf_p "<=" to the position		 * of the first EOB in the buffer, since yy_c_buf_p will		 * already have been incremented past the NUL character		 * (since all states make transitions on EOB to the		 * end-of-buffer state).  Contrast this with the test		 * in yyinput().		 */		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] ) {			// This was really a NUL.			yy_state_type yy_next_state;			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;			yy_current_state = yy_get_previous_state();			/* Okay, we're now positioned to make the NUL			 * transition.  We couldn't have			 * yy_get_previous_state() go ahead and do it			 * for us because it doesn't know how to deal			 * with the possibility of jamming (and we don't			 * want to build jamming into it because then it			 * will run more slowly).			 */			yy_next_state = yy_try_NUL_trans( yy_current_state );			yy_bp = yytext_ptr + YY_MORE_ADJ;			if ( yy_next_state ) {				/* Consume the NUL. */				yy_cp = ++yy_c_buf_p;				yy_current_state = yy_next_state;				goto yy_match;			} else {				yy_cp = yy_c_buf_p;				goto yy_find_action;			}		} else			switch ( yy_get_next_buffer() ) {			case EOB_ACT_END_OF_FILE: {				yy_did_buffer_switch_on_eof = 0;				if ( yywrap() ) {					/* Note: because we've taken care in					 * yy_get_next_buffer() to have set up					 * yytext, we can now set up					 * yy_c_buf_p so that if some total					 * hoser (like flex itself) wants to					 * call the scanner after we return the					 * YY_NULL, it'll still work - another					 * YY_NULL will get returned.					 */					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;					yy_act = YY_STATE_EOF(YY_START);					goto do_action;				} else {					if ( ! yy_did_buffer_switch_on_eof )						YY_NEW_FILE;				}				break;			}			case EOB_ACT_CONTINUE_SCAN:				yy_c_buf_p =					yytext_ptr + yy_amount_of_matched_text;				yy_current_state = yy_get_previous_state();				yy_cp = yy_c_buf_p;				yy_bp = yytext_ptr + YY_MORE_ADJ;				goto yy_match;			case EOB_ACT_LAST_MATCH:				yy_c_buf_p =				&yy_current_buffer->yy_ch_buf[yy_n_chars];				yy_current_state = yy_get_previous_state();				yy_cp = yy_c_buf_p;				yy_bp = yytext_ptr + YY_MORE_ADJ;				goto yy_find_action;			}		break;	}		default:			YY_FATAL_ERROR(	"fatal flex scanner internal error--no action found" );		} // end of action switch	} // end of scanning one token} // end of yylex/* yy_get_next_buffer - try to read in a new buffer * * Returns a code representing an action: *	EOB_ACT_LAST_MATCH - *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position *	EOB_ACT_END_OF_FILE - end of file */YY_DECLARE(int) yy_get_next_buffer (void){	register char* dest = yy_current_buffer->yy_ch_buf;	register char* source = yytext_ptr;	register int number_to_move, i;	int ret_val;	if (yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1])		YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");	if (yy_current_buffer->yy_fill_buffer == 0) {		// Don't try to fill the buffer, so this is an EOF.		if (yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1) {			/* We matched a singled characater, the EOB, so			 * treat this as a final EOF.			 */			return EOB_ACT_END_OF_FILE;		}		else {			// We matched some text prior to the EOB, first process it.			return EOB_ACT_LAST_MATCH;		}	}	// Try to read more data.	// First move last chars to start of buffer.	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;	for (i = 0; i < number_to_move; ++i)		*(dest++) = *(source++);	if (yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING)		/* don't do the read, it's not guaranteed to return an EOF,		 * just force an EOF		 */		yy_n_chars = 0;	else {		int num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;		while (num_to_read <= 0) {			// Not enough room in the buffer - grow it.#ifdef YY_USES_REJECT			YY_FATAL_ERROR(			"input buffer overflow, can't enlarge buffer because scanner uses REJECT");#else			// just a shorter name for the current buffer			YY_BUFFER_STATE b = yy_current_buffer;			int yy_c_buf_p_offset = (int) (yy_c_buf_p - b->yy_ch_buf);			if (b->yy_is_our_buffer) {				int new_size = b->yy_buf_size * 2;				if (new_size <= 0)					b->yy_buf_size += b->yy_buf_size / 8;				else					b->yy_buf_size *= 2;				b->yy_ch_buf = (char*)					// Include room in for 2 EOB chars.					yy_flex_realloc((void*) b->yy_ch_buf, b->yy_buf_size + 2);			} else				// Can't grow it, we don't own it.				b->yy_ch_buf = 0;			if (!b->yy_ch_buf)				YY_FATAL_ERROR("fatal error - scanner input buffer overflow");			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];			num_to_read = yy_current_buffer->yy_buf_size - number_to_move - 1;#endif		}		if (num_to_read > YY_READ_BUF_SIZE)			num_to_read = YY_READ_BUF_SIZE;		// Read in more data.		YY_INPUT((&yy_current_buffer->yy_ch_buf[number_to_move]),					yy_n_chars, num_to_read);	}	if (yy_n_chars == 0) {		if (number_to_move == YY_MORE_ADJ) {			ret_val = EOB_ACT_END_OF_FILE;			yyrestart(yyin);		} else {			ret_val = EOB_ACT_LAST_MATCH;			yy_current_buffer->yy_buffer_status = YY_BUFFER_EOF_PENDING;		}	} else		ret_val = EOB_ACT_CONTINUE_SCAN;	yy_n_chars += number_to_move;	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];	return ret_val;}// yy_get_previous_state - get the state just before the EOB char was reachedYY_DECLARE(yy_state_type) yy_get_previous_state (void){	register yy_state_type yy_current_state;	register char* yy_cp;	yy_current_state = yy_start;	yy_current_state += YY_AT_BOL();	for (yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp) {		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);		if ( yy_accept[yy_current_state] )			{			yy_last_accepting_state = yy_current_state;			yy_last_accepting_cpos = yy_cp;			}		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )			{			yy_current_state = (int) yy_def[yy_current_state];			if ( yy_current_state >= 726 )				yy_c = yy_meta[(unsigned int) yy_c];			}		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];	}	return yy_current_state;}/* yy_try_NUL_trans - try to make a transition on the NUL character * * synopsis *	next_state = yy_try_NUL_trans(current_state); */YY_DECLARE(yy_state_type) yy_try_NUL_trans(yy_state_type yy_current_state){	register int yy_is_jam;	register char *yy_cp = yy_c_buf_p;	register YY_CHAR yy_c = 1;	if ( yy_accept[yy_current_state] )		{		yy_last_accepting_state = yy_current_state;		yy_last_accepting_cpos = yy_cp;		}	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )		{		yy_current_state = (int) yy_def[yy_current_state];		if ( yy_current_state >= 726 )			yy_c = yy_meta[(unsigned int) yy_c];		}	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];	yy_is_jam = (yy_current_state == 725);	return yy_is_jam ? 0 : yy_current_state;}#ifndef YY_NO_UNPUTYY_DECLARE(void) yyunput (int c, register char* yy_bp){	register char* yy_cp = yy_c_buf_p;	// undo effects of setting up yytext	*yy_cp = yy_hold_char;	if (yy_cp < yy_current_buffer->yy_ch_buf + 2) {		// need to shift things up to make room		// +2 for EOB chars.		register int number_to_move = yy_n_chars + 2;		register char *dest = &yy_current_buffer->yy_ch_buf[									yy_current_buffer->yy_buf_size + 2];		register char* source = &yy_current_buffer->yy_ch_buf[number_to_move];		while (source > yy_current_buffer->yy_ch_buf)			*--dest = *--source;		yy_cp += (int) (dest - source);		yy_bp += (int) (dest - source);		yy_n_chars = yy_current_buffer->yy_buf_size;		if (yy_cp < yy_current_buffer->yy_ch_buf + 2)			YY_FATAL_ERROR("flex scanner push-back overflow");	}	*--yy_cp = (char) c;	yytext_ptr = yy_bp;	yy_hold_char = *yy_cp;	yy_c_buf_p = yy_cp;}#endif	// ifndef YY_NO_UNPUTYY_DECLARE(int) yyinput (void){	int c;	*yy_c_buf_p = yy_hold_char;	if (*yy_c_buf_p == YY_END_OF_BUFFER_CHAR) {		/* yy_c_buf_p now points to the character we want to return.		 * If this occurs *before* the EOB characters, then it's a		 * valid NUL; if not, then we've hit the end of the buffer.		 */		if (yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars])			*yy_c_buf_p = '\0';			// This was really a NUL.		else { // need more input			yytext_ptr = yy_c_buf_p;			++yy_c_buf_p;			switch (yy_get_next_buffer()) {				case EOB_ACT_END_OF_FILE: {					if (yywrap()) {						yy_c_buf_p =						yytext_ptr + YY_MORE_ADJ;						return EOF;					}					if (!yy_did_buffer_switch_on_eof)						YY_NEW_FILE;					return yyinput();				}				case EOB_ACT_CONTINUE_SCAN:					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;					break;				case EOB_ACT_LAST_MATCH:					YY_FATAL_ERROR("unexpected last match in yyinput()");			}		}	}	c = *(unsigned char*) yy_c_buf_p;	// cast for 8-bit char's	*yy_c_buf_p = '\0';					// preserve yytext	yy_hold_char = *++yy_c_buf_p;	yy_current_buffer->yy_at_bol = (c == '\n');	return c;}YY_DECLARE(void) yyrestart (istream* input_file){	if ( ! yy_current_buffer )		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );	yy_init_buffer( yy_current_buffer, input_file );	yy_load_buffer_state();}YY_DECLARE(void) yy_switch_to_buffer (YY_BUFFER_STATE new_buffer){	if (yy_current_buffer == new_buffer)		return;	if (yy_current_buffer) {	// Flush out information for old buffer.		*yy_c_buf_p = yy_hold_char;		yy_current_buffer->yy_buf_pos = yy_c_buf_p;		yy_current_buffer->yy_n_chars = yy_n_chars;	}	yy_current_buffer = new_buffer;	yy_load_buffer_state();	/* We don't actually know whether we did this switch during	 * EOF (yywrap()) processing, but the only time this flag	 * is looked at is after yywrap() is called, so it's safe	 * to go ahead and always set it.	 */	yy_did_buffer_switch_on_eof = 1;}YY_DECLARE(void) yy_load_buffer_state (void){	yy_n_chars = yy_current_buffer->yy_n_chars;	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;	yyin = yy_current_buffer->yy_input_file;	yy_hold_char = *yy_c_buf_p;}YY_DECLARE(YY_BUFFER_STATE) yy_create_buffer (istream* file, int size){	YY_BUFFER_STATE b;	b = (YY_BUFFER_STATE) yy_flex_alloc(sizeof(struct yy_buffer_state));	if (!b)		YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");	b->yy_buf_size = size;	/* yy_ch_buf has to be 2 characters longer than the size given because	 * we need to put in 2 end-of-buffer characters.	 */	b->yy_ch_buf = (char*) yy_flex_alloc(b->yy_buf_size + 2);	if (!b->yy_ch_buf)		YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");	b->yy_is_our_buffer = 1;	yy_init_buffer(b, file);	return b;}YY_DECLARE(void) yy_delete_buffer (YY_BUFFER_STATE b){	if (!b)		return;	if (b == yy_current_buffer)		yy_current_buffer = (YY_BUFFER_STATE) 0;	if (b->yy_is_our_buffer)		yy_flex_free((void*) b->yy_ch_buf);	yy_flex_free((void*) b);}#if !defined(YY_ALWAYS_INTERACTIVE) && !defined(YY_NEVER_INTERACTIVE)extern YY_C int isatty (int);#endifYY_DECLARE(void) yy_init_buffer (YY_BUFFER_STATE b, istream* file){	yy_flush_buffer(b);	b->yy_input_file  = file;	b->yy_fill_buffer = 1;#if YY_ALWAYS_INTERACTIVE	b->yy_is_interactive = 1;#elif YY_NEVER_INTERACTIVE	b->yy_is_interactive = 0;#else	b->yy_is_interactive = file ? (isatty(fileno(file)) > 0) : 0;#endif}YY_DECLARE(void) yy_flush_buffer (YY_BUFFER_STATE b){	b->yy_n_chars = 0;	/* We always need two end-of-buffer characters.  The first causes	 * a transition to the end-of-buffer state.  The second causes	 * a jam in that state.	 */	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;	b->yy_buf_pos = &b->yy_ch_buf[0];	b->yy_at_bol = 1;	b->yy_buffer_status = YY_BUFFER_NEW;	if (b == yy_current_buffer)		yy_load_buffer_state();}#ifndef YY_NO_SCAN_BUFFERYY_BUFFER_STATE yy_scan_buffer (char* base, yy_size_t size){	YY_BUFFER_STATE b;	if (size < 2 || base[size-2] != YY_END_OF_BUFFER_CHAR ||					base[size-1] != YY_END_OF_BUFFER_CHAR)		return 0;		// They forgot to leave room for the EOB's.	b = (YY_BUFFER_STATE) yy_flex_alloc(sizeof(struct yy_buffer_state));	if (!b)		YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");	b->yy_buf_size       = size - 2;	// "- 2" to take care of EOB's	b->yy_buf_pos        = b->yy_ch_buf = base;	b->yy_is_our_buffer  = 0;	b->yy_input_file     = 0;	b->yy_n_chars        = b->yy_buf_size;	b->yy_is_interactive = 0;	b->yy_at_bol         = 1;	b->yy_fill_buffer    = 0;	b->yy_buffer_status  = YY_BUFFER_NEW;	yy_switch_to_buffer(b);	return b;}#endif#ifndef YY_NO_SCAN_STRINGYY_BUFFER_STATE yy_scan_string (yyconst char* str){	int len;	for (len = 0; str[len]; ++len)		;	return yy_scan_bytes(str, len);}#endif#ifndef YY_NO_SCAN_BYTESYY_BUFFER_STATE yy_scan_bytes (yyconst char* bytes, int len){	YY_BUFFER_STATE b;	char* buf;	yy_size_t n;	int i;	// Get memory for full buffer, including space for trailing EOB's.	n = len + 2;	buf = (char*) yy_flex_alloc(n);	if (!buf)		YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");	for (i = 0; i < len; ++i)		buf[i] = bytes[i];	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;	b = yy_scan_buffer(buf, n);	if (!b)		YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");	/* It's okay to grow etc. this buffer, and we should throw it	 * away when we're done.	 */	b->yy_is_our_buffer = 1;	return b;}#endif#ifndef YY_NO_PUSH_STATEYY_DECLARE(void) yy_push_state (int new_state){	if (yy_start_stack_ptr >= yy_start_stack_depth) {		yy_size_t new_size;		yy_start_stack_depth += YY_START_STACK_INCR;		new_size = yy_start_stack_depth * sizeof(int);		if (!yy_start_stack)			yy_start_stack = (int*) yy_flex_alloc(new_size);		else			yy_start_stack = (int*) yy_flex_realloc((void*) yy_start_stack, new_size);		if (!yy_start_stack)			YY_FATAL_ERROR("out of memory expanding start-condition stack");	}	yy_start_stack[yy_start_stack_ptr++] = YY_START;	BEGIN(new_state);}#endif#ifndef YY_NO_POP_STATEYY_DECLARE(void) yy_pop_state (void){	if (--yy_start_stack_ptr < 0)		YY_FATAL_ERROR("start-condition stack underflow");	BEGIN(yy_start_stack[yy_start_stack_ptr]);}#endif#ifndef YY_NO_TOP_STATEYY_DECLARE(int) yy_top_state (void){	return yy_start_stack[yy_start_stack_ptr - 1];}#endif#ifndef YY_EXIT_FAILURE#define YY_EXIT_FAILURE 2#endifYY_DECLARE(void) YY_FATAL_ERROR (yyconst char msg[]){	(void) fprintf(stderr, "%s\n", msg);	exit(YY_EXIT_FAILURE);}// Redefine yyless() so it works in section 3 code.#undef yyless#define yyless(n)	do { \		/* Undo effects of setting up yytext. */ \		yytext[yyleng] = yy_hold_char; \		yy_c_buf_p = yytext + n - YY_MORE_ADJ; \		yy_hold_char = *yy_c_buf_p; \		*yy_c_buf_p = '\0'; \		yyleng = n; \	} while (0)// Internal utility routines.#ifndef yytext_ptrstatic voidyy_flex_strncpy (char* s1, yyconst char* s2, int n){	register int i;	for (i = 0; i < n; ++i)		s1[i] = s2[i];}#endifstatic void*yy_flex_alloc (yy_size_t size){	return (void*) malloc(size);}static void*yy_flex_realloc (void* ptr, yy_size_t size){	return (void*) realloc(ptr, size);}static voidyy_flex_free (void* ptr){	free(ptr);}#if YY_MAINintmain (void){	yylex();	return 0;}#endif#line 651 "scan.l"int yywrap()	{	if ( --num_input_files > 0 )		{		set_input_file( *++input_files );		return 0;		}	else		return 1;	}/* set_input_file - open the given file (if NULL, stdin) for scanning */void set_input_file( char *file )	{	if ( file && strcmp( file, "-" ) )		{		infilename = copy_string( file );		yyin = fopen( infilename, "r" );		if ( yyin == NULL )			lerrsf( _( "can't open %s" ), file );		}	else		{		yyin = stdin;		infilename = copy_string( "<stdin>" );		}	linenum = 1;	}/* Wrapper routines for accessing the scanner's malloc routines. */void *flex_alloc( size_t size )	{	SpinCursor(32);	return (void *) malloc( size );	}void *flex_realloc( void *ptr, size_t size )	{	SpinCursor(32);	return (void *) realloc( ptr, size );	}void flex_free( void *ptr )	{	SpinCursor(32);	if ( ptr )		free( ptr );	}