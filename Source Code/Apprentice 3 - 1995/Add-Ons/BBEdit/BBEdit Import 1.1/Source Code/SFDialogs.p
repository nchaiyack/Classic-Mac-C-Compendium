unit SFDialogs;{ BBIMPORT PROJECT: }{ Open Dialog }{ ANTI© 1993-1994 Merzwaren }interface	uses		Translators;	function OpenDialog (standardFilter: ProcPtr;									hTransList: Handle;									var spec: FSSpec;									var format: Integer): OSErr;implementation	uses		DialogExtensions, Utilities;	const		kTypeDialogItemList = 'DITL';{ menu resource IDs (should be the same as the menu IDs!) }		kMenuImportTypes = 1001;{ dialog item list resource IDs }		kDITLOpenPopup = 1018;			{ DITL appended to standard Open dialog }{ dialog item numbers }		kItemFormatPopup = 1;			{ pop-up box showing available formats }		kItemDividingLine = 2;				{ PICT item for dividing line }	type{ the SFCallbackData record defines the information used}{ and maintained by our callback routines }		SFCallbackData = record				standardFilter: ProcPtr;				{ ptr to BBEdit standard dialog filter proc }				numItems: Integer;						{ count of original items in dialog }				popupSelection: Integer;				{ selected item in the file-type popup menu }				nTranslators: Integer;					{ number of translators }				hTransList: Handle;						{ handle to translator descriptors }			end;  { SFCallbackData }		SFCallbackPtr = ^SFCallbackData;		SFTypeListPtr = ^SFTypeList;	function CallFilter (dialog: DialogPtr;									var event: EventRecord;									var item: Integer;									filter: ProcPtr): Boolean;	inline		$205F, $4E90;	function GetDialogControl (dialog: DialogPtr;									item: Integer): ControlHandle;		var			itemType: Integer;			itemRect: Rect;	begin		GetDItem(dialog, item, itemType, Handle(GetDialogControl), itemRect);	end;  { GetDialogControl }	procedure FixDivider (dialog: DialogPtr;									item: Integer);		var			itemType: Integer;			itemHandle: Handle;			itemRect: Rect;	begin		GetDItem(dialog, item, itemType, itemHandle, itemRect);		itemRect.right := dialog^.portRect.right - itemRect.left;		SetDItem(dialog, item, itemType, itemHandle, itemRect);	end;  { FixDivider }	function SFFilter (dialog: DialogPtr;									var event: EventRecord;									var item: Integer;									pData: SFCallbackPtr): Boolean;	begin		SFFilter := false;		if ((event.what = activateEvt) or (event.what = updateEvt)) then			SFFilter := CallFilter(dialog, event, item, pData^.standardFilter);	end;  { SFFilter }	function SFHook (item: Integer;									dialog: DialogPtr;									pData: SFCallbackPtr): Integer;		var			additionalItems: Handle;			popupBox: ControlHandle;			oldSelection: Integer;	begin		SFHook := item;		with pData^ do			begin{ *be careful*: before trying to do anything with the dialog items, }{ make sure that we're being called for the main dialog }{ (not for an auxiliary dialog!) }				if (OSType(GetWRefCon(dialog)) = sfMainDialogRefCon) then					begin{ we have to add the pop-up to the standard items }{ on the first call (when dialog has been created but isn't showing yet) }						if (item = sfHookFirstCall) then							begin								numItems := CountDITL(dialog);								additionalItems := GetResource(kTypeDialogItemList, kDITLOpenPopup);								AppendDITL(dialog, additionalItems, appendDITLBottom);								ReleaseResource(additionalItems);								FixDivider(dialog, numItems + kItemDividingLine);							end;  { if first call }{ get a handle to the pop-up box control }						popupBox := GetDialogControl(dialog, numItems + kItemFormatPopup);{ on first call, set the pop-up selection to saved value }						if (item = sfHookFirstCall) then							SetCtlValue(popupBox, popupSelection);						if (item - numItems = kItemFormatPopup) then							begin								oldSelection := popupSelection;{ if the file-type popup was hit, retrieve the current selection }								popupSelection := GetCtlValue(popupBox);{ if pop-up selection changed, rebuild the file list }								if (oldSelection <> popupSelection) then									SFHook := sfHookRebuildList;							end;					end;  { if main dialog }			end;  { with }	end;  { SFHook }	function FileFilter (pb: CInfoPBPtr;									pData: SFCallbackPtr): Boolean;		const			kAllowDisplay = false;			kSuppressDisplay = true;			bDirectoryAttr = 4;		var			i: Integer;	begin		FileFilter := kSuppressDisplay;		with pb^, pData^ do			begin{ if this catalog entry is a directory, allow display and exit }				if BTST(ioFlAttrib, bDirectoryAttr) then					begin						FileFilter := kAllowDisplay;						Exit(FileFilter);					end;{ if we should show all available types, loop through list of translator description }				if (popupSelection = 1) then					begin						for i := 1 to nTranslators do							if IsMatch(ioFlFndrInfo.fdCreator, ioFlFndrInfo.fdType, hTransList, i) then								begin									FileFilter := kAllowDisplay;									Leave;								end;  { for i }					end				else{ display only the file types corresponding to the selected popup item }					if IsMatch(ioFlFndrInfo.fdCreator, ioFlFndrInfo.fdType, hTransList, popupSelection - 2) then						FileFilter := kAllowDisplay;			end;  { with }	end;  { FileFilter }	function OpenDialog (standardFilter: ProcPtr;									hTransList: Handle;									var spec: FSSpec;									var format: Integer): OSErr;		label			1;		var			reply: StandardFileReply;			callbackData: SFCallbackData;			popup: MenuHandle;			err: OSErr;	begin		popup := nil;		BlockClear(@reply, SizeOf(reply));{ set output parameters to zero or default values }		BlockClear(@spec, SizeOf(spec));		format := kUseDefault;{ build a pop-up menu of readable formats from the list of import translators }		err := BuildFormatMenu(kMenuImportTypes, hTransList, popup);		if (err <> noErr) then			goto 1;{ prepare the callback parameter block for our callbacks }		BlockClear(@callbackData, SizeOf(callbackData));		callbackData.standardFilter := standardFilter;		callbackData.popupSelection := 1;		callbackData.hTransList := hTransList;		callbackData.nTranslators := CountTranslators(hTransList);{ put up the Import File dialog }		CustomGetFile(@FileFilter, -1, SFTypeListPtr(nil)^, reply, 0, Point(-1), @SFHook, @SFFilter, nil, nil, @callbackData);{ exit with an error code if the user canceled the dialog }		err := userCanceledErr;		if (reply.sfGood = false) then			goto 1;{ copy the file specification record }		spec := reply.sfFile;{ copy the index to the preferred translator, if any }		if (callbackData.popupSelection > 2) then			format := callbackData.popupSelection - 2;{ clear result code }		err := noErr;1:{ clean up }		if (popup <> nil) then			begin				DeleteMenu(kMenuImportTypes);				ReleaseResource(Handle(popup));			end;{ return result code }		OpenDialog := err;	end;  { OpenDialog }end.