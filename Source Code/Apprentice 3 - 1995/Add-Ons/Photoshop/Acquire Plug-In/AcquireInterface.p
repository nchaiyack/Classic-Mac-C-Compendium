(*}{	File: AcquireInterface.h				}{}{	Copyright 1990-91 by Thomas Knoll.			}{}{	This file describes version 4.0 of Photoshop's Acquisition module interface.}(*  Converted 1994-03-05 using Dan's Source Converter 		*){The code resource and file type for acquisition modules is Ô8BAMÕ.}Unit AcquireInterface;Interface	Const    (* Operation selectors *)		acquireSelectorAbout = 0;		acquireSelectorStart = 1;		acquireSelectorContinue = 2;		acquireSelectorFinish = 3;		acquireSelectorPrepare = 4;    (* Image modes *)		acquireModeBitmap = 0;		acquireModeGrayScale = 1;		acquireModeIndexedColor = 2;		acquireModeRGBColor = 3;		acquireModeCMYKColor = 4;		acquireModeHSLColor = 5;		acquireModeHSBColor = 6;		acquireModeMultichannel = 7;		acquireModeDuotone = 8;    (* Error return values. The plug-in module may also return standard Macintosh}    { operating system error codes, or report its own errors, in which case it}    { can return any positive integer. *)		acquireBadParameters = -30000;	(* "a problem with the acquisition module interface" *)		acquireNoScanner = -30001;		(* "there is no scanner installed" *)		acquireScannerProblem = -30002;	(* "a problem with the scanner" *)	Type		AcquireLUT = Packed Array[0..255] Of char;		AcquireMap = Array[0..15] Of Integer;		AcquireRecordPtr = ^AcquireRecord;		AcquireMonitor = Record				gamma: Fixed;			(* Gamma value *)				redX: Fixed;			(* Red phosphor *)				redY: Fixed;				greenX: Fixed;			(* Green phosphor *)				greenY: Fixed;				blueX: Fixed;			(* Blue phosphor *)				blueY: Fixed;				whiteX: Fixed;			(* White point *)				whiteY: Fixed;				ambient: Fixed;			(* 0.0 = Low, 0.5 = Medium, 1.0 = High *)			End;		AcquireRecord = Record				serialNumber: LongInt;		(* Host's serial number, to allow}{					copy protected plug-in modules. *)				abortProc: ProcPtr;		(* The plug-in module may call this no-argument}{					BOOLEAN function (using Pascal calling}{					conventions) several times a second during long}{					operations to allow the user to abort the operation.}{					If it returns TRUE, the operation should be aborted}{					(and a positive error code returned). *)				progressProc: ProcPtr;		(* The plug-in module may call this two-argument}{					procedure (using Pascal calling conventions)}{					periodically to update a progress indicator.}{					The first parameter (type LONGINT) is the number}{					of operations completed; the second (type LONGINT)}{					is the total number of operations. *)				maxData: LongInt;		(* Maximum number of bytes that should be}{					passed back at once, plus the size of any}{					interal buffers. The plug-in may reduce this}{					value in the acquireSelectorPrepare routine. *)				imageMode: Integer;		(* Image mode *)				imageSize: Point;		(* Size of image *)				depth: Integer;			(* Bits per sample, currently must be 1 or 8 *)				planes: Integer; 		(* Samples per pixel *)				imageHRes: Fixed;		(* Horizontal Pixels per inch *)				imageVRes: Fixed;		(* Vertical Pixels per inch *)				redLUT: AcquireLUT; 		(* Red LUT, only used for Indexed Color images *)				greenLUT: AcquireLUT;		(* Green LUT, only used for Indexed Color images *)				blueLUT: AcquireLUT;		(* Blue LUT, only used for Indexed Color images *)				data: Ptr;			(* A pointer to the returned image data. The}{					plug-in module is now responsible for freeing}{					this buffer (this is a change from previous}{					versions). Should be set to NIL when}{					all the image data has been returned. *)				theRect: Rect;			(* Rectangle being returned *)				loPlane: Integer;		(* First plane being returned *)				hiPlane: Integer;		(* Last plane being returned *)				colBytes: Integer;		(* Spacing between columns *)				rowBytes: LongInt;		(* Spacing between rows *)				planeBytes: LongInt; 		(* Spacing between planes (ignored if only one}{					plane is returned at a time) *)				filename: Str255;		(* Document file name *)				vRefNum: Integer;		(* Volume reference number, or zero if none *)				dirty: Boolean;			(* Changes since last saved flag. The plug-in may clear}{					this field to prevent prompting the user when}{					closing the document. *)				hostSig: OSType;		(* Creator code for host application *)				hostProc: ProcPtr;		(* Host specific callback procedure *)				hostModes: LongInt;		(* Used by the host to inform the plug-in which}{					imageMode values it supports.  If the corresponding}{					bit (LSB = bit 0) is 1, the mode is supported. *)				planeMap: AcquireMap;		(* Maps plug-in plane numbers to host plane}{					numbers.  The host initializes this is a linear}{					mapping.  The plug-in may change this mapping if}{					it sees the data in a different order. *)				canTranspose: Boolean;		(* Is the host able to transpose the image? *)				needTranspose: Boolean;		(* Does the plug-in need the image transposed? *)				duotoneInfo: Handle;		(* Handle to duotone information, if returning a}{					duotone mode image.  The plug-in is responsible}{					for freeing this buffer. *)				diskSpace: LongInt;		(* Free disk space on the host's scratch disk or}{					disks.  Set to a negative number if host does}{					not use a scratch disk. *)				spaceProc: ProcPtr;	{ If not NIL, a pointer to a no-argument}{				LONGINT function (using Pascal calling}{				conventions) which uses the current settings of}{				the imageMode, imageSize, depth, and planes}{				fields to compute the amount of scratch disk}{				space required to hold the image.  Returns -1}{				if the settings are not valid. }				monitor: AcquireMonitor;	(* Information on current monitor *)				reserved: Packed Array[0..255] Of char;(* Set to zero *)			End;ImplementationEnd.