unit Movable;interface	uses		TransSkel, ButtonGlobals;	procedure DoMovableModal;	procedure InitMovableModal;implementation	const		okBtn = 1;		cancelBtn = 2;	var		dlog: DialogPtr;{--------------------------------------------------------------------}{ Dialog handling procedures }{--------------------------------------------------------------------}	function Filter (dlog: DialogPtr;									evt: EventRecord;									var item: Integer): Boolean;		var			hilite: Integer;			ignore: Boolean;	begin		Filter := false;		case evt.what of			updateEvt: 				SkelDrawButtonOutline(SkelGetDlogCtl(dlog, okBtn));			activateEvt: 				begin					if (BitAnd(evt.modifiers, activeFlag) <> 0) then						hilite := normalHilite					else						hilite := dimHilite;					ignore := SkelSetDlogCtlHilite(dlog, okBtn, hilite);					SkelDrawButtonOutline(SkelGetDlogCtl(dlog, okBtn));					ignore := SkelSetDlogCtlHilite(dlog, cancelBtn, hilite);				end;			keyDown: 				Filter := SkelDlogMapKeyToButton(dlog, evt, item, okBtn, cancelBtn);		end;	end;	procedure Select (dlog: DialogPtr;									item: Integer);	begin		case item of			okBtn, cancelBtn: 				begin					HideWindow(dlog);{AdjustMenus;}				end;		end;	end;	procedure Clobber;		var			dlog: DialogPtr;	begin		GetPort(dlog);		HideWindow(dlog);		DisposeDialog(dlog);	end;	procedure DoMovableModal;		var			ignore: Boolean;	begin		if (dlog <> nil) then			begin				SelectWindow(dlog);				ShowWindow(dlog);				exit(DoMovableModal);			end;		dlog := GetNewDialog(movableRes, nil, WindowPtr(-1));		if (dlog = nil) then			begin				SysBeep(1);				exit(DoMovableModal);			end;		SkelPositionWindow(dlog, skelPositionOnMainDevice, horizRatio, vertRatio);		ignore := SkelDialog(dlog, @Filter, @Select, nil, @Clobber);		ShowWindow(dlog);{AdjustMenus;}	end;	procedure InitMovableModal;	begin		dlog := nil;	end;end.