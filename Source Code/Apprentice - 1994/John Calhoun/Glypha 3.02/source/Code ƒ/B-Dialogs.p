unit Dialogs;interface	var		rightOffset, downOffset: Integer;	procedure D_ConfigureGameWndo (var mortals, level, toDelay: Integer; var soundOn: Boolean; cantSing: Boolean);	procedure D_ControlsWndo (var keyboardControl: Boolean);	procedure WhosHiScore (var theName: Str255);implementation	const							{These are the item numbers for controls in the Dialog	}		I_Okay = 1;					{They are found in the .RSRC fork of Glypha				}		I_Cancel = 2;		I_Sound_OFF = 3;		I_Sound_ON = 4;		I_Fast = 5;		I_Fastest = 6;		I_Slow = 14;		I_Slowest = 15;		I_Static_Text = 2;		I_Static_Text3 = 3;		I_Static_Text7 = 7;		I_Static_Text8 = 8;		I_Static_Text10 = 9;		I_Edit_Text = 4;		I_Edit_Text6 = 5;		I_Edit_Text10 = 10;		I_Edit_Text13 = 11;		I_Rectanglex12 = 12;		I_Rectanglex13 = 13;		I_Drawn_line = 14;		I_Drawn_line18 = 15;		I_Keyboard = 3;		I_Mouse = 4;		I_Static_Text5 = 5;		I_Iconx6 = 6;		I_Iconx7 = 7;		I_Iconx8 = 8;		I_Iconx9 = 9;		I_Iconx10 = 10;		I_Iconx11 = 11;		I_Iconx12 = 12;		I_Iconx13 = 13;		I_Rectanglex14 = 14;		I_Rectanglex15 = 15;		I_Rectanglex16 = 16;	var		GetSelection: DialogPtr;             {Name of dialog}		tempRect: Rect;                      {Temporary tectangle}		DType: Integer;                      {Type of dialog item}		Index: Integer;                      {For looping}		DItem: Handle;                       {Handle to the dialog item}		CItem, CTempItem: controlhandle;     {Control handle}		sTemp: Str255;                       {Get text entered, temp holding}		itemHit: Integer;                    {Get selection}		temp: Integer;                       {Get selection, temp holding}		ThisEditText: TEHandle;              {Handle to get the Dialogs TE record}		TheDialogPtr: DialogPeek;            {Pointer to Dialogs definition record, contains the TE record}		ExitDialog, keepIt: boolean;{==========================================================}	procedure D_ConfigureGameWndo;		var			soundCopy, keepIt: Boolean;			delayCopy, levelCopy, mortalsCopy, rightOff, downOff, Index: Integer;			theValue: Integer;			nTemp: LongInt;		procedure Refresh_Dialog;			{Refresh the dialogs non-controls	}			var				rTempRect: Rect;		begin			rTempRect := tempRect;			PenSize(1, 1);			MoveTo(8, 80);			LineTo(340, 80);			MoveTo(171, 40);			LineTo(171, 134);			SetRect(tempRect, 6, 40, 341, 135);			FrameRect(tempRect);			MoveTo(7, 29);			LineTo(340, 29);			LineTo(340, 6);			SetRect(tempRect, 6, 5, 340, 29);			FrameRect(tempRect);			SetRect(tempRect, 222, 146, 299, 173);			PenSize(3, 3);			FrameRoundRect(tempRect, 15, 15);			PenSize(1, 1);			tempRect := rTempRect;		end;	begin		levelCopy := level;		mortalsCopy := mortals;		soundCopy := soundOn;		delayCopy := toDelay;		GetSelection := GetNewDialog(3, nil, Pointer(-1));	{Bring in the dialog resource		}		with GetSelection^.portBits do			begin				rightOff := rightOffset - bounds.left;				downOff := downOffset - bounds.top;			end;		MoveWindow(GetSelection, rightOff, downOff, FALSE);		ShowWindow(GetSelection);		SelectWindow(GetSelection);						{Lets see it							}		SetPort(GetSelection);								{Perpare to add conditional text	}		TheDialogPtr := DialogPeek(GetSelection);{Get to the inner record			}		ThisEditText := TheDialogPtr^.textH;	{Get to the TE record			}		HLock(Handle(ThisEditText));					{Lock it for safety				}		ThisEditText^^.txSize := 12;					{TE Point size						}		TextSize(12);													{Window Point size				}		ThisEditText^^.txFont := systemFont;	{TE Font ID								}		TextFont(systemFont);									{Window Font ID						}		ThisEditText^^.txFont := 0;						{TE Font ID								}		ThisEditText^^.fontAscent := 12;			{Font ascent							}		ThisEditText^^.lineHeight := 12 + 3 + 1;{Font ascent + descent + leading	}		HUnLock(Handle(ThisEditText));				{UnLock handle when done	}		if (soundOn) then			begin				GetDItem(GetSelection, I_Sound_ON, DType, DItem, tempRect);				CItem := Pointer(DItem);				SetCtlValue(CItem, 1);			end		else			begin				GetDItem(GetSelection, I_Sound_OFF, DType, DItem, tempRect);				CItem := Pointer(DItem);				SetCtlValue(CItem, 1);			end;		if (cantSing) then					{cantSing is TRUE if run under older than System 6.0	}			begin				GetDItem(GetSelection, I_Sound_ON, DType, DItem, tempRect);				CItem := Pointer(DItem);				HiliteControl(CItem, 255);				GetDItem(GetSelection, I_Sound_OFF, DType, DItem, tempRect);				CItem := Pointer(DItem);				HiliteControl(CItem, 255);			end;		case toDelay of			0: 				GetDItem(GetSelection, I_Fastest, DType, DItem, tempRect);			1: 				GetDItem(GetSelection, I_Fast, DType, DItem, tempRect);			3: 				GetDItem(GetSelection, I_Slow, DType, DItem, tempRect);			4: 				GetDItem(GetSelection, I_Slowest, DType, DItem, tempRect);			otherwise				begin					GetDItem(GetSelection, I_Fastest, DType, DItem, tempRect);				end;		end;		CItem := Pointer(DItem);		SetCtlValue(CItem, 1);			{Select to slower}		GetDItem(GetSelection, I_Edit_Text10, DType, DItem, tempRect);		NumToString(mortalsCopy, sTemp);		SetIText(DItem, sTemp);		GetDItem(GetSelection, I_Edit_Text13, DType, DItem, tempRect);		NumToString(levelCopy, sTemp);		SetIText(DItem, sTemp);		SelIText(GetSelection, I_Edit_Text13, 0, 2);		Refresh_Dialog;		ExitDialog := FALSE;					{Do not exit dialog handle loop yet	}		repeat												{Start of dialog handle loop				}			ModalDialog(nil, itemHit);	{Wait until an item is hit					}			GetDItem(GetSelection, itemHit, DType, DItem, tempRect);	{Get item information	}			CItem := Pointer(DItem);		{Get the control handle							}			if (ItemHit = I_Okay) then	{Handle the Button being pressed					}				begin					GetDItem(GetSelection, I_Edit_Text10, DType, DItem, tempRect); {Get the item handle}					GetIText(DItem, sTemp);					StringToNum(sTemp, nTemp);					mortalsCopy := LoWord(nTemp);					GetDItem(GetSelection, I_Edit_Text13, DType, DItem, tempRect); {Get the item handle}					GetIText(DItem, sTemp);			{Get the text entered								}					StringToNum(sTemp, nTemp);					levelCopy := LoWord(nTemp);					if ((levelCopy < 1) or (levelCopy > 99)) then						begin							GetDItem(GetSelection, I_Edit_Text13, DType, DItem, tempRect);							NumToString(levelCopy, sTemp);							SetIText(DItem, sTemp);							levelCopy := level;						end;					if ((mortalsCopy < 1) or (mortalsCopy > 99)) then						begin							GetDItem(GetSelection, I_Edit_Text10, DType, DItem, tempRect);							NumToString(mortalsCopy, sTemp);							SetIText(DItem, sTemp);							mortalsCopy := mortals;						end;					if ((mortalsCopy > 0) and (mortalsCopy < 100)) and ((levelCopy > 0) and (levelCopy < 100)) then						begin							level := levelCopy;							mortals := mortalsCopy;							keepIt := TRUE;							ExitDialog := TRUE;						end;					Refresh_Dialog;				end;			if (ItemHit = I_Cancel) then				begin					keepIt := FALSE;					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit >= I_Sound_OFF) and (ItemHit <= I_Sound_ON) then {Handle the Radio selection}				begin					for Index := I_Sound_OFF to I_Sound_ON do {Clear all other radios}						begin							GetDItem(GetSelection, Index, DType, DItem, tempRect); {Get the Radio handle}							CTempItem := Pointer(DItem);    {Convert to a control handle}							SetCtlValue(CTempItem, 0);      {Turn the radio selection OFF}						end;                              {End of clear the radio selections loop}					SetCtlValue(CItem, 1);            {Turn the one radio selection ON}					GetDItem(GetSelection, I_Sound_OFF, DType, DItem, tempRect);					theValue := GetCtlValue(Pointer(DItem));					if (theValue = 1) then						soundCopy := FALSE					else						soundCopy := TRUE;				end;			if ((ItemHit = I_Slowest) or (ItemHit = I_Fastest) or (ItemHit = I_Fast) or (ItemHit = I_Slow)) then {Handle the Radio selection}				begin					GetDItem(GetSelection, I_Slowest, DType, DItem, tempRect);	{Get the Radio handle}					CTempItem := Pointer(DItem);										{Convert to a control handle			}					SetCtlValue(CTempItem, 0);										{Turn the radio selection OFF				}					GetDItem(GetSelection, I_Fastest, DType, DItem, tempRect);	{Get the Radio handle}					CTempItem := Pointer(DItem);										{Convert to a control handle			}					SetCtlValue(CTempItem, 0);										{Turn the radio selection OFF				}					GetDItem(GetSelection, I_Fast, DType, DItem, tempRect);		{Get the Radio handle}					CTempItem := Pointer(DItem);										{Convert to a control handle			}					SetCtlValue(CTempItem, 0);										{Turn the radio selection OFF				}					GetDItem(GetSelection, I_Slow, DType, DItem, tempRect);		{Get the Radio handle}					CTempItem := Pointer(DItem);										{Convert to a control handle			}					SetCtlValue(CTempItem, 0);										{Turn the radio selection OFF				}																	{End of clear the radio selections loop	}					SetCtlValue(CItem, 1);													{Turn the one radio selection ON	}					GetDItem(GetSelection, I_Fastest, DType, DItem, tempRect);					theValue := GetCtlValue(Pointer(DItem));					if (theValue = 1) then						delayCopy := 0;					GetDItem(GetSelection, I_Fast, DType, DItem, tempRect);					theValue := GetCtlValue(Pointer(DItem));					if (theValue = 1) then						delayCopy := 1;					GetDItem(GetSelection, I_Slow, DType, DItem, tempRect);					theValue := GetCtlValue(Pointer(DItem));					if (theValue = 1) then						delayCopy := 3;					GetDItem(GetSelection, I_Slowest, DType, DItem, tempRect);					theValue := GetCtlValue(Pointer(DItem));					if (theValue = 1) then						delayCopy := 4;				end;		until ExitDialog;		if (keepIt) then			begin				soundOn := soundCopy;				toDelay := delayCopy;			end;		DisposDialog(GetSelection);	end;{===========================================================}	function MyFilter (theDialog: DialogPtr; var theEvent: EventRecord; var itemHit: integer): boolean;		var			MyPt: Point;	begin		MyFilter := FALSE;		if (theEvent.what = MouseDown) then			begin				MyPt := theEvent.where;				with theDialog^.portBits.bounds do					begin						myPt.h := myPt.h + left;						myPt.v := myPt.v + top;					end;			end;	end;{===========================================================}	procedure D_ControlsWndo;		var			Index, rightOff, downOff: Integer;		procedure Refresh_Dialog;			var				rTempRect: Rect;		begin			rTempRect := tempRect;			PenSize(1, 1);			MoveTo(127, 114);			LineTo(265, 114);			LineTo(265, 36);			SetRect(TempRect, 126, 35, 265, 114);			FrameRect(TempRect);			MoveTo(127, 164);			LineTo(265, 164);			LineTo(265, 121);			SetRect(TempRect, 126, 120, 265, 164);			FrameRect(TempRect);			MoveTo(7, 32);			LineTo(267, 32);			LineTo(267, 6);			SetRect(TempRect, 6, 5, 267, 32);			FrameRect(TempRect);			SetRect(tempRect, 172, 176, 257, 203);			PenSize(3, 3);			FrameRoundRect(tempRect, 15, 15);			PenSize(1, 1);			tempRect := rTempRect;		end;	begin		GetSelection := GetNewDialog(4, nil, Pointer(-1));		with GetSelection^.portBits do			begin				rightOff := rightOffset - bounds.left;				downOff := downOffset - bounds.top;			end;		MoveWindow(GetSelection, rightOff, downOff, FALSE);		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GetSelection);		TheDialogPtr := DialogPeek(GetSelection);		ThisEditText := TheDialogPtr^.textH;		HLock(Handle(ThisEditText));		ThisEditText^^.txSize := 12;		TextSize(12);		ThisEditText^^.txFont := systemFont;		TextFont(systemFont);		ThisEditText^^.txFont := 0;		ThisEditText^^.fontAscent := 12;		ThisEditText^^.lineHeight := 12 + 3 + 1;		HUnLock(Handle(ThisEditText));		if (keyboardControl) then			GetDItem(GetSelection, I_Keyboard, DType, DItem, tempRect)		else			GetDItem(GetSelection, I_Mouse, DType, DItem, tempRect);		CItem := Pointer(DItem);		SetCtlValue(CItem, 1);		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := Pointer(DItem);			if (ItemHit = I_Okay) then				begin					keepIt := TRUE;					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit = I_Cancel) then				begin					keepIt := FALSE;					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit >= I_Keyboard) and (ItemHit <= I_Mouse) then				begin					for Index := I_Keyboard to I_Mouse do						begin							GetDItem(GetSelection, Index, DType, DItem, tempRect);							CTempItem := Pointer(DItem);							SetCtlValue(CTempItem, 0);						end;					SetCtlValue(CItem, 1);				end;		until ExitDialog;		Index := I_Keyboard;		repeat			GetDItem(GetSelection, Index, DType, DItem, tempRect);			CItem := Pointer(DItem);			temp := GetCtlValue(CItem);			Index := Index + 1;		until (temp <> 0) or (Index > I_Mouse);		temp := Index - I_Keyboard + 1;		if (keepIt) then			begin				if (temp = 3) then					keyboardControl := FALSE				else					keyboardControl := TRUE;			end;		DisposDialog(GetSelection);	end;{===========================================}	procedure WhosHiScore;		var			excessSpace, rightOff, downOff: Integer;			dotFiller, space: Str255;		procedure Refresh_Dialog;				{This draws the rounded-rectangular		}			var											{border around the Okay button so that		}				rTempRect: Rect;							{the user knows it is the default button.		}		begin			PenNormal;			PenSize(3, 3);			SetRect(rTempRect, 167, 36, 251, 65);			FrameRoundRect(rTempRect, 13, 13);		end;	begin															{Start of dialog handler}		GetSelection := GetNewDialog(999, nil, Pointer(-1));{Bring in the dialog resource}		with GetSelection^.portBits do			begin				rightOff := rightOffset - bounds.left;				downOff := downOffset - bounds.top;			end;		MoveWindow(GetSelection, rightOff, downOff, FALSE);		ShowWindow(GetSelection);		SelectWindow(GetSelection);								{Lets see it}		SetPort(GetSelection);										{Perpare to add conditional text}		TheDialogPtr := DialogPeek(GetSelection);	{Get to the inner record}		ThisEditText := TheDialogPtr^.textH;			{Get to the TE record}		HLock(Handle(ThisEditText));							{Lock it for safety}		ThisEditText^^.txSize := 12;							{TE Point size}		TextSize(12);															{Window Point size}		ThisEditText^^.txFont := systemFont;  		{TE Font ID}		TextFont(systemFont);											{Window Font ID}		ThisEditText^^.txFont := 0;								{TE Font ID}		ThisEditText^^.fontAscent := 12;					{Font ascent}		ThisEditText^^.lineHeight := 12 + 3 + 1;	{Font ascent + descent + leading}		HUnLock(Handle(ThisEditText));						{UnLock the handle when done}		GetDItem(GetSelection, I_Edit_Text, DType, DItem, tempRect);		SetIText(DItem, theName);									{Set the default text}		SelIText(GetSelection, I_Edit_Text, 0, 15);{Select the text}		ExitDialog := FALSE;											{Don't exit dialog loop yet}		Refresh_Dialog;		repeat																		{Start of dialog loop}			ModalDialog(nil, itemHit);							{Wait until item is hit}			GetDItem(GetSelection, itemHit, DType, DItem, tempRect); {Get item information}			CItem := Pointer(DItem);								{Get the control handle}			if (ItemHit = I_Okay) then							{Handle the Button pressed}				begin					GetDItem(GetSelection, I_Edit_Text, DType, DItem, tempRect); {Get the item handle}					GetIText(DItem, sTemp);							{Get the text entered}					if (LENGTH(sTemp) > 15) then				{Make sure it's less than 15 characters}						theName := COPY(sTemp, 1, 15)			{Just clip the first 15 if it is too long}					else						begin							if (LENGTH(sTemp) < 15) then								begin									space := '               ';									excessSpace := 15 - LENGTH(sTemp);									dotFiller := COPY(space, 1, excessSpace);									sTemp := CONCAT(sTemp, dotfiller);								end;							theName := sTemp;							{Otherwise, take it as is}						end;					ExitDialog := TRUE;								{Exit the dialog when this selection is made}				end;												{End for this item selected}		until ExitDialog;										{Handle dialog items until exit selected}		DisposDialog(GetSelection);						{Flush the dialog out of memory}	end;														{End of procedure}{=============================================================}end.