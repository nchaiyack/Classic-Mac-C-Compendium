unit GlyphaGuts;interface	uses		Palettes, Dialogs, Sound, Globals, Enemies, GameUtils;	procedure DoAStoneHit (whichStone: Rect);	procedure MoveThePlayer;	procedure CheckTombStones;	procedure AnimateTheAnk;	procedure AdvanceALevel;	procedure EnterANewMortal;	procedure DoEnd;	procedure ExitAMortal;	procedure SlideTheStones;implementation{=================================}	procedure DoOnTheGround;		var			onLand: Boolean;			index: Integer;			tempRect, dummyRect: Rect;	begin		with thePlayer do			begin				if (state) then		{taking off from the ground}					begin						DoTheSound('flap.snd', lowPriority);						state := FALSE;						mode := 5;						ChangeRect;						vertVel := liftAmount;					end				else							{but if not flapping...}					begin						onLand := FALSE;						tempRect := dest;						InsetRect(tempRect, 17, 0);						OffsetRect(tempRect, 0, 2);						for index := startStone to numberOfStones do							if (SectRect(tombRects[index], tempRect, dummyRect)) then								onLand := TRUE;						if not onLand then							begin								mode := 4;								ChangeRect;								vertVel := fallAmount;							end						else							{on solid ground}							begin								if (keyStillDown) then	{and running}									begin										horiVel := running[horiVel, facing, 0];										mode := running[horiVel, facing, 1];										if ((mode = 0) or (mode = 2)) then											DoTheSound('walk.snd', lowPriority);									end								else							{not running, we're braking - screeeech}									begin										mode := 1;										horiVel := idleLanded[horiVel];										if (horiVel <> 0) then											DoTheSound('screech.snd', lowPriority);									end;						{end - else, key still down}							end;							{end - else, not on solid ground}					end;								{end - else, not flapping to take off}				dest.left := dest.left + horiVel;				dest.right := dest.right + horiVel;				dest.top := dest.top + vertVel;				dest.bottom := dest.bottom + vertVel;			end;	end;{=================================}	procedure DoAStoneHit;	begin		with thePlayer do			begin				if (horiVel > 0) then					begin						if (dest.left < whichStone.left) then	{hit the edge}							begin								dest.left := dest.left + whichStone.left - whichStone.right;								dest.right := dest.right + whichStone.left - whichStone.right;								horiVel := impacted[horiVel];							end						else							begin								if (vertVel < 0) then							{hit coming up}									begin										vertVel := impacted[vertVel];										OffsetRect(dest, 0, whichStone.bottom - dest.top);									end								else									begin										if (mode = 6) then											begin												DoTheSound('boom1.snd', highPriority);												OffsetRect(dest, 0, whichStone.top - dest.bottom);												vertVel := 0;												horiVel := 0;												mode := 50;												ChangeRect;												Exit(DoAStoneHit);											end;										if (vertVel < 4) or (dest.right > whichStone.right) then											begin												DoTheSound('screech.snd', lowPriority);												vertVel := -3;												OffSetRect(dest, 0, whichStone.top - dest.bottom);											end										else											begin												DoTheSound('walk.snd', lowPriority);												vertVel := 0;												OffSetRect(dest, 0, whichStone.top - dest.bottom - 10);												mode := 1;												ChangeRect;											end;									end;							end;					end				else					begin						if (dest.right > whichStone.right) then	{hit the edge}							begin								OffsetRect(dest, whichStone.right - whichStone.left, 0);								horiVel := impacted[horiVel];							end						else							begin								if (vertVel < 0) then		{hit coming up}									begin										vertVel := impacted[vertVel];										OffsetRect(dest, 0, whichStone.bottom - dest.top);									end								else									begin										if (mode = 6) then											begin												DoTheSound('boom1.snd', highPriority);												OffsetRect(dest, 0, whichStone.top - dest.bottom);												vertVel := 0;												horiVel := 0;												if (mortals <= 1) then													mode := 7												else													mode := 50;												ChangeRect;												Exit(DoAStoneHit);											end;										if (vertVel < 4) or (dest.left < whichStone.left) then											begin												DoTheSound('screech.snd', lowPriority);												vertVel := -3;												OffSetRect(dest, 0, whichStone.top - dest.bottom);											end										else											begin												DoTheSound('walk.snd', lowPriority);												vertVel := 0;												OffSetRect(dest, 0, whichStone.top - dest.bottom - 10);												mode := 1;												ChangeRect;											end;									end;							end;					end;			end;	end;{=================================}	procedure DoInTheAir;		var			index: Integer;			tempRect, dummyRect: Rect;	begin		with thePlayer do			begin				if (keyStillDown) then					horiVel := gliding[horiVel, facing];				if (state) then					begin						DoTheSound('flap.snd', lowPriority);						mode := 5;						state := FALSE;						vertVel := vertVel + liftAmount;					end				else					begin						if (vertVel < maxFall) then							vertVel := vertVel + fallAmount;						if (vertVel > 0) then							mode := 4						else							mode := 5;					end;				dest.left := dest.left + horiVel;				dest.right := dest.right + horiVel;				dest.top := dest.top + vertVel;				dest.bottom := dest.bottom + vertVel;				for index := startStone to numberOfStones do					begin						if SectRect(dest, tombRects[index], dummyRect) then							DoAStoneHit(dummyRect);					end;			end;	end;{=================================}	procedure DoFallingSkeleton;		var			index: Integer;			dummyRect: Rect;	begin		with thePlayer do			begin				if (vertVel < maxFall) then					vertVel := vertVel + fallAmount;				dest.left := dest.left + horiVel;				dest.right := dest.right + horiVel;				dest.top := dest.top + vertVel;				dest.bottom := dest.bottom + vertVel;				for index := startStone to numberOfStones do					begin						if SectRect(dest, tombRects[index], dummyRect) then							DoAStoneHit(dummyRect);					end;			end;	end;{=================================}	procedure DoDeadBones;	begin		with thePlayer do			begin				if (mode < 8) then					begin						OffsetRect(dest, 0, 1);						dest.bottom := dest.bottom - 1;						if (dest.bottom = dest.top) then							begin								deadAndGone := TRUE;								CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, mainWndo^.portBits, dest, dest, srcCopy, playRgn);							end;					end				else					mode := mode - 1;			end;	end;{=================================}	procedure MoveThePlayer;	begin		case thePlayer.mode of			0..3: 				begin					DoOnTheGround;					CheckTombStones;				end;			4..5: 				begin					DoInTheAir;					CheckTombStones;				end;			6: 				begin					DoFallingSkeleton;					CheckTombStones;				end;			7..100: 				DoDeadBones;		end;	end;{=================================}	procedure CheckTombStones;		var			hori, vert: Integer;			dummyRect: Rect;{-------------------}		procedure TooLow;		begin			with thePlayer do				if (otherState) then					begin						OffsetRect(dest, 0, 1);						if (dest.top > playRect.bottom + 10) then							deadAndGone := TRUE;						Exit(CheckTombStones);					end				else					begin						DoTheSound('bird.snd', highPriority);						OffsetRect(dest, 0, playRect.bottom - dest.top + 1);						otherState := TRUE;						Exit(CheckTombStones);					end;		end;{-------------------}		procedure TooHi;		begin			with thePlayer do				begin					vertVel := impacted[vertVel];					OffSetRect(dest, 0, playRect.top - dest.bottom + 1);				end;		end;{-------------------}		procedure TooLeft;		begin			with thePlayer do				begin					CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, mainWndo^.portBits, oldDest, oldDest, srcCopy, playRgn);					OffsetRect(dest, 640, 0);					oldDest := dest;				end;		end;{-------------------}		procedure TooRight;		begin			with thePlayer do				begin					CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, mainWndo^.portBits, oldDest, oldDest, srcCopy, playRgn);					OffsetRect(dest, -640, 0);					oldDest := dest;				end;		end;{-------------------}	begin		with thePlayer do			if (not SectRect(dest, playRect, dummyRect)) then	{Player has left the screen	}				begin					if (dest.top > playRect.bottom) then						TooLow;					if (dest.bottom <= playRect.top) then						TooHi;					if (dest.right < playRect.left) then						TooLeft;					if (dest.left > playRect.right) then						TooRight;				end;	end;{=================================}	procedure AnimateTheAnk;		var			index, index2, howHigh: Integer;			dummyLong, loopDelay: LongInt;			newRect, tempRect: Rect;			theKeys: KeyMap;	begin		DoTheSound('lightning.snd', highPriority);		if ((numberOfStones > 4) and (DoRandom(2) = 0) and (not stonesSliding)) then			begin				newRect := playerRects[0, 0];				OffsetRect(newRect, -newRect.left - 24, -newRect.top);				OffsetRect(newRect, 320, tombRects[5].top - newRect.bottom);				howHigh := upperLevel;				thePlayer.dest := newRect;				thePlayer.oldDest := thePlayer.dest;			end		else			begin				newRect := playerRects[0, 0];				OffsetRect(newRect, -newRect.left - 24, -newRect.top);				OffsetRect(newRect, 320, tombRects[0].top - newRect.bottom);				howHigh := lowerLevel;				thePlayer.dest := newRect;				thePlayer.oldDest := thePlayer.dest;			end;		newRect.left := newRect.left + 10;		newRect.right := newRect.left + 16;		newRect.top := newRect.bottom - 23;		CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, mainWndo^.portBits, ankRects[0], ankRects[0], newRect);		StrikeLightning(howHigh);		StrikeLightning(howHigh);		StrikeLightning(howHigh);		tempRect := thePlayer.dest;		FlushEvents(everyEvent, 0);		loopDelay := TickCount + gameSpeed;		for index := 0 to 60 do		{Here's where the player flashes in get-ready mode	}			begin				DoTheSound('rez.snd', highPriority);				CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, tempRect, tempRect, srcCopy, nil);				CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, ankRects[0], ankRects[0], newRect);				CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, mainWndo^.portBits, tempRect, tempRect, srcCopy, mainWndo^.visRgn);				if (stonesSliding) then					SlideTheStones;				UpdateEye;				HandleTheEnemies;				DrawBeasts;				repeat					GetKeys(theKeys);					if (theKeys[kSpaceKey] or Button) then						begin							thePlayer.otherState := FALSE;							FlushEvents(everyEvent, 0);							Exit(AnimateTheAnk);						end;				until (TickCount >= loopDelay);				loopDelay := TickCount + gameSpeed;				CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, newRect, newRect, srcCopy, nil);				CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, BitMapPtr(loadCPtr^.portPixMap^)^, playerRects[0, 1], playerRects[0, 1], tempRect);				CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, mainWndo^.portBits, tempRect, tempRect, srcCopy, mainWndo^.visRgn);				if (stonesSliding) then					SlideTheStones;				UpdateEye;				HandleTheEnemies;				if (theHand.state) then					RetractTheHand;				DrawBeasts;				repeat					GetKeys(theKeys);					if (theKeys[kSpaceKey] or Button) then						begin							thePlayer.otherState := FALSE;							FlushEvents(everyEvent, 0);							Exit(AnimateTheAnk);						end;				until (TickCount >= loopDelay);				loopDelay := TickCount + gameSpeed;			end;		thePlayer.otherState := FALSE;		FlushEvents(everyEvent, 0);	end;{=================================}	procedure AdvanceALevel;		var			index, aNumber, anotherNumber: Integer;{--------------------}		procedure SetUpEggEnemies;			var				index: Integer;		begin			totalToKill := 6;			numberOfEnemies := 6;			beastsActive := 6;			for index := 1 to numberOfEnemies do				with theEnemies[index] do					begin						mode := -DoRandom(kEggDelayRange) + (levelOn * kEggLevelPenalty);						if (mode > -100) then							mode := DoRandom(50) - 150;						otherState := TRUE;						facing := DoRandom(2);						aNumber := DoRandom(2);					{Now we figure out where the sphinx is	}						anotherNumber := DoRandom(110) + 20;	{to appear.  What platform, what side.}						if (facing = 0) then							begin								if aNumber = 0 then									begin										dest := eggRects;										anotherNumber := anotherNumber - (dest.right - dest.left);										OffsetRect(dest, -dest.left, -dest.bottom);										OffsetRect(dest, tombRects[3].right - anotherNumber, tombRects[3].top);									end								else									begin										dest := eggRects;										anotherNumber := anotherNumber - (dest.right - dest.left);										OffsetRect(dest, -dest.left, -dest.bottom);										OffsetRect(dest, tombRects[1].right - anotherNumber, tombRects[1].top);									end;							end						else							begin								if aNumber = 0 then									begin										dest := eggRects;										OffsetRect(dest, -dest.left, -dest.bottom);										OffsetRect(dest, tombRects[4].left + anotherNumber, tombRects[4].top);									end								else									begin										dest := eggRects;										OffsetRect(dest, -dest.left, -dest.bottom);										OffsetRect(dest, tombRects[2].left + anotherNumber, tombRects[2].top);									end;							end;						oldDest := dest;					end;		end;{--------------------}		procedure SetUpNonEggEnemies;			var				index: Integer;		begin			{a normal 'non-egg' wave}			totalToKill := levelOn div 5 + 4;			numberOfEnemies := levelOn div 5 + 1;			if (numberOfEnemies > maxEnemies) then				numberOfEnemies := maxEnemies;			for index := 1 to numberOfEnemies do				with theEnemies[index] do					begin						mode := DoRandom(kInitEnemyModeRange) + kInitEnemyModeMinumum;						DoEnemyPlacement(index);					end;		end;{--------------------}	begin		if (score > 0) then						{Compute the time bonus (if any) to the score.	}			aNumber := 2000 - gameCycle		{If they cleared it in less than 2000 cycles		}		else			aNumber := 0;		if (aNumber < 0) then					{But don't SUBTRACT from their score, even	}			aNumber := 0;									{if they took forever.  Just add zero.}		score := score + aNumber;				{Add it...												}		ShowScore;		CheckExtraMortal;		oldScore := Score;							{Keep a hold on this score.				}		levelOn := levelOn + 1;		ShowLevel;		if (levelOn = 3) then			stonesSliding := TRUE		else			stonesSliding := FALSE;		with theEye do			begin				otherMode := 0;				mode := (levelOn * 10) - 1500;				if (mode > -100) then					mode := -100;				dest := eyeRects[4];				CenterZeroRect(dest);				if (DoRandom(2) = 0) then					OffsetRect(dest, 320, upperEyeHeight)				else					OffsetRect(dest, 320, lowerEyeHeight);				oldDest := dest;			end;		beastsActive := 0;		beastsKilled := 0;		if ((levelOn div 5) = (levelOn / 5)) then			SetUpEggEnemies		else			SetUpNonEggEnemies;		for index := 1 to numberOfEnemies do			with theEnemies[index] do				begin					state := FALSE;					aNumber := DoRandom(levelOn);	{What type of sphinx?  O, 1 or 2?  Well, on level 1,}					if (aNumber > 20) then				{there is a 0% chance that a random # between 0 &}						otherMode := 2							{0 will be greater than 20...so, no tough sphinx.}					else													{But on level 30, aNumber will be a random number}						begin												{between 0 and 29.  That gives us almost a 33%}							if (aNumber > 5) then		{chance that it will be a sphinx 2, if not a sphinx 2,}								otherMode := 1					{(not >20) then a good 50% chance that aNumber>10}							else											{(11 to 20) and thus a sphinx 1.  Note: there is}								otherMode := 0;					{ALWAYS a CHANCE of the easiest sphinx 0, but it}						end;												{gets increasingly unlikely as the player goes on.}					vertVel := 0;					horiVel := 0;				end;		with theHand do			begin				dest := handRects[0];				OffsetRect(dest, -dest.left, -dest.top);				OffsetRect(dest, handLeft, handBottom);				oldDest := dest;				state := FALSE;				onward := FALSE;				mode := 0;			end;		growRate := levelOn div 3 + 1;		if (growRate > 8) then			growRate := 8;		numberOfStones := 2;		startStone := 0;		if (levelOn < 3) then			tombRects[0] := tombRects[-1]		else			tombRects[0] := tombRects[-2];		if (levelOn = 3) then			begin				tombRects[5] := tombRects[-4];				numberOfStones := numberOfStones + 2;			end		else			tombRects[5] := tombRects[-3];		if (((levelOn + 4) / 5) = ((levelOn + 4) div 5)) then			numberOfStones := numberOfStones + 3;		if ((levelOn / 5) = (levelOn div 5)) then			numberOfStones := numberOfStones + 3;		if (((levelOn + 3) / 5) = ((levelOn + 3) div 5)) then			numberOfStones := numberOfStones + 2;		if (((levelOn + 2) / 5) = ((levelOn + 2) div 5)) then			numberOfStones := numberOfStones + 2;		RedoTheBackground;		gameCycle := 0;		FlushEvents(everyEvent, 0);	end;{=================================}	procedure EnterANewMortal;		var			halfHeight: Integer;	begin		with thePlayer do			begin				facing := 0;				mode := 0;				horiVel := 0;				vertVel := 0;				dest := playerRects[facing, mode];				CenterZeroRect(dest);				halfHeight := (dest.bottom - dest.top) div 2;				OffSetRect(dest, 320, 425 - halfHeight);				oldDest := dest;				if (theEye.mode > 0) then					theEye.mode := 272;				state := FALSE;			end;		keyStillDown := FALSE;		playing := TRUE;		pausing := FALSE;		deadAndGone := FALSE;		AnimateTheAnk;	end;{===================================}	procedure DoEnd;		var			index: Integer;			dummyLong: LongInt;			tempRect: Rect;	begin		DoTheSound('music.snd', highPriority);					{Play the theme song, but wait for it to finish	}		playing := FALSE;		pausing := FALSE;		RedoTheBackground;		ShowScore;		tempRect := gameoverRects;		CenterZeroRect(tempRect);		OffsetRect(tempRect, 320, 120);		for index := 1 to 5 do			begin				CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, mainWndo^.portBits, gameoverRects, gameoverRects, tempRect);				Delay(4, dummyLong);				CopyMask(BitMapPtr(objectCPtr^.portPixMap^)^, offMaskMap, mainWndo^.portBits, gameoverRects, gameoverRects, tempRect);				Delay(4, dummyLong);			end;		with theEye do			begin				dest := eyeRects[4];				CenterZeroRect(dest);				OffsetRect(dest, 320, upperEyeHeight);				oldDest := dest;			end;		repeat		until (soundPriority = noSound);		InitCursor;		FinalScore;		RedoTheBackground;		RedrawHiScores;		EnableItem(GetMenu(mGame), iBegin);		DisableItem(GetMenu(mGame), iPause);		DisableItem(GetMenu(mGame), iEnd);		DrawMenuBar;					{Draw the menu bar}	end;{=================================}	procedure ExitAMortal;		var			aNumber: Integer;	begin		mortals := mortals - 1;		ShowMortals;		UnionRect(thePlayer.oldDest, thePlayer.dest, thePlayer.wholeRect);		CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, mainWndo^.portBits, thePlayer.wholeRect, thePlayer.wholeRect, srcCopy, playRgn);		if (mortals <= 0) then							{Game over, dude}			begin				DoEnd;			end		else			begin				EnterANewMortal;			end;	end;{=================================}	procedure SlideTheStones;		var			leftExposed, rightExposed: Rect;	begin		leftExposed := tombRects[6];		OffsetRect(tombRects[6], -1, 0);		leftExposed.left := tombRects[6].right;		rightExposed := tombRects[5];		OffsetRect(tombRects[5], 1, 0);		rightExposed.right := tombRects[5].left;		CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, leftExposed, leftExposed, srcCopy, nil);		CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, rightExposed, rightExposed, srcCopy, nil);		CopyBits(BitMapPtr(objectCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, longStoneSrc, tombRects[6], srcCopy, nil);		CopyBits(BitMapPtr(objectCPtr^.portPixMap^)^, BitMapPtr(loadCPtr^.portPixMap^)^, longStoneSrc, tombRects[5], srcCopy, nil);		leftExposed.left := 0;		rightExposed.right := 640;		CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, mainWndo^.portBits, leftExposed, leftExposed, srcCopy, playRgn);		CopyBits(BitMapPtr(loadCPtr^.portPixMap^)^, mainWndo^.portBits, rightExposed, rightExposed, srcCopy, playRgn);		if (tombRects[6].right < 0) then			begin				tombRects[5] := tombRects[-3];				tombRects[6] := tombRects[-5];				numberOfStones := numberOfStones - 2;				stonesSliding := FALSE;			end;	end;{=================================}end.