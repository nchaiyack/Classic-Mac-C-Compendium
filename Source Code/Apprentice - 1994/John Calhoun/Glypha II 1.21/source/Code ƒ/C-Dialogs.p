unit Dialogs;interface	uses		Palettes, Sound, Globals;	procedure ConfigureGame;	procedure ControlDialog (var keyboardControl: Boolean);	procedure WhosHiScore (var theName: Str255);	function YesNoAlert (whatGives: Integer): Boolean;implementation	var		GetSelection: DialogPtr;             {Name of dialog}		tempRect: Rect;                      {Temporary tectangle}		DType: Integer;                      {Type of dialog item}		Index: Integer;                      {For looping}		DItem: Handle;                       {Handle to the dialog item}		CItem, CTempItem: controlhandle;     {Control handle}		sTemp: Str255;                       {Get text entered, temp holding}		itemHit: Integer;                    {Get selection}		temp: Integer;                       {Get selection, temp holding}		ThisEditText: TEHandle;              {Handle to get the Dialogs TE record}		TheDialogPtr: DialogPeek;            {Pointer to Dialogs definition record, contains the TE record}		ExitDialog, keepIt: boolean;{=================================}	procedure ConfigureGame;		const			okayButt = 1;			cancelButt = 2;			soundOnRadio = 3;			soundOffRadio = 4;			fastRadio = 5;			slowRadio = 6;			levelEdit = 7;			userBox1 = 11;			userBox2 = 12;			userBox3 = 13;		var			soundCopy: Boolean;			speedCopy, levelCopy, Index, tempVolume: Integer;			theValue: Integer;			nTemp: LongInt;			dummyInt: Integer;			dialHandle: DialogTHndl;			dialRect: Rect;{---------------}		procedure Refresh_Dialog;			{Refresh the dialogs non-controls	}		begin			PenNormal;			GetDItem(GetSelection, userBox1, DType, DItem, tempRect);			FillRect(tempRect, black);			GetDItem(GetSelection, userBox2, DType, DItem, tempRect);			FillRect(tempRect, black);			GetDItem(GetSelection, userBox3, DType, DItem, tempRect);			FillRect(tempRect, black);			GetDItem(GetSelection, okayButt, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1);		end;{---------------}	begin		levelCopy := levelStart;		soundCopy := soundOn;		speedCopy := gameSpeed;		dialHandle := DialogTHndl(Get1Resource('DLOG', configGameDialID));		if (dialHandle <> nil) then			begin				HNoPurge(Handle(dialHandle));				dialRect := dialHandle^^.boundsRect;				OffsetRect(dialRect, -dialRect.left, -dialRect.top);				dummyInt := (screenBits.bounds.right - dialRect.right) div 2;				OffsetRect(dialRect, dummyInt, 0);				dummyInt := (screenBits.bounds.bottom - dialRect.bottom) div 3;				OffsetRect(dialRect, 0, dummyInt);				dialHandle^^.boundsRect := dialRect;				HPurge(Handle(dialHandle));			end;		GetSelection := GetNewDialog(configGameDialID, nil, Pointer(-1));		ShowWindow(GrafPtr(GetSelection));		SelectWindow(GrafPtr(GetSelection));						{Lets see it}		SetPort(GrafPtr(GetSelection));		if (soundOn) then			GetDItem(GetSelection, soundOnRadio, DType, DItem, tempRect)		else			GetDItem(GetSelection, soundOffRadio, DType, DItem, tempRect);		CItem := Pointer(DItem);		SetCtlValue(CItem, 1);		GetSoundVol(tempVolume);		if ((inhibitSound) or (tempVolume = 0)) then			begin				GetDItem(GetSelection, soundOnRadio, DType, DItem, tempRect);				HiliteControl(Pointer(DItem), 255);				GetDItem(GetSelection, soundOffRadio, DType, DItem, tempRect);				HiliteControl(Pointer(DItem), 255);			end;		if (speedCopy = 3) then			GetDItem(GetSelection, fastRadio, DType, DItem, tempRect)		else			GetDItem(GetSelection, slowRadio, DType, DItem, tempRect);		SetCtlValue(Pointer(DItem), 1);			{Select to slower}		GetDItem(GetSelection, levelEdit, DType, DItem, tempRect);		NumToString(levelCopy, sTemp);		SetIText(DItem, sTemp);		SelIText(GetSelection, levelEdit, 0, 2);		InitCursor;		Refresh_Dialog;		ExitDialog := FALSE;					{Do not exit dialog handle loop yet	}		repeat												{Start of dialog handle loop				}			ModalDialog(nil, itemHit);	{Wait until an item is hit					}			GetDItem(GetSelection, itemHit, DType, DItem, tempRect);	{Get item information	}			CItem := Pointer(DItem);		{Get the control handle							}			if (ItemHit = okayButt) then	{Handle the Button being pressed					}				begin					GetDItem(GetSelection, levelEdit, DType, DItem, tempRect); {Get the item handle}					GetIText(DItem, sTemp);					StringToNum(sTemp, nTemp);					levelCopy := LoWord(nTemp);					if ((levelCopy < 1) or (levelCopy > 99)) then						begin							GetDItem(GetSelection, levelEdit, DType, DItem, tempRect);							NumToString(levelCopy, sTemp);							SetIText(DItem, sTemp);							levelCopy := levelStart;							Refresh_Dialog;						end					else						begin							levelStart := levelCopy;							soundOn := soundCopy;							gameSpeed := speedCopy;							ExitDialog := TRUE;						end;				end;			if (ItemHit = cancelButt) then				ExitDialog := TRUE;			if (itemHit = soundOnRadio) then				begin					GetDItem(GetSelection, soundOffRadio, DType, DItem, tempRect);					SetCtlValue(Pointer(DItem), 0);					GetDItem(GetSelection, soundOnRadio, DType, DItem, tempRect);					SetCtlValue(Pointer(DItem), 1);					soundCopy := TRUE;				end;			if (itemHit = soundOffRadio) then				begin					GetDItem(GetSelection, soundOnRadio, DType, DItem, tempRect);					SetCtlValue(Pointer(DItem), 0);					GetDItem(GetSelection, soundOffRadio, DType, DItem, tempRect);					SetCtlValue(Pointer(DItem), 1);					soundCopy := FALSE;				end;			if (itemHit = slowRadio) then				begin					GetDItem(GetSelection, fastRadio, DType, DItem, tempRect);					SetCtlValue(Pointer(DItem), 0);					GetDItem(GetSelection, slowRadio, DType, DItem, tempRect);					SetCtlValue(Pointer(DItem), 1);					speedCopy := 4;				end;			if (itemHit = fastRadio) then				begin					GetDItem(GetSelection, slowRadio, DType, DItem, tempRect);					SetCtlValue(Pointer(DItem), 0);					GetDItem(GetSelection, fastRadio, DType, DItem, tempRect);					SetCtlValue(Pointer(DItem), 1);					speedCopy := 3;				end;		until ExitDialog;		DisposDialog(GetSelection);		CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, mainWndo^.portBits, wholeArea, wholeArea, srcCopy, mainWndo^.visRgn);	end;{=================================}	function MyFilter (theDialog: DialogPtr; var theEvent: EventRecord; var itemHit: integer): boolean;		var			MyPt: Point;	begin		MyFilter := FALSE;		if (theEvent.what = MouseDown) then			begin				MyPt := theEvent.where;				with theDialog^.portBits.bounds do					begin						myPt.h := myPt.h + left;						myPt.v := myPt.v + top;					end;			end;	end;{=================================}	procedure ControlDialog;		const			okayButt = 1;			cancelButt = 2;			keyRadio = 3;			mouseRadio = 4;			userBox1 = 15;			userBox2 = 16;			userBox3 = 17;		var			Index: Integer;			dummyInt: Integer;			dialHandle: DialogTHndl;			dialRect: Rect;		procedure Refresh_Dialog;			var				rTempRect: Rect;		begin			PenNormal;			GetDItem(GetSelection, userBox1, DType, DItem, tempRect);			FrameRect(tempRect);			GetDItem(GetSelection, userBox2, DType, DItem, tempRect);			FrameRect(tempRect);			GetDItem(GetSelection, userBox3, DType, DItem, tempRect);			FillRect(tempRect, black);			GetDItem(GetSelection, okayButt, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1);		end;	begin		dialHandle := DialogTHndl(Get1Resource('DLOG', controlDialID));		if (dialHandle <> nil) then			begin				HNoPurge(Handle(dialHandle));				dialRect := dialHandle^^.boundsRect;				OffsetRect(dialRect, -dialRect.left, -dialRect.top);				dummyInt := (screenBits.bounds.right - dialRect.right) div 2;				OffsetRect(dialRect, dummyInt, 0);				dummyInt := (screenBits.bounds.bottom - dialRect.bottom) div 3;				OffsetRect(dialRect, 0, dummyInt);				dialHandle^^.boundsRect := dialRect;				HPurge(Handle(dialHandle));			end;		GetSelection := GetNewDialog(controlDialID, nil, Pointer(-1));		ShowWindow(GetSelection);		SelectWindow(GetSelection);		SetPort(GrafPtr(GetSelection));		if (keyboardControl) then			GetDItem(GetSelection, keyRadio, DType, DItem, tempRect)		else			GetDItem(GetSelection, mouseRadio, DType, DItem, tempRect);		CItem := Pointer(DItem);		SetCtlValue(CItem, 1);		InitCursor;		Refresh_Dialog;		ExitDialog := FALSE;		repeat			ModalDialog(nil, itemHit);			GetDItem(GetSelection, itemHit, DType, DItem, tempRect);			CItem := Pointer(DItem);			if (ItemHit = okayButt) then				begin					keepIt := TRUE;					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit = cancelButt) then				begin					keepIt := FALSE;					ExitDialog := TRUE;					Refresh_Dialog;				end;			if (ItemHit = keyRadio) or (ItemHit = mouseRadio) then				begin					for Index := keyRadio to mouseRadio do						begin							GetDItem(GetSelection, Index, DType, DItem, tempRect);							CTempItem := Pointer(DItem);							SetCtlValue(CTempItem, 0);						end;					SetCtlValue(CItem, 1);				end;		until ExitDialog;		Index := keyRadio;		repeat			GetDItem(GetSelection, Index, DType, DItem, tempRect);			CItem := Pointer(DItem);			temp := GetCtlValue(CItem);			Index := Index + 1;		until (temp <> 0) or (Index > mouseRadio);		temp := Index - keyRadio + 1;		if (keepIt) then			begin				if (temp = 3) then					keyboardControl := FALSE				else					keyboardControl := TRUE;			end;		DisposDialog(GetSelection);		CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, mainWndo^.portBits, wholeArea, wholeArea, srcCopy, mainWndo^.visRgn);	end;{=================================}	procedure WhosHiScore;		const			okayButt = 1;			nameEdit = 2;		var			excessSpace: Integer;			dotFiller, space: Str255;			dummyInt: Integer;			dialHandle: DialogTHndl;			dialRect: Rect;{-------------------------}		procedure Refresh_Dialog;	{This draws the rounded-rectangular}		begin			SetPort(GetSelection);			GetDItem(GetSelection, okayButt, DType, DItem, tempRect);			PenSize(3, 3);			InsetRect(tempRect, -4, -4);			FrameRoundRect(tempRect, 16, 16);			PenSize(1, 1);		end;{-------------------------}	begin		dialHandle := DialogTHndl(Get1Resource('DLOG', hiNameDialID));		if (dialHandle <> nil) then			begin				HNoPurge(Handle(dialHandle));				dialRect := dialHandle^^.boundsRect;				OffsetRect(dialRect, -dialRect.left, -dialRect.top);				dummyInt := (screenBits.bounds.right - dialRect.right) div 2;				OffsetRect(dialRect, dummyInt, 0);				dummyInt := (screenBits.bounds.bottom - dialRect.bottom) div 3;				OffsetRect(dialRect, 0, dummyInt);				dialHandle^^.boundsRect := dialRect;				HPurge(Handle(dialHandle));			end;		GetSelection := GetNewDialog(hiNameDialID, nil, Pointer(-1));{Bring in the dialog resource}		ShowWindow(GetSelection);		SelectWindow(GetSelection);								{Lets see it}		SetPort(GrafPtr(GetSelection));										{Perpare to add conditional text}		GetDItem(GetSelection, nameEdit, DType, DItem, tempRect);		SetIText(DItem, theName);									{Set the default text}		SelIText(GetSelection, nameEdit, 0, 15);{Select the text}		ExitDialog := FALSE;											{Don't exit dialog loop yet}		Refresh_Dialog;		repeat																		{Start of dialog loop}			ModalDialog(nil, itemHit);							{Wait until item is hit}			GetDItem(GetSelection, itemHit, DType, DItem, tempRect); {Get item information}			CItem := Pointer(DItem);								{Get the control handle}			if (ItemHit = okayButt) then							{Handle the Button pressed}				begin					GetDItem(GetSelection, nameEdit, DType, DItem, tempRect); {Get the item handle}					GetIText(DItem, sTemp);							{Get the text entered}					if (LENGTH(sTemp) > 15) then				{Make sure it's less than 15 characters}						theName := COPY(sTemp, 1, 15)			{Just clip the first 15 if it is too long}					else						begin							if (LENGTH(sTemp) < 15) then								begin									space := '               ';									excessSpace := 15 - LENGTH(sTemp);									dotFiller := COPY(space, 1, excessSpace);									sTemp := CONCAT(sTemp, dotfiller);								end;							theName := sTemp;							{Otherwise, take it as is}						end;					ExitDialog := TRUE;								{Exit the dialog when this selection is made}				end;												{End for this item selected}		until ExitDialog;										{Handle dialog items until exit selected}		DisposDialog(GetSelection);						{Flush the dialog out of memory}	end;														{End of procedure}{=================================}	function YesNoAlert;		var			dummyInt, goForIt: Integer;			line1: Str255;			alertHandle: AlertTHndl;			alertRect: Rect;	begin		YesNoAlert := FALSE;		InitCursor;		if (whatGives > 0) then			GetIndString(line1, yesNoStrIDs, whatGives)		else			Exit(YesNoAlert);		ParamText(line1, '', '', '');		alertHandle := AlertTHndl(Get1Resource('ALRT', alertID));		if (alertHandle <> nil) then			begin				HNoPurge(Handle(alertHandle));				alertRect := alertHandle^^.boundsRect;				OffsetRect(alertRect, -alertRect.left, -alertRect.top);				dummyInt := (screenBits.bounds.right - alertRect.right) div 2;				OffsetRect(alertRect, dummyInt, 0);				dummyInt := (screenBits.bounds.bottom - alertRect.bottom) div 3;				OffsetRect(alertRect, 0, dummyInt);				alertHandle^^.boundsRect := alertRect;				HPurge(Handle(alertHandle));			end;		goForIt := Alert(yesNoAlertID, nil);		if (goForIt = 1) then			YesNoAlert := TRUE;		CopyBits(BitMapPtr(virginCPtr^.portPixMap^)^, mainWndo^.portBits, wholeArea, wholeArea, srcCopy, mainWndo^.visRgn);	end;{=================================}end.