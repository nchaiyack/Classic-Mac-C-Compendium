unit InitializeAll;interface	uses		Sound, GameUtilities, GliderMain;	procedure DoFast;	procedure Init_My_Menus;	function NewBitMap (var theBitMap: BitMap; theRect: Rect): ptr;	procedure InitAllRooms;	procedure InitAllVariables (prefs: Str255);	var		AppleMenu: MenuHandle;			{Used to handle DAs, needed for later use}implementation{==============================================}	procedure DoFast;	begin		advanceRate := 1;		scoresChanged := TRUE;		gravity := gravityFast;					{Use the global const gravityFast for the rate	}		ductGravity := ceilingFast;				{of descent (for copters and gliders).  The		}		ventLift := floorFast;					{other constants here work in the same way.	}		if (gliderCraft) then					{The glider/dart's thrust of course depends	}			begin									{not only on the speed of the game, but also on}				thrust := gliderForwardFast;		{the type of craft.  Recall in the docs that the	}				stall := gliderBackwardFast;		{glider has a 2:1 glide ratio both forward and	}			end										{backward while the dart has a 4:1 forward	}		else										{but a 1:1 backward.  Look at the global con-	}			begin									{stants to confirm this.  The rooms were		}				thrust := dartForwardFast;			{designed for the glider's ratio, but the dart	}				stall := dartBackwardFast;			{just adds a little variety to the game.			}			end;	end;{=============================================}	procedure Init_My_Menus;		const			Menu1 = 201;						{Menu resource ID for the Apple menu	}			Menu2 = 202;						{Menu resource ID for the Game menu	}			Menu3 = 203;						{Menu resource ID for the Options menu}		var			tempMenu: MenuHandle;			{Throw away all other menu handles	}	begin		ClearMenuBar;						{Clear any old menu bars				}		tempMenu := GetMenu(Menu1);	{Get the menu from the resource file		}		AddResMenu(tempMenu, 'DRVR');	{Add in DAs								}		InsertMenu(tempMenu, 0);			{Insert this menu into the menu bar		}		AppleMenu := tempMenu;			{Save this menu handle for later use	}		tempMenu := GetMenu(Menu2);	{Get the menu from the resource file		}		InsertMenu(tempMenu, 0);			{Insert this menu into the menu bar		}		tempMenu := GetMenu(Menu3);	{Get the menu from the resource file		}		InsertMenu(tempMenu, 0);			{Insert this menu into the menu bar		}		DrawMenuBar;						{Draw the menu bar to reflect changes	}	end;{=============================================}	function NewBitMap;				{I pulled this routine stright from the pages of MacTutor	}	begin								{Magazine.  I suggest you just grab the whole thing from	}		with theBitMap, theRect do	{here and pop it right into any program where you need	}			begin							{off-screen bitmapping.  Note how it is called below.		}				rowBytes := ((right - left + 15) div 16) * 2;		{calculates number of row bytes	}				baseAddr := NewPtr(rowBytes * (bottom - top));	{defines base address for bitmap}				bounds := theRect;										{define the .bounds field of map	}				if (MemError <> noErr) then							{do we have enough memory?	}					begin						SysBeep(1);				{Let's really yell at them.  Upgrade!  Upgrade me!			}						SysBeep(1);						NewBitMap := nil		{Set that pointer to zero-land.	}					end				else					NewBitMap := baseAddr;	{So, we have enough memory!	}			end;	end;{=============================================}	procedure InitAllRooms;	begin{Here is the rather boring and tedious part.  This array holds all the data for each room.		}{It's fairly encrypted (unintentionally), but I'll try to give you the low-down.  Note that		}{levelArray is a 3-dimensional array.  Okay.  Anyway, the second dimension of the array		}{is only a little bit more complex.  The "zero-eth" cell of the 2nd-dimen. specifies the			}{number of "objects" in the room.  It acts as a sort of header value to tell SetupTheFurniture	}{ how many times to loop through.}		levelArray[1, 0, 1] := 4;		{Here's data for room #1.  Note here that		}		levelArray[1, 1, 1] := 4;		{will be 4 objects in this room. ([1,0,1] := 4)	}		levelArray[1, 1, 2] := 15;		{Now, after the "zero-eth" cell, the following	}		levelArray[1, 1, 3] := 200;	{cells in the 2nd-dim. specify what kind of		}		levelArray[1, 2, 1] := 2;		{object.  The 2nd object in this room happens	}		levelArray[1, 2, 2] := 112;	{to be a floor vent.  How do I know?  Because	}		levelArray[1, 2, 3] := 20;		{levelArray[1,2,1] := 2, and 2=floorvent.		}		levelArray[1, 3, 1] := 10;		{for a complete table of these "codes" look at	}		levelArray[1, 3, 2] := 200;	{SetUpTheFurniture; it is essentially one big	}		levelArray[1, 3, 3] := 140;	{case statement that extracts all it's info		}		levelArray[1, 3, 4] := 350;	{from this array.  Well, let's look at the floor	}		levelArray[1, 4, 1] := 2;		{vent [2, 1, 1] := 2 in the next room for a		}		levelArray[1, 4, 2] := 460;	{further example of what all is in this array.	}		levelArray[1, 4, 3] := 20;		levelArray[2, 0, 1] := 4;		{Here we are with room 2's data.  Note here	}		levelArray[2, 1, 1] := 2;		{object 1 is a floor vent, but 2 more lines of	}		levelArray[2, 1, 2] := 250;	{data follow for the floor vent (namely, they	}		levelArray[2, 1, 3] := 20;		{are [2, 1, 2 ]:=250 & [2, 1, 3 ]:=20).  Well	}		levelArray[2, 2, 1] := 10;		{for a floor vent, the 2nd cell in the 3rd dim.	}		levelArray[2, 2, 2] := 61;		{specifies the horizontal position on the floor	}		levelArray[2, 2, 3] := 210;	{for this floor vent (all have the same vertical}		levelArray[2, 2, 4] := 201;	{position.  The 3rd cell in the 3rd dim. specif-	}		levelArray[2, 3, 1] := 10;		{ies how many pixels down from the top of the	}		levelArray[2, 3, 2] := 301;	{screen the air is to terminate.  20 puts this	}		levelArray[2, 3, 3] := 180;	{vent's column of air right up to the ceiling.	}		levelArray[2, 3, 4] := 401;	{Some vents (namely those under shelves &	}		levelArray[2, 4, 1] := 2;		{tables) nay have shorter columns of air.		}		levelArray[2, 4, 2] := 460;		levelArray[2, 4, 3] := 20;		levelArray[3, 0, 1] := 5;		{Well, that should help sort out this array.		}		levelArray[3, 1, 1] := 3;		{All other objects have a similar format.  It	}		levelArray[3, 1, 2] := 170;	{depends of course on how much info is needed	}		levelArray[3, 2, 1] := 2;		{to specify the object.  You can examine the	}		levelArray[3, 2, 2] := 20;		{SetupTheFurniture procedure to decipher the	}		levelArray[3, 2, 3] := 20;		{rest.  Good luck!									}		levelArray[3, 3, 1] := 2;		levelArray[3, 3, 2] := 170;		levelArray[3, 3, 3] := 20;		levelArray[3, 4, 1] := 10;		levelArray[3, 4, 2] := 300;		levelArray[3, 4, 3] := 130;		levelArray[3, 4, 4] := 450;		levelArray[3, 5, 1] := 2;		levelArray[3, 5, 2] := 460;		levelArray[3, 5, 3] := 20;		levelArray[4, 0, 1] := 4;		levelArray[4, 1, 1] := 2;		levelArray[4, 1, 2] := 460;		levelArray[4, 1, 3] := 20;		levelArray[4, 2, 1] := 2;		levelArray[4, 2, 2] := 80;		levelArray[4, 2, 3] := 20;		levelArray[4, 3, 1] := 10;		levelArray[4, 3, 2] := 237;		levelArray[4, 3, 3] := 210;		levelArray[4, 3, 4] := 329;		levelArray[4, 4, 1] := 10;		levelArray[4, 4, 2] := 298;		levelArray[4, 4, 3] := 130;		levelArray[4, 4, 4] := 468;		levelArray[5, 0, 1] := 5;		levelArray[5, 1, 1] := 2;		levelArray[5, 1, 2] := 460;		levelArray[5, 1, 3] := 20;		levelArray[5, 2, 1] := 10;		levelArray[5, 2, 2] := 202;		levelArray[5, 2, 3] := 140;		levelArray[5, 2, 4] := 280;		levelArray[5, 3, 1] := 2;		levelArray[5, 3, 2] := 130;		levelArray[5, 3, 3] := 20;		levelArray[5, 4, 1] := 10;		levelArray[5, 4, 2] := 390;		levelArray[5, 4, 3] := 150;		levelArray[5, 4, 4] := 448;		levelArray[5, 5, 1] := 6;		levelArray[5, 5, 2] := 420;		levelArray[5, 5, 3] := 150;		levelArray[6, 0, 1] := 6;		levelArray[6, 1, 1] := 4;		levelArray[6, 1, 2] := 15;		levelArray[6, 1, 3] := 200;		levelArray[6, 2, 1] := 2;		levelArray[6, 2, 2] := 70;		levelArray[6, 2, 3] := 40;		levelArray[6, 3, 1] := 9;		levelArray[6, 3, 2] := 148;		levelArray[6, 3, 3] := 210;		levelArray[6, 3, 4] := 300;		levelArray[6, 4, 1] := 9;		levelArray[6, 4, 2] := 210;		levelArray[6, 4, 3] := 100;		levelArray[6, 4, 4] := 350;		levelArray[6, 5, 1] := 2;		levelArray[6, 5, 2] := 380;		levelArray[6, 5, 3] := 20;		levelArray[6, 6, 1] := 1;		levelArray[6, 6, 2] := 30;		levelArray[6, 6, 3] := 200;		levelArray[7, 0, 1] := 5;		levelArray[7, 1, 1] := 3;		levelArray[7, 1, 2] := 200;		levelArray[7, 2, 1] := 2;		levelArray[7, 2, 2] := 20;		levelArray[7, 2, 3] := 140;		levelArray[7, 3, 1] := 2;		levelArray[7, 3, 2] := 200;		levelArray[7, 3, 3] := 20;		levelArray[7, 4, 1] := 9;		levelArray[7, 4, 2] := 70;		levelArray[7, 4, 3] := 100;		levelArray[7, 4, 4] := 180;		levelArray[7, 5, 1] := 9;		levelArray[7, 5, 2] := 270;		levelArray[7, 5, 3] := 140;		levelArray[7, 5, 4] := 380;		levelArray[8, 0, 1] := 7;		levelArray[8, 1, 1] := 2;		levelArray[8, 1, 2] := 22;		levelArray[8, 1, 3] := 20;		levelArray[8, 2, 1] := 9;		levelArray[8, 2, 2] := 100;		levelArray[8, 2, 3] := 135;		levelArray[8, 2, 4] := 208;		levelArray[8, 3, 1] := 9;		levelArray[8, 3, 2] := 280;		levelArray[8, 3, 3] := 150;		levelArray[8, 3, 4] := 490;		levelArray[8, 4, 1] := 5;		levelArray[8, 4, 2] := 182;		levelArray[8, 4, 3] := 135;		levelArray[8, 5, 1] := 5;		levelArray[8, 5, 2] := 302;		levelArray[8, 5, 3] := 150;		levelArray[8, 6, 1] := 2;		levelArray[8, 6, 2] := 450;		levelArray[8, 6, 3] := 180;		levelArray[8, 7, 1] := 6;		levelArray[8, 7, 2] := 278;		levelArray[8, 7, 3] := 150;		levelArray[9, 0, 1] := 6;		levelArray[9, 1, 1] := 2;		levelArray[9, 1, 2] := 170;		levelArray[9, 1, 3] := 20;		levelArray[9, 2, 1] := 9;		levelArray[9, 2, 2] := 280;		levelArray[9, 2, 3] := 130;		levelArray[9, 2, 4] := 400;		levelArray[9, 3, 1] := 9;		levelArray[9, 3, 2] := 280;		levelArray[9, 3, 3] := 230;		levelArray[9, 3, 4] := 400;		levelArray[9, 4, 1] := 10;		levelArray[9, 4, 2] := 400;		levelArray[9, 4, 3] := 170;		levelArray[9, 4, 4] := 498;		levelArray[9, 5, 1] := 5;		levelArray[9, 5, 2] := 285;		levelArray[9, 5, 3] := 130;		levelArray[9, 6, 1] := 7;		levelArray[9, 6, 2] := 340;		levelArray[9, 6, 3] := 230;		levelArray[10, 0, 1] := 7;		levelArray[10, 1, 1] := 2;		levelArray[10, 1, 2] := 20;		levelArray[10, 1, 3] := 20;		levelArray[10, 2, 1] := 2;		levelArray[10, 2, 2] := 400;		levelArray[10, 2, 3] := 20;		levelArray[10, 3, 1] := 9;		levelArray[10, 3, 2] := 160;		levelArray[10, 3, 3] := 180;		levelArray[10, 3, 4] := 380;		levelArray[10, 4, 1] := 2;		levelArray[10, 4, 2] := 280;		levelArray[10, 4, 3] := 230;		levelArray[10, 5, 1] := 9;		levelArray[10, 5, 2] := 70;		levelArray[10, 5, 3] := 250;		levelArray[10, 5, 4] := 170;		levelArray[10, 6, 1] := 9;		levelArray[10, 6, 2] := 70;		levelArray[10, 6, 3] := 100;		levelArray[10, 6, 4] := 170;		levelArray[10, 7, 1] := 7;		levelArray[10, 7, 2] := 73;		levelArray[10, 7, 3] := 250;		levelArray[11, 0, 1] := 5;		levelArray[11, 1, 1] := 10;		levelArray[11, 1, 2] := 190;		levelArray[11, 1, 3] := 120;		levelArray[11, 1, 4] := 308;		levelArray[11, 2, 1] := 2;		levelArray[11, 2, 2] := 130;		levelArray[11, 2, 3] := 20;		levelArray[11, 3, 1] := 10;		levelArray[11, 3, 2] := 390;		levelArray[11, 3, 3] := 150;		levelArray[11, 3, 4] := 448;		levelArray[11, 4, 1] := 2;		levelArray[11, 4, 2] := 460;		levelArray[11, 4, 3] := 20;		levelArray[11, 5, 1] := 8;		levelArray[11, 5, 2] := 260;		levelArray[11, 5, 3] := 170;		levelArray[12, 0, 1] := 7;		levelArray[12, 1, 1] := 1;		levelArray[12, 1, 2] := 70;		levelArray[12, 1, 3] := 100;		levelArray[12, 2, 1] := 9;		levelArray[12, 2, 2] := 70;		levelArray[12, 2, 3] := 50;		levelArray[12, 2, 4] := 500;		levelArray[12, 3, 1] := 9;		levelArray[12, 3, 2] := 70;		levelArray[12, 3, 3] := 170;		levelArray[12, 3, 4] := 200;		levelArray[12, 4, 1] := 9;		levelArray[12, 4, 2] := 280;		levelArray[12, 4, 3] := 170;		levelArray[12, 4, 4] := 430;		levelArray[12, 5, 1] := 5;		levelArray[12, 5, 2] := 300;		levelArray[12, 5, 3] := 170;		levelArray[12, 6, 1] := 2;		levelArray[12, 6, 2] := 200;		levelArray[12, 6, 3] := 70;		levelArray[12, 7, 1] := 2;		levelArray[12, 7, 2] := 430;		levelArray[12, 7, 3] := 100;		levelArray[13, 0, 1] := 6;		levelArray[13, 1, 1] := 2;		levelArray[13, 1, 2] := 460;		levelArray[13, 1, 3] := 20;		levelArray[13, 2, 1] := 2;		levelArray[13, 2, 2] := 40;		levelArray[13, 2, 3] := 20;		levelArray[13, 3, 1] := 10;		levelArray[13, 3, 2] := 237;		levelArray[13, 3, 3] := 210;		levelArray[13, 3, 4] := 329;		levelArray[13, 4, 1] := 10;		levelArray[13, 4, 2] := 298;		levelArray[13, 4, 3] := 130;		levelArray[13, 4, 4] := 468;		levelArray[13, 5, 1] := 6;		levelArray[13, 5, 2] := 305;		levelArray[13, 5, 3] := 130;		levelArray[13, 6, 1] := 11;		levelArray[13, 6, 2] := 230;		levelArray[13, 6, 3] := 170;		levelArray[14, 0, 1] := 5;		{Note: the dripping ceiling isn't specified here.	}		levelArray[14, 1, 1] := 3;		{The program handles both the dripping ceiling &	}		levelArray[14, 1, 2] := 130;	{the cat seperately.  Also, note that ALL rooms	}		levelArray[14, 2, 1] := 10;	{have copters in them and so they are also dealt	}		levelArray[14, 2, 2] := 202;	{with within the program itself.						}		levelArray[14, 2, 3] := 140;		levelArray[14, 2, 4] := 300;		levelArray[14, 3, 1] := 2;		levelArray[14, 3, 2] := 130;		levelArray[14, 3, 3] := 20;		levelArray[14, 4, 1] := 10;		levelArray[14, 4, 2] := 390;		levelArray[14, 4, 3] := 150;		levelArray[14, 4, 4] := 448;		levelArray[14, 5, 1] := 2;		levelArray[14, 5, 2] := 460;		levelArray[14, 5, 3] := 20;		levelArray[15, 0, 1] := 2;		levelArray[15, 1, 1] := 2;		levelArray[15, 1, 2] := 250;		levelArray[15, 1, 3] := 100;		levelArray[15, 2, 1] := 2;		levelArray[15, 2, 2] := 40;		levelArray[15, 2, 3] := 20;		backgroundArray[1] := 172;	{Here we set up an array to hold the ID		}		backgroundArray[2] := 168;	{numbers of all background PICTs in the	}		backgroundArray[3] := 170;	{resource fork.  In room 6, for example,	}		backgroundArray[4] := 171;	{we use the PICT with ID=68.				}		backgroundArray[5] := 169;	{In part, the backgrounds were chosen at	}		backgroundArray[6] := 168;	{random, but some backgrounds just will	}		backgroundArray[7] := 169;	{not work with the furniture arrangement	}		backgroundArray[8] := 168;	{in the room (a shelf mounted to a window).}		backgroundArray[9] := 169;	{Get ResEdit and look at these PICT's in the}		backgroundArray[10] := 169;	{Glider_3.RSRC portion of this code.		}		backgroundArray[11] := 169;		backgroundArray[12] := 168;		backgroundArray[13] := 171;		backgroundArray[14] := 173;		backgroundArray[15] := 174;	end;{=============================================}	procedure InitAllVariables;		var			tempRect: Rect;			tempChar: Char;			defaultString: Str255;			rawPointer: Ptr;			theSnd: Handle;			tempStringHand: StringHandle;			Pic_Handle: PicHandle;	begin		gliderCraft := TRUE;		DoFast;		levelBegin := defaultRoomBegin;	{Here we set up all other default values 				}		numberBegin := defaultNumber;		gliderNumber := numberBegin;		doneFlag := FALSE;					{Here follows the Boolean vars and initial settings	}		Pausing := FALSE;		Playing := FALSE;		darkOn := FALSE;		soundPlaying := FALSE;		levelOn := 1;							{And which room we begin in (by default)}		chanPtr := nil;		GetPort(oldPort);		if (inhibitSound) then			begin				SetItem(GetMenu(L_Options), C_Sound_On, 'No Sound : need ³ Sys 6.02');				DisableItem(GetMenu(L_Options), C_Sound_On);		{and disable it (changing the name is a public	}			end;		if (gameSpeed = fastSpeed) then			begin				CheckItem(GetMenu(L_Options), C_Fast, TRUE);	{If on, put a checkmark		}				CheckItem(GetMenu(L_Options), C_Slow, FALSE);	{If on, put a checkmark		}			end		else			begin				CheckItem(GetMenu(L_Options), C_Slow, TRUE);	{If on, put a checkmark		}				CheckItem(GetMenu(L_Options), C_Fast, FALSE);	{If on, put a checkmark		}			end;		rawPointer := NewPtr(SizeOf(GrafPort));				{This offscreen bitmap will be for forming	}		loadPort := GrafPtr(rawPointer);						{all the composites before dumping to the	}		OpenPort(loadPort);										{screen.}		SetRect(loadArea, 0, 0, 512, 322);					{Note: here is where we call the above		}		loadBits := NewBitMap(loadMap, loadArea);			{function NewBitMap.  Grab this code for	}		SetPortBits(loadMap);									{your own programs.  See the globals for	}		EraseRect(loadMap.bounds);								{a the variable types.						}		rawPointer := NewPtr(SizeOf(GrafPort));				{Here we keep all the various objects we'll}		objectsPort := GrafPtr(rawPointer);					{need during play.  Note that we load them	}		OpenPort(objectsPort);									{up from the resource fork here as well.	}		SetRect(objectsArea, 0, 0, 512, 320);		objectsBits := NewBitMap(objectsMap, objectsArea);		SetPortBits(objectsMap);		EraseRect(objectsMap.bounds);		SetPort(objectsPort);									{Set the off-screen as the active port!	}		Pic_Handle := GetPicture(200);						{Get objects into memory (PICT ID=200)}		SetRect(tempRect, 0, 0, 512, 320);		if (Pic_Handle <> nil) then							{Only use handle if it is valid				}			begin				ClipRect(tempRect);				HLock(Handle(Pic_Handle));							{Lock the handle before using it			}				tempRect.Right := tempRect.Left + (Pic_Handle^^.picFrame.Right - Pic_Handle^^.picFrame.Left);				tempRect.Bottom := tempRect.Top + (Pic_Handle^^.picFrame.Bottom - Pic_Handle^^.picFrame.Top);				HUnLock(Handle(Pic_Handle));						{Unlock the picture again					}				DrawPicture(Pic_Handle, tempRect);				{Since we SetPort(objectsMap), the		}			end;														{picture is drawn off-screen.				}		SetRect(tempRect, 0, 0, 1023, 1023);				{Widen the clip area again					}		ClipRect(tempRect);										{Set the clip area							}		ReleaseResource(Handle(Pic_Handle));				{This frees up memory since we're done}		rawPointer := NewPtr(SizeOf(GrafPort));			{Here we keep a "virgin" copy of the	}		virginPort := GrafPtr(rawPointer);					{room unspoilt by the animated objects.	}		OpenPort(virginPort);		SetRect(screenArea, 0, 0, 512, 322);		virginBits := NewBitMap(virginMap, screenArea);		SetPortBits(virginMap);		EraseRect(virginMap.bounds);		SetPort(oldPort);		SetRect(playerDropRect, startHori, startVert, startHori, startVert);		SetRect(shadowDropRect, startHori, shadowVert, startHori, shadowVert);		ResizeARect(playerDropRect, 0);		ResizeARect(shadowDropRect, 53);		oldPlayerRect := playerDropRect;		oldShadowRect := shadowDropRect;		SetRect(playArea, 30, 10, 510, 280);{Here follows the MOST tedious part of programming games like this.  The objectsRects	}{array is of primary importance to the drawing routines in the program.  All the objects	}{in all of the rooms is crammed into a single PICT with ID=200 in the resource fork (use	}{ResEdit to look at this mess).  We loaded this PICT into the objectsMap offscreen bitmap,	}{and we now need some bounding rects defined to give CopyBits and CopyMask info as to	}{where in objectsMap these silly drawings are to be found.  Well, objectsRects holds all	}{the info on the rectangular areas where the objects and their masks are to be found.		}{How to get these?  Well once you have your PICT completely drawn with masks in Mac-	}{Paint (or similar "bitmap editor" use Show Mouse Position or a DA that will suffice to	}{give you the pixel coordinates of the left, top, right & bottom sides of the bounding rect.	}{Note: add 1 onto both the bottom and right edges of the rect.  Show Mouse Position (on	}{MacPaint 2.0 anyway) seems to give you the coords for the upper left of each pixel.		}		SetRect(objectsRects[0, 0], 2, 1, 48, 19);				{Glider in forward position}		SetRect(objectsRects[0, 1], 2, 22, 48, 40);				{it's mask}		SetRect(objectsRects[1, 0], 48, 2, 96, 22);			{Glider in backward position}		SetRect(objectsRects[1, 1], 48, 23, 96, 43);				{it's mask}		SetRect(objectsRects[2, 0], 152, 1, 217, 23);		{Dart}		SetRect(objectsRects[2, 1], 152, 24, 217, 46);			{it's mask}		SetRect(objectsRects[3, 0], 389, 77, 405, 101);		{Wall socket}		SetRect(objectsRects[3, 1], 407, 77, 423, 101);			{it's mask}		SetRect(objectsRects[4, 0], 100, 83, 147, 96);		{Floor vent}		SetRect(objectsRects[4, 1], 100, 97, 147, 110);			{it's mask}		SetRect(objectsRects[5, 0], 100, 37, 148, 50);		{Ceiling suction vent}		SetRect(objectsRects[5, 1], 100, 67, 148, 80);			{it's mask}		SetRect(objectsRects[6, 0], 100, 53, 148, 66);		{Ceiling blower}		SetRect(objectsRects[6, 1], 100, 67, 148, 80);			{it's mask}		SetRect(objectsRects[7, 0], 31, 42, 62, 76);			{Candle number 1}		SetRect(objectsRects[7, 1], 32, 78, 62, 112);			{it's mask}		SetRect(objectsRects[8, 0], 2, 55, 29, 83);			{Clock}		SetRect(objectsRects[8, 1], 2, 84, 29, 112);				{it's mask}		SetRect(objectsRects[9, 0], 160, 61, 210, 82);		{Folded paper}		SetRect(objectsRects[9, 1], 160, 83, 210, 104);			{it's mask}		SetRect(objectsRects[10, 0], 425, 49, 440, 73);		{Thermostat}		SetRect(objectsRects[10, 1], 407, 77, 423, 101);		{it's mask}		SetRect(objectsRects[11, 0], 417, 2, 428, 21);		{Shelf bracket}		SetRect(objectsRects[11, 1], 417, 23, 428, 42);			{it's mask}		SetRect(objectsRects[12, 0], 336, 73, 383, 86);		{Table base object}		SetRect(objectsRects[12, 1], 336, 88, 383, 101);		{it's mask}		SetRect(objectsRects[13, 0], 425, 77, 440, 101);	{Light switch}		SetRect(objectsRects[13, 1], 407, 77, 423, 101);		{it's mask}		SetRect(objectsRects[14, 0], 31, 42, 62, 76);		{Candle number 2}		SetRect(objectsRects[14, 1], 66, 78, 97, 112);			{it's mask}		SetRect(objectsRects[15, 0], 220, 1, 253, 36);		{Helicopter 1}		SetRect(objectsRects[15, 1], 220, 36, 253, 71);			{it's mask}		SetRect(objectsRects[16, 0], 250, 1, 283, 36);		{Helicopter 2}		SetRect(objectsRects[16, 1], 336, 221, 369, 256);		{it's mask}		SetRect(objectsRects[17, 0], 269, 1, 302, 36);		{Helicopter 3}		SetRect(objectsRects[17, 1], 269, 36, 302, 71);			{it's mask}		SetRect(objectsRects[18, 0], 289, 1, 322, 36);		{Helicopter 4}		SetRect(objectsRects[18, 1], 336, 258, 369, 293);		{it's mask}		SetRect(objectsRects[19, 0], 318, 1, 351, 36);		{Helicopter 5}		SetRect(objectsRects[19, 1], 318, 36, 351, 71);			{it's mask}		SetRect(objectsRects[20, 0], 348, 1, 381, 36);		{Helicopter 6}		SetRect(objectsRects[20, 1], 336, 258, 369, 293);		{it's mask}		SetRect(objectsRects[21, 0], 367, 1, 400, 36);		{Helicopter 7}		SetRect(objectsRects[21, 1], 367, 36, 400, 71);			{it's mask}		SetRect(objectsRects[22, 0], 387, 1, 420, 36);		{Helicopter 8}		SetRect(objectsRects[22, 1], 336, 221, 369, 256);		{it's mask}		SetRect(objectsRects[23, 0], 221, 75, 245, 88);		{Water drop 1}		SetRect(objectsRects[23, 1], 221, 92, 245, 104);		{it's mask}		SetRect(objectsRects[24, 0], 246, 75, 270, 88);		{Water drop 2}		SetRect(objectsRects[24, 1], 246, 92, 270, 104);		{it's mask}		SetRect(objectsRects[25, 0], 271, 75, 296, 88);		{Water drop 3}		SetRect(objectsRects[25, 1], 271, 92, 296, 104);		{it's mask}		SetRect(objectsRects[26, 0], 297, 75, 322, 88);		{Water drop 4}		SetRect(objectsRects[26, 1], 297, 92, 322, 104);		{it's mask}		SetRect(objectsRects[27, 0], 325, 73, 334, 87);		{Falling water drop}		SetRect(objectsRects[27, 1], 325, 89, 334, 103);		{it's mask}		SetRect(objectsRects[28, 0], 3, 115, 106, 176);		{Cat1}		SetRect(objectsRects[28, 1], 211, 115, 314, 176);		{it's mask}		SetRect(objectsRects[29, 0], 107, 115, 210, 176);	{Cat2}		SetRect(objectsRects[29, 1], 315, 115, 418, 176);		{it's mask}		SetRect(objectsRects[30, 0], 2, 177, 34, 217);		{Cat paw 1}		SetRect(objectsRects[30, 1], 194, 177, 226, 217);		{it's mask}		SetRect(objectsRects[31, 0], 36, 177, 76, 217);		{Cat paw 2}		SetRect(objectsRects[31, 1], 228, 177, 268, 217);		{it's mask}		SetRect(objectsRects[32, 0], 78, 177, 132, 217);	{Cat paw 3}		SetRect(objectsRects[32, 1], 270, 177, 324, 217);		{it's mask}		SetRect(objectsRects[33, 0], 134, 177, 189, 217);	{Cat paw 4}		SetRect(objectsRects[33, 1], 326, 177, 381, 217);		{it's mask}		SetRect(objectsRects[34, 0], 3, 221, 321, 240);			{Banner}		SetRect(objectsRects[34, 1], 3, 241, 321, 260);				{it's mask}		SetRect(objectsRects[35, 0], 422, 124, 461, 143);		{Crunched glider}		SetRect(objectsRects[35, 1], 422, 162, 461, 181);			{it's mask}		SetRect(objectsRects[36, 0], 0, 0, 0, 0);	{unused}		SetRect(objectsRects[36, 1], 0, 0, 0, 0);	{unused}		SetRect(objectsRects[37, 0], 447, 33, 494, 67);			{Burning glider 1}		SetRect(objectsRects[37, 1], 447, 71, 494, 105);			{it's mask}		SetRect(objectsRects[38, 0], 462, 107, 509, 145);		{Burning glider 2}		SetRect(objectsRects[38, 1], 462, 145, 509, 183);			{it's mask}		SetRect(objectsRects[39, 0], 0, 0, 0, 0);	{unused}		SetRect(objectsRects[39, 1], 0, 0, 0, 0);	{unused}		SetRect(objectsRects[40, 0], 0, 0, 0, 0);	{unused}		SetRect(objectsRects[40, 1], 0, 0, 0, 0);	{unused}		SetRect(objectsRects[41, 0], 388, 242, 432, 276);	{Folding plane 1 - no masks	}		SetRect(objectsRects[42, 0], 388, 277, 432, 311);	{Folding plane 2 - we'll get	}		SetRect(objectsRects[43, 0], 433, 207, 477, 241);	{Folding plane 3 - get lazy &	}		SetRect(objectsRects[44, 0], 433, 242, 477, 276);	{Folding plane 4 - do these	on	}		SetRect(objectsRects[45, 0], 433, 277, 477, 311);	{Folding plane 5 - a white		}		SetRect(objectsRects[46, 0], 478, 187, 507, 221);	{Folding plane 6 - background.	}		SetRect(objectsRects[47, 0], 478, 222, 507, 240);	{Folding plane 7}		SetRect(objectsRects[48, 0], 478, 241, 507, 265);	{Folding plane 8}		SetRect(objectsRects[49, 0], 478, 266, 507, 279);	{Folding plane 9}		SetRect(objectsRects[50, 0], 478, 280, 507, 294);	{Folding plane 10}		SetRect(objectsRects[51, 0], 478, 295, 507, 303);	{Folding plane 11}		SetRect(objectsRects[52, 0], 478, 304, 507, 315);	{Folding plane 12}		SetRect(objectsRects[53, 0], 97, 3, 138, 16);		{Glider shadow}		SetRect(objectsRects[53, 1], 97, 3, 138, 16);			{it's mask}		SetRect(objectsRects[54, 0], 154, 48, 216, 58);		{Dart shadow}		SetRect(objectsRects[54, 1], 154, 48, 216, 58);			{it's mask}		SetRect(objectsRects[55, 0], 265, 294, 323, 320);	{Crushed dart}		SetRect(objectsRects[55, 1], 324, 294, 381, 320);		{it's mask}		SetRect(objectsRects[56, 0], 1, 289, 66, 320);		{Burning dart 1}		SetRect(objectsRects[56, 1], 68, 289, 133, 320);		{it's mask}		SetRect(objectsRects[57, 0], 135, 286, 199, 320);	{Burning dart 2}		SetRect(objectsRects[57, 1], 200, 286, 264, 320);		{it's mask}		SetRect(catBodyRect, 283, 165, 386, 226);		{"Special" rectangles.	}		pawRect := objectsRects[30, 0];		OffsetRect(pawRect, 281, -16);		oldPawRect := pawRect;		SetRect(dangerRect, 258, 145, 303, 200);		escapeRect := dangerRect;		InsetRect(escapeRect, 6, 6);		theSnd := GetNamedResource('snd ', 'bonus.snd');		{Finally, we preload all the sounds	}		MoveHHi(theSnd);											{in from the resource fork so that	}		ReleaseResource(theSnd);		theSnd := GetNamedResource('snd ', 'ductsuck.snd');	{we don't have a dreaded pause as	}		MoveHHi(theSnd);											{each sound is needed.					}		ReleaseResource(theSnd);		theSnd := GetNamedResource('snd ', 'ductdump.snd');		MoveHHi(theSnd);		ReleaseResource(theSnd);		theSnd := GetNamedResource('snd ', 'crunch.snd');		MoveHHi(theSnd);		ReleaseResource(theSnd);		theSnd := GetNamedResource('snd ', 'boom.snd');		MoveHHi(theSnd);		ReleaseResource(theSnd);		theSnd := GetNamedResource('snd ', 'drip.snd');		MoveHHi(theSnd);		ReleaseResource(theSnd);		theSnd := GetNamedResource('snd ', 'fold.snd');		MoveHHi(theSnd);		ReleaseResource(theSnd);		theSnd := GetNamedResource('snd ', 'flash.snd');		MoveHHi(theSnd);		ReleaseResource(theSnd);	end;{=============================================}end.