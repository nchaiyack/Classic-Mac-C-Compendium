{**********************************************************************************  Project Name:	DropShell**     File Name:	DSUserProcs.p****   Description:	Specific AppleEvent handlers used by the Dropbox***********************************************************************************                       A U T H O R   I D E N T I T Y***********************************************************************************	Initials	Name**	--------	-----------------------------------------------**	LDR			Leonard Rosenthol***********************************************************************************                      R E V I S I O N   H I S T O R Y***********************************************************************************	  Date		Time	Author	Description**	--------	-----	------	---------------------------------------------**	12/09/91			LDR		Added the new SelectFile & UserGlobal userProcs**								Modified PostFlight to only autoquit on odoc, not pdoc**	11/24/91			LDR		Added the userProcs for pdoc handler**								Added support for a userDataHandle passed odoc/pdoc routines**								We now include the new DSUtils**	10/30/91			LDR		Modified USES clause for new include & ifc'ed ThP**	10/28/91			LDR		Officially renamed DropShell (from QuickShell)**								Added a bunch of comments for clarification**	04/08/91	23:58	LDR		Original Version********************************************************************************}UNIT DSUserProcs;INTERFACE{$IFC THINK_Pascal}	USES		DSGlobals, DSUtils;	{just the DropShell files}{$ELSEC}	USES	{ First load standard interface files}		MemTypes, QuickDraw, 	{ Now include the stuff from OSIntf }		OSIntf, 	{ Now Include the stuff from ToolIntf.p }		ToolIntf, Packages, GestaltEqu, 	{ Then any OTHER Toolbox interfaces... }		Files, Aliases, AppleEvents,	{ And finally any files from DropShell }		DSGlobals, DSUtils;{$ENDC THINK_Pascal}	{---------------------}{Interface Definitions}{---------------------}	PROCEDURE InstallOtherEvents;		PROCEDURE OpenApp;	PROCEDURE QuitApp;		FUNCTION  PreFlightDocs(opening: Boolean; VAR userDataHandle: UNIV Handle): Boolean;	PROCEDURE OpenDoc( myFSSPtr: FSSpecPtr; opening: Boolean; userDataHandle: UNIV Handle );	PROCEDURE PostFlightDocs(opening: Boolean; userDataHandle: UNIV Handle);	PROCEDURE SelectFile;	FUNCTION  InitUserGlobals:Boolean;	PROCEDURE DisposeUserGlobals;	IMPLEMENTATION{$S Main}	{		This routine is called during init time.				It allows you to install more AEVT Handlers beyond the standard four	}	PROCEDURE InstallOtherEvents;	BEGIN	END;		{		This routine is called when an OAPP event is received.				Currently, all it does is set the gOApped flag, so you know that		you were called initally with no docs, and therefore you shouldn't 		quit when done processing any following odocs.	}	PROCEDURE OpenApp;	BEGIN		gOApped := TRUE;	END;		{		This routine is called when an QUIT event is received.				We simply set the global done flag so that the main event loop can		gracefully exit.  We DO NOT call ExitToShell for two reasons:		1) It is a pretty ugly thing to do, but more importantly		2) The Apple event manager will get REAL upset!	}	PROCEDURE QuitApp;	BEGIN		gDone := TRUE;	{All Done!}	END;		{		This routine is the first one called when an ODOC or PDOC event is received.				In this routine you would place code used to setup structures, etc. 		which would be used in a 'for all docs' situation (like "Archive all		dropped files"). 				Obviously, the opening boolean tells you whether you should be opening		or printing these files based on the type of event recieved.				userDataHandle is a handle that you can create & use to store your own		data structs.  This dataHandle will be passed around to the other 		odoc/pdoc routines so that you can get at your data without using		globals - just like the new StandardFile.    The shell knows NOTHING		about this userDataHandle and will do NOTHING to do.  You MUST perform		all allocation, access and deallocation if you use it.			We also return a boolean to tell the caller if you support this type		of event.  By default, our dropboxes don't support the pdoc, so when		opening is FALSE, we return FALSE to let the caller send back the		proper error code to the AEManager.	}	FUNCTION PreFlightDocs(opening: Boolean; VAR userDataHandle: UNIV Handle): Boolean;	BEGIN			PreFlightDocs := opening;	{we support opening, but not printing - see above}	END;		{		This routine is called for each file passed in the ODOC or PDOC event.				In this routine you would place code for processing each file/folder/disk that		was dropped on top of you.	}	PROCEDURE OpenDoc( myFSSPtr: FSSpecPtr; opening: Boolean; userDataHandle: UNIV Handle );	BEGIN	END;		{		This routine is the last routine called as part of an ODOC or PDOC event.				In this routine you would place code to process any structures, etc. 		that you setup in the PreflightDocs routine.		If you created a userDataHandle in the PreFlightDocs routines, this is		the place to dispose of it since the Shell will NOT do it for you!	}	PROCEDURE PostFlightDocs(opening: Boolean; userDataHandle: UNIV Handle);	BEGIN		IF (opening) AND (NOT gOApped) THEN			gDone := TRUE;	{close everything up when sent an original odoc}				{			The reason we do not auto quit is based on a recommendation in the			Apple event Registry which specifically states that you should NOT			quit on a 'pdoc' as the Finder will send you a 'quit' when it is 			ready for you to do so.		}	END;	{		This routine is called when the user chooses "Select File…" from the		File Menu.				Currently it simply calls the new StandardGetFile routine to have the		user select a single file (any type, numTypes = -1) and then calls the		SendODOCToSelf routine in order to process it.  						The reason we send an odoc to ourselves is two fold: 1) it keeps the code		cleaner as all file openings go through the same process, and 2) if events		are ever recordable, the right things happen (this is called Factoring!)		Modification of this routine to only select certain types of files, selection		of multiple files, and/or handling of folder & disk selection is left 		as an exercise to the reader.	}	PROCEDURE SelectFile;	VAR		stdReply: StandardFileReply;		theTypeList: SFTypeList;	BEGIN		StandardGetFile(NIL, -1, theTypeList, stdReply);		IF (stdReply.sfGood) THEN				{user did not cancel}			SendODOCToSelf(stdReply.sfFile);	{so send me an event!}	END;{	This routine is called during the program's initialization and gives you	a chance to allocate or initialize any of your own globals that your	dropbox needs.		You return a boolean value which determines if you were successful.	Returning false will cause DropShell to exit immediately.}FUNCTION InitUserGlobals:Boolean;BEGIN	InitUserGlobals := TRUE;	{nothing to do, it we must be successful!}END;{	This routine is called during the program's cleanup and gives you	a chance to deallocate any of your own globals that you allocated 	in the above routine.}PROCEDURE DisposeUserGlobals;BEGIN	{nothing to do for our sample dropbox}END;	END.