% mrandom.tex 3.1 5/28/93\documentstyle[titlepage,latexinfo]{article}\pagestyle{empty}\begin{document}\begin{center}\vspace{1in}{\largeMassachusetts Institute of Technology\\}77 Massachusetts Avenue \\Cambridge, MA 02139 \\\end{center}\vspace{1in}\begin{center}{\Large\bfmrandom 3.0 User's Manual}\end{center}\vskip .1 in\begin{center}by\end{center}\vskip .1in\begin{center}{\large \em Robert Plotkin}\vskip .5 inDepartment of Electrical Engineering and Computer Science\vskip 3.0 inMay 1993\end{center}\clearpage\pagestyle{headings}\pagenumbering{roman}\tableofcontents\clearpage\listoffigures\clearpage\pagenumbering{arabic}\section{Introduction}The mrandom package contains a library of routines for using randomnumber generators (RNGs) in C in the Unix 4.3bsd environment.  ThisUser's Manual is designed as a guide for programmers who wish to use themrandom package within their own programs.  The current version ofmrandom (version 3.0) is a major rewrite of mrandom version 2.1,released by Clark Thomborson in July 1992 (available via anonymous\code{ftp} from \code{theory.lcs.mit.edu}).  The package now provides:\begin{itemize}\item A standardized interface to many simultaneously-active RNGs,\item A standardized, and unbiased, method for generating randomintegers in the range 0..\code{m}-1,\item A standardized method for generating floating point numbersuniformly distributed in [0.0, 1.0),\item Two standardized methods for generating pseudorandom bitstreams,\item Time-efficient vectorized calls, returning multiple uniformvariates,\item Buffered and unbuffered calls for efficient generation ofpseudorandom generates in both large and small quantities,\item The ability to ``split'' RNGs to produce parallel output streamsusing the ``leapfrog'' method,\item A shorthand notation for completely specifying thealgorithm and current state of an RNG, in an 80-character human-readable ASCII string,\item A method for reconstructing an RNG state from its shorthandnotation,\item A standardized method for adding new RNGs to the package,and\item A file-I/O interface allowing fast saves and restarts of RNG statevectors.\end{itemize}You can obtain the complete distribution of mrandom by anonymous ftpfrom \code{theory.lcs.mit.edu}.  Take the file \file{mrandom.tar.Z} fromthe directory \code{/pub/cthombor/Mrandom/V3.0}.  The distributioncontains all source code, instructions, and this manual.In addition, the mrandom package includes an unsupported set of routinesfor testing the statistical properties of the RNGs in the package.  Theroutines are packaged in an executable called \code{mrtest}.Information about \code{mrtest} is available in the \code{doc/mrtest}directory of the distribution.  Although \code{mrtest} is included inthe current distribution, it is not supported.Questions, comments, bug reports, etc. should be sent to ClarkThomborson at \code{cthombor@ub.d.umn.edu}.\section{Files in the Distribution Directory}The mrandom source code distribution includes the followingfiles:\begin{description}\item[makefile] The makefile for creating the \code{mrtest} program and the \code{mrandom.a}library.\item[README] General information about the mrandom package, includingchanges to the last version.\item[mrandom.c mrandom.h] The source and header files for the mainmrandom module.\item[bentley.c bentley.h] The source and header files for Bentley's  version of the generator described in Knuth Vol 2, Section 3.6.\item[pcrand.c pcrand.h] The source and header files for the Portable CombinedRNG.\item[ran0.c ran0.h ran1.c ran1.h ran2.c ran2.h] The source and headerfiles for Press and Teukolsky's ran0, ran1, and ran2.\item[ultra.c ultra.h] The source and header files for Marsaglia's Ultragenerator.\item[mrtest.c] The mrtest source file.\item[xsq.c xsq.h] Code used by mrtest.\item[rngs.h] The header file for the UNIX RNGs and the trivial RNG.\item[newrng.c newrng.h] Source and header file templates for a new RNG.\item[mrandom.3] The man pages for mrandom.\item[mrtest.1] The man pages for mrtest.\item[script] A test script for mrtest.\item[mrandom.tex] The latex source for this manual.\item[latexinfo.sty] The style file needed to latex this manual.\item[mrandom.txt] Plain ASCII text version of this manual.\item[mrandom.ps] PostScript version of this manual.\end{description}\section{Installing mrandom}\label{sec:install}Preparing the mrandom package for use by other programs issimple.  Merely position yourself in the directory which contains themrandom files and type:\\\begin{example}make all\\\end{example}This will compile all necessary source files and create the\code{mrandom.a} library, as well as the \code{mrtest} binary executable.You can also make either the \code{mrandom.a} library or the \code{mrtest}executable by typing:\\\begin{example}make mrandom.a\\\end{example}or\\\begin{example}make mrtest\\\end{example}\noindentrespectively.To save disk space, various intermediate object files can be removedwith:\\\begin{example}make clean\\\end{example}The system can be restored to its original state with:\\\begin{example}make realclean\\\end{example}The mrandom package is written in ANSI C, and should beeasily portable to any UNIX-based system supporting a C languagecompiler.  However, when compiling on a new system, confirm thatthe \code{long} type is represented in 32 bits.\section{What is an RNG?}Within the mrandom package, an RNG is represented by the \code{RNGdata}structure.  An RNG has several abstract characteristics which aredescribed in this section.  For a more detailed description of therepresentation of the \code{RNGdata} structure in C, seeAppendix \ref{app:rngdata}.Associated with every RNG is:\begin{itemize}\item an algorithm number, which determines which algorithm the RNGuses to produce pseudorandom generates.  For descriptions of thealgorithms which are currently installed in the package, see Appendix\ref{app:installedrngs}.\item an ``mrandom algorithm number,'' which determines whichalgorithm the \code{mrandomrv} routine will use to producerestricted-range integers when called with the RNG.  (See thedescription of \code{mrandomrv} in Section \ref{sec:mrandomrv} for moreinformation.)\item a state vector, which contains the current state of the RNG.\item the size of the state vector.\item a seed vector, which contains the seeds which were used toseed the RNG.\item the size of the seed vector.\item a count of the number of times the RNG has been called sinceit was initialized.\item two buffers\begin{itemize}\item a bit buffer for bit generates\item a main buffer for all other generates.\end{itemize}See Section \ref{sec:genproc} for a description of how the two buffers work.\item a split value, which determines how many generates to skipbetween values which are returned from the RNG.  For a detaileddescription of the split value, see Section \ref{sec:examandmodify}.\item a string containing the human-readable name of the RNG.\item the range of the RNG, such that the RNG is capable ofproducing integers with a maximum value of range-1.\end{itemize}\section{Using the mrandom package}\subsection{Overview of the Library}This section describes the mrandom library.  The proceduresin the library are gathered into the following groups:\begin{itemize}\item functions for initializing and de-initializing (killing)RNGs\item functions for returning generates from RNGs\item functions for saving and restarting RNGs\item a function for seeding RNGs\item a function for checking the integrity of RNG state vectors\item a function for producing a human-readable ASCII descriptionof an RNG\item functions for examining and modifying characteristics of RNGs\end{itemize}\subsection{Return codes from mrandom routines}Most mrandom routines follow one of two conventions for returnvalues.\noindentFor those routines which return pointers to an \code{RNGdata}structure:\begin{itemize}\item A valid pointer to an \code{RNGdata} structure is returned uponsuccess.\item A null pointer is returned upon failure.\end{itemize}For routines which produce vectors of pseudorandom generates:\begin{itemize}\item The first cell of the vector is returned upon success.\item The program aborts upon error.\end{itemize}For all other routines:\begin{itemize}\item A 0 or -1 is returned upon failure.\end{itemize}Details are provided in the description of the mrandom libraryin Section \ref{sec:library}.\subsection{Linking}In order to use the mrandom library of routines in your programsyou must:\begin{itemize}\item Link the \code{mrandom.a} library with your program.  This willtypically involve merely including the library on your compiler'scommand line, such as:\\\begin{example}cc myprog.c mrandom.a\\\end{example}Since mrandom uses some UNIX mathematical functions, you may also needto link a math library with your program, as in the following:\\\begin{example}cc myprog.c mrandom.a -lm\\\end{example}Check the documentation for your C compiler for details.\item Include the following line at the top of your source file:\begin{example}#include "mrandom.h"\end{example}\end{itemize}\subsection{The mrandom library}\label{sec:library}\subsubsection{Initialization and De-Initialization}\label{sec:initkill}In order to use an RNG, it must first be initialized.  Thisis accomplished by first declaring a pointer to an \code{RNGdata}structure, and then calling \code{init_rng}, which allocates memory forthe RNG and readies it for use by the other routines in thepackage.\\\begin{example}	RNGdata *init_rng(alg,mrandom_alg,seed,count1,count2,bufsize)	long alg;	long mrandom_alg;	long *seed;	long count1, count2;	long bufsize;	int kill_rng(rng)	RNGdata *rng;\\\end{example}\code{init_rng} returns a pointer to an initialized RNG.  A pointerreturned by \code{init_rng} is valid for use by all other mrandom routines.\code{alg} is the number of the algorithm to be used by the RNG.  (SeeAppendix \ref{app:installedrngs}.)\code{mrandom_alg} is the algorithm to be used by \code{mrandomrv} whencalled with the RNG.  (See Section \ref{sec:mrandomrv}.)\code{seed} is a pointer to a seed vector to be used to seed the RNG.(See Section \ref{sec:seedproc}.)\code{count1} and \code{count2} determine the number of initial valuesto be generated by the RNG and then discarded, according to the formula:\\number to discard = \code{count1 + BILLION*count2},\\ where \code{BILLION} is defined in \file{mrandom.h} as the decimalconstant 1000000000.\code{bufsize} is the size of the RNG's main buffer.  A non-positive value of\code{bufsize} will be interpreted as a value of 1.  (See Section\ref{sec:genproc} for more information on buffering.)\code{kill_rng} destroys the RNG, making it invalid for use.  Thisprocedure de-allocates the space used by the RNG, and should thereforebe used to kill RNGs which will no longer be used.Do {\em not} use an \code{RNGdata} pointer which points to an active RNGto store the return value of \code{init_rng}.  In order to initialize anRNG, you should either:\begin{itemize}\item Declare a new \code{RNGdata} pointer, and then use it to store thereturn value of \code{init_rng}, as shown in Figure \ref{fig:properinit}.\begin{figure}\begin{example}RNGdata *rng;long seed[1];rng=init_rng(2, 0, seed, 10000, 0, 8192);\end{example}\caption{Proper initialization of an RNG}\label{fig:properinit}\end{figure}\item Use \code{kill_rng} to de-initialize an \code{RNGdata} pointerwhich points to an active RNG, and then use that pointer to store to thereturn value of \code{init_rng}, as shown in Figure\ref{fig:properreinit}.  Figure \ref{fig:improperreinit} shows how anRNG should {\em not} be re-initialized.\begin{figure}\begin{example}RNGdata *myrng;long seed[1];seed[0]=12345;myrng=init_rng(2, 0, seed, 10000, 0, 8192);kill_rng(myrng);myrng=init_rng(3, 0, seed, 5000, 0, 2048);\end{example}\caption{Proper re-initialization of an RNG}\label{fig:properreinit}\end{figure}\end{itemize}\begin{figure}\begin{example}RNGdata *myrng;long seed[1];seed[0]=12345;myrng=init_rng(2, 0, seed, 10000, 0, 8192);myrng=init_rng(3, 0, seed, 5000, 0, 2048);\end{example}\caption{Improper re-initialization of an RNG}\label{fig:improperreinit}\end{figure}\subsubsection{Procedures for Generating Pseudorandom Numbers}\label{sec:genproc}An initialized RNG can be used to generate pseudorandomnumbers by using a variety of routines described in this section.Routines are provided for producing generates of four types:\begin{tex}\begin{itemize}\item{double precision floating point generates in the range [0,1)}\item{single precision floating point generates in the range [0,1)}\item{long integer generates in the range $0..r-1$, where r is the rangeof the RNG being used to produce generates}\item{long integer generates in the range $0..\code{m}-1$, for any $1\leq \code{m} < \code{range\_rng(rng)}$}\end{itemize}\end{tex}Note that although both single and double precision floats can bereturned by the generate-producing routines, the actual precision of thegenerates produced is determined by the precision of the underlyinggenerator being used.  In other words, the difference between routineswhich return generates of type \code{double} and those which returngenerates of type \code{float} is merely in the ``packaging'' of thegenerates, not in the precision they provide.  Information about theprecision of the RNGs currently installed in the package is in Appendix\ref{app:installedrngs}; such information can also be obtained atrun-time through the \code{range_rng} routine (see Section\ref{sec:examandmodify}).  The current version of the package onlysupports RNGs with precisions of no more than 32 bits.Both buffered and unbuffered routines are provided.  Unbuffered routinescall the underlying RNG only as many times as are needed to produce therequested number of generates, while buffered routines maintain buffersof generates, so that generates may be produced efficiently even whenrequested in small quantities.  Roughly, buffered routines arepreferable when generates are requested one at a time or in smallquantities, while unbuffered routines are preferable when generates arerequested in large quantities.  Some other differences between bufferedand unbuffered routines are discussed later in this section.  The sizeof the buffer used by an RNG is determined at the time of the RNG'sinitialization; effective buffer sizes will vary from application toapplication.The name of a routine denotes the type of the value which the routinereturns and whether the routine is buffered or unbuffered. The firstletter of a routine denotes the type of value which it returns: ``d''for double precision and ``f'' for single precision floating point inthe range [0,1); ``l'' for long integer in the range0..(\code{range_rng(rng)}-1), and ``b'' for bit (either a 0 or a 1).  Ifthe second letter of the routine's name is an ``x'', then the routine isunbuffered.  Otherwise, the routine is buffered.For convenience in user programming, we also provide a number of macrosthat supply default parameter values.  The last two letters of all ourfundamental routines is ``rv''.  This means that they must be providedwith both a pointer to an \code{RNGdata} structure and a vector to fillwith generates from the RNG.  Macros whose names do not contain an ``r''have the \code{RNGdata} pointer omitted from their parameter list; theyuse the most-recently initialized or restarted RNG to produce generates.Macros whose names do not contain a ``v'' have the vector and number ofgenerates omitted from their parameter list; they produce and return asingle generate.All generating routines abort with a message to \code{stderr} if calledwith an invalid \code{RNGdata} pointer.\\\noindent{\bf Buffering\\}The operation of the buffered routines and their interaction with theunbuffered routines requires some elaboration.  Each RNG maintains twoseparate buffers: one for buffering bit values (the ``bit buffer''), andone for buffering all other values (the ``main buffer'').  The size ofthe main buffer of an RNG is determined at the time of the RNG'sinitialization, while the size of the bit buffer is currently fixed at32 bits.Consider a freshly-initialized RNG with a main buffer size of 1000.  Arequest is made for a single generate of type \code{long}.  The RNG'sbuffer gets filled with 1000 generates, and the first such generate isreturned to the user.  So the buffer now contains 999 generates.  Ifanother generate of type \code{long}, \code{double}, or \code{float}, isrequested, a generate will be pulled from the buffer and returned to theuser after being converted to the proper type.  If the user continues torequest generates in this way and the main buffer becomes depleted, itwill be filled again with 1000 generates, and so on.The unbuffered routines do not interfere with either of the RNG'sbuffers.  Again, consider our RNG, with its buffer filled with 1000generates.  The user now makes a request for a single unbufferedgenerate.  The underlying RNG will then be called once, returning asingle generate, leaving our buffer of 1000 generates untouched, andstill ready to be accessed by the buffered routines.  If, in aparticular application, it is necessary to always use consecutivegenerates from an RNG, then that RNG should always be called {\emeither} with buffered or unbuffered routines, but not with a combinationof both.The bit buffer of an RNG operates similarly to the main buffer, with onekey difference: the bit buffer is filled by sequentially retrievinggenerates from the main buffer.  Once again, consider our RNG, with itsbuffer filled with 1000 generates, and with its bit buffer empty.  Asingle bit is then requested.  Thirty-two generates will be pulled fromthe main buffer, transformed into thirty-two one-bit 0-1 values, thenstored in the bit buffer.  (For users who are more concerned with speedthan accuracy, we also provide a ``fast'' bit-buffer call, in which asingle 32-bit generate from the main buffer is transformed intothirty-two 0-1 variates.  See the descriptions of \code{bxrandom_f} and\code{brandom_f}, below.)\\\pagebreak\noindent{\bf Unbuffered and buffered calling procedures\\}\begin{example}	double dxrandomrv(rng, n, v)	double drandomrv(rng, n, v)	RNGdata *rng;	long n;	double v[];	float fxrandomrv(rng, n, v)	float frandomrv(rng, n, v)	RNGdata *rng;	long n;	float v[];	long lxrandomrv(rng, n, v)	long lrandomrv(rng, n, v)	RNGdata *rng;	long n;	long v[];	int bxrandomrv(rng, n, v)	int brandomrv(rng, n, v)	RNGdata *rng;	long n;	int v[];	int bxrandomrv_f(rng, n, v)	int brandomrv_f(rng, n, v)	RNGdata *rng;	long n;	double v[];\\\end{example}These routines fill the vector \code{v} with \code{n} generates from\code{rng}, and return the first generate produced (i.e. \code{v[0]}).If \code{rng} is a null pointer, then the most-recently initialized orrestarted RNG is used to produce generates.  If \code{n} is 0, then the\code{v} parameter need not be provided, and a single generate isproduced and returned.\code{bxrandomrv} uses one generate from \code{rng} to generate eachbit.  This routine is slower than \code{bxrandomrv_f}, but returns bitsof higher quality.\begin{tex}\code{bxrandomrv\_f} uses each generate from \code{rng} to produce 32bits.  Therefore, requests for bits in other than multiples of 32 willresult in bits from the stream being ``lost'' between calls.  Theroutine returns -1 if it is called with an RNG whose range is not $2^{32}$.This routine is faster than \code{bxrandomrv}, but we do not recommendits use, since we know of no one who has rigorously tested such a bitstream.  We gain confidence in our slower \code{bxrandomrv} bit stream,in comparison, every time the underlying generator passes a testsensitive to correlations in the leading digit of its floating pointoutput, or to the most significant bit of its fixed point output.\end{tex}\code{brandomrv_f}, the buffered version of \code{bxrandomrv_f}, does notexhibit the same property of ``losing bits'' as does \code{bxrandomrv_f}, sincebits which are not used in one call to \code{brandomrv_f} are stored in the bitbuffer and are available for use upon future calls.\\\begin{example}	int flush_rng(rng)	RNGdata *rng;\\\end{example}	Flushes both of the RNG's buffers.\\\noindent{\bf Procedure for generating integers in a restricted range\\}\label{sec:mrandomrv}\begin{example}	long mrandomrv(rng, m, n, v)	RNGdata *rng;	long m,n,v[];\\\end{example}\begin{tex}\code{mrandomrv} fills the vector \code{v} with \code{n} generates inthe range $0..\code{m}-1$ using \code{rng}, where $1 \leq \code{m} \leq\code{range\_rng(rng)}$.  If $\code{range\_rng(rng)} < \code{m}$, theprogram aborts with an error.\end{tex}The algorithm used by \code{mrandomrv} to fill \code{v} is set by\code{init_rng} or by \code{mralg_rng}.  (See Section \ref{sec:initkill}and Section \ref{sec:examandmodify}.)\begin{tex}Algorithm 0 is Thomborson's unbiased method, which produces unbiasedlong integers in the range [0..\code{m}).  The algorithm discards anyoutputs from \code{rng} which are larger than $r-(r \bmod \code{m})$, wherer is equal to \code{range\_rng(rng)}.  At worst, this code will discard(on long-term average) at most one value of r for every one that isuseful.  This worst case is only encountered for extremely large\code{m}; for fixed and moderate \code{m}, this code will rarely discard avalue, and thus will run essentially as fast as algorithm 1.  When thevalue of \code{m} changes on each call to \code{mrandom}, however, thiscode is slower than algorithm 1, due to the necessity of recomputing$r-(r \bmod \code{m})$.The program aborts with an error message to \code{stderr} if \code{rng}is behaving so non-randomly that Algorithm 0 must make an excessivenumber of calls to \code{rng} in order to produce the requested number ofgenerates.The program aborts with an error to \code{stderr} if \code{mrandomrv} isasked to use Algorithm 0 with a value of \code{m} for which $\code{m} >\code{range\_rng(rng)}$. \\Algorithm 1 is the standard \code{(long)(m*dxrandomr(rng))}.  Thisalgorithm may be biased: for large \code{m}, some results may be be morelikely than others.  The bias is $\frac{r \bmod \code{m}}{\code{m}}$, which isupper-bounded by 0.1\% if \code{m} is less than a million and the ranger of \code{rng} is at least a billion.We do not support, and indeed we actively discourage, generatingrestricted-range integers with \code{lrandomr(rng)\%m}.  Many RNGs havepoor behavior under this transformation, most noticeably when \code{m}is a power of 2.  When \code{m} is not a power of 2, fixed-pointdivision required by an ``\code{\%}'' operation is time-consuming on manyworkstations.\\\end{tex}\noindent{\bf NOTES}\begin{tex}The \code{mrandomrv} procedure is capable of generating long integers inthe full range of any RNG for which $1 \leq \code{range\_rng(rng)} \leq2^{32}$.  In order to accomplish this, with the parameter \code{m} asigned long integer, the following mapping is used:\begin{tabbing}Range(\code{mrandom(m)}) = \=	$0..\code{m}-1$ \hspace{.5in} \= if $1 \leq\code{m} < 2^{31}$\\\> $0.. 2^{32}-1$ \> if $\code{m}=0$\\\> $0..(2^{31}-\code{m}-1)$ \> if $-2^{31} \leq \code{m} < 0$\end{tabbing}\end{tex}Macros are defined for easy calling of \code{mrandomrv} with variousdefault parameters.  See Section \ref{sec:genproc} for the namingconventions followed by the macros.\subsubsection{Saving and restarting RNGs}\label{sec:saverestart}RNGs may be saved to disk files in a human-readable ASCII format andlater restarted.  RNG buffers are not saved, and therefore all restartedRNGs have empty buffers, and any data remaining in an RNG's buffer atthe time of its state-save will {\em not} be reconstructed.\\\begin{example}	int save_rng(rng, filename)	RNGdata *rng;	char *filename;	RNGdata *restart_rng(filename)	char *filename;\\\end{example}\code{save_rng} saves \code{rng} to the ASCII file named \code{filename}.\code{restart_rng} restarts an RNG from a previously saved statefile.The restarted RNG will begin where the saved RNG ``left off.''  As with\code{init_rng}, the \code{RNGdata} pointer used to store the restartedRNG {\em must} be either a freshly declared pointer or a pointer to afreshly killed RNG (see Section \ref{sec:initkill}).RNGs may store their state and seed vectors in any of a number offormats, and this is reflected in the format of the state file.  Figure\ref{fig:samplestatefile1} shows a sample state file of an RNG usingthe Knuth/Bentley lagged-Fibonnacci generator prand (see Appendix\ref{app:installedrngs}), which stores its state and seeds as 32-bit\code{long int}s.  Figure \ref{fig:samplestatefile2} shows a samplestate file of an RNG using 4.3bsd \code{nrand48}, which stores its stateand seeds as 16-bit \code{int}s.\begin{figure}\begin{example}RNG statefile for algorithm 2, (Knuth/Bentley prand: lagged Fibbonacci)Buffer size = 1024 bytesInitial seed table =   00000927Number of calls to underlying RNG after seeding = 0 billion + 2000Next value in this pseudorandom sequence = 0b64d0eaThis RNG returns every 1 generatesThis RNG uses mrandom algorithm 0RNG state table =   0911c27a 10641ca0 2ba00807 1aabed0a   273ff367 1ab88564 2ae76a9e 2a7e6bc0   35c7568e 201b6b04 3ad90695 303208b2   1e718896 054c9886 00e8c93f 130a41cb   11de97bf 0da54e15 2f4fcca0 0ebb1f70   01c195c3 3283980e 37dee108 0893a89b   326849b0 167bb45e 19cc9765 33d97b51   36b425d1 35704e34 29a638ca 280a086f   11dfa5d6 14dcbcc4 2610bdf4 02534109   2817daf4 0bcf76ab 19b0a07d 0eebf7f6   113c003e 31b996b0 12bab234 05eddb36   1ed71381 377742a3 3878e079 2668c922   22cc8033 22368c85 18e960ea 2002b06f   22ff23e8 251187dc 340c3dcd 00000023   00000004\end{example}\caption{A sample RNG state file for the Knuth/Bentley prand().}\label{fig:samplestatefile1}\end{figure}\begin{figure}\begin{example}RNG statefile for algorithm 4, (4.3bsd nrand48.c: 48-bit multiplicative)Buffer size = 8192 bytesInitial seed table =   0096   b43f   0034   bf15Number of calls to underlying RNG after seeding = 0 billion + 11000Next value in this pseudorandom sequence = 04a3689eThis RNG returns every 1 generatesThis RNG uses mrandom algorithm 0RNG state table =   07c5   8f2d   0000   a7d6\end{example}\caption{A sample RNG state table for {\tt nrand48}}\label{fig:samplestatefile2}\end{figure}A few examples of how to save and restart RNGs are displayed in Figure\ref{fig:saverestart}.\begin{figure}\begin{example}/* Proper way to re-initialize an active RNG */mrandom(rng,10,n,v);kill_rng(rng);rng=restart_rng("mystatefile");/* Proper way to restart an inactive RNG */RNGdata *rng;rng=restart_rng("mystatefile");/* Improper way to restart an active RNG */mrandom(rng,10,n,v);rng=restart_rng("mystatefile");\end{example}\caption{Examples of saving and restarting RNGs}\label{fig:saverestart}\end{figure}\subsubsection{Seeding}\label{sec:seedproc}Each RNG is initially seeded during initialization by\code{init_rng}.  An RNG may also be reseeded at any time afterinitialization.\\\begin{example}	void seed_rng(rng,seed)	RNGdata *rng;	long *seed;\\\end{example}\code{seed_rng} seeds \code{rng} with the seed table pointed to by \code{seed}.The RNG's counter is reset to 0 and its buffers are flushed.\subsubsection{Checking RNG integrity}	An RNG can be checked to see if it has been corrupted or isotherwise not in proper condition for use.\\\begin{example}	int check_rng(rng);	RNGdata *rng;\\\end{example}\code{check_rng} checks the integrity of the RNG, in order to determinewhether it can be used by the other mrandom library routines.\subsubsection{Obtaining a human-readable description of the RNG}\begin{example}	char *describe_rng(rng,rngid)	RNGdata *rng;	char rngid[RNGIDSTRLEN];\\\end{example}\code{describe_rng} places a human-readable description of \code{rng} inthe string \code{rngid}.  The string has the following format:\\\begin{example}RNG state identifier is (alg, mralg: seed1, seed2; count1,count2;bufsize, split)\\\end{example}where\begin{itemize}\item \code{alg} is the number of the algorithm used by \code{rng} to generatepseudorandom numbers.  (See Appendix \ref{app:installedrngs}.)\item \code{mralg} is the number of the algorithm used by\code{mrandomrv} when called with \code{rng}.  (See Section\ref{sec:mrandomrv}.)\item \code{seed1} and \code{seed2} are the first and second entries int\code{rng}'s seed table.  If \code{rng}'s seed table has more than twoentries, only the first two are included in its description.  (SeeSection \ref{sec:seedproc}.)\item \code{count1} and \code{count2} represent \code{rng}'s counter.(See Section \ref{sec:initkill}.)\item \code{bufsize} is the number of entries in \code{rng}'s buffer.(See Section \ref{sec:genproc}.)\item \code{split} is \code{rng}'s current split value.  (See Section\ref{sec:examandmodify}.)\end{itemize}\code{describe_rng} exits with a message to \code{stderr} if calledwith an invalid \code{RNGdata} pointer.\subsubsection{Procedures for examining and modifying RNG parameters}\label{sec:examandmodify}Procedures are available for examining and modifying an RNG's parametersonce it has been initialized.\\\begin{example}	int mralg_rng(rng, new_value)	RNGdata *rng;	long new_value;	int split_rng(rng, new_value)	RNGdata *rng;	long new_value;	double range_rng(rng)	RNGdata *rng;\\\end{example}\code{mralg_rng} sets \code{rng}'s mrandom algorithm number (See Section\ref{sec:mrandomrv} for information on mrandom algorithm numbers).  Itreturns 0 if \code{new_value} is an invalid value.\code{split_rng} sets the split value of \code{rng}.  It returns 0 if\code{new_value} < 0.  An RNG's split value is set to \code{SPLIT_DEF}upon initialization.  \code{SPLIT_DEF} is \code{#define}d in\file{mrandom.h}, and currently has a value of 0.The function of the split value is to simulate one ``branch'' of agenerator which has been ``split'' into two or more generators.  This isbest illustrated with an example.  Consider an (apparently non-random)RNG which returns the raw sequence:\begin{center}0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ...\\\end{center}The split value indicates how many elements of the sequence to skipbetween generates.  For example, if our sample RNG were given a splitvalue of 1 immediately after initialization, it would then return the followingsequence:\begin{center}0 2 4 6 8 10 ...\\\end{center}A split value of 2 after initialization would produce:\begin{center}0 3 6 9 12 15 ...\\\end{center}An RNG may be split at any time after its initialization.  So, forexample, our sample RNG might be initialized and then made to generatethe following values:\begin{center}0 1 2 3 4 5\\\end{center}before being split with a split value of 3, producing the followinggenerates:\begin{center}6 10 14 18 22 ...\\\end{center}Splitting can be used to create several ``leapfrogged'' RNGs from oneRNG, as shown in Figure \ref{fig:leapfrog}.\begin{figure}\begin{example}RNGdata *rngs[10];long seed;int i;seed=12345;for (i=0; i<10; i++) \{  /* RNG #i gets cycled i times */  rng[i]=init_rng(2,0,&seed,i,0,1024);  split(rng[i],9);\}\end{example}\caption{Creating ``leapfrogged'' RNGs}\label{fig:leapfrog}\end{figure}This operation may be useful in parallel codes, as in testing an RNG forlong-range correlations.  Unfortunately, our current implementation isinefficient for leapfrogging large numbers of RNGs.  A more efficientmethod may be included in a future version of mrandom.The split value affects all of the pseudorandom number generatingroutines (See Section \ref{sec:genproc}).\code{range_rng} returns the range of \code{rng}.\\\noindent{\bf NOTES}These procedures exit with a message to \code{stderr} if\code{rng} does not point to a valid \code{RNGdata} structure.\section{Adding new RNGs to the Package}This section is designed for the programmer who wishes to add new RNGsto the mrandom package.  The section first describes the routines whichmust be provided by the programmer to serve as an interface between theRNG and the mrandom package.  It then describes the RNG parameters whichmust be defined in a header file for the RNG, and how these parametersare to be incorporated into the code for mrandom itself.  Finally, itdescribes how to remake the mrandom package after adding or modifyingRNGs.  Appendix \ref{app:installedrngs} contains descriptions of the tenRNGs installed in the current version of the package.\subsection{Routines Provided by the Programmer}\label{sec:progroutines}\subsubsection{Introduction}This section describes routines which must be provided by each RNG inthe package.The routines provided by the programmer must manipulate an\code{RNGdata} structure.  In order to facilitate this, two macros areavailable for accessing an RNG's state and seed vectors:\begin{itemize}\item \code{RNGstate} refers to the RNG's state vector.\item \code{RNGseed} refers to the RNG's seed vector.\end{itemize}These vectors are one-dimensional C arrays, e.g.\code{RNGstate[0]} is the first element in the RNG's state vector,\code{RNGstate[1]} is the second element, etc.  In order to make use ofthese macros, the name of the \code{RNGdata} pointer in your routines'parameter lists {\em must} be \code{rng}, as shown in the examples inthis section.The names used as examples in this section begin with ``\code{myrng}'';however, there are no restrictions on naming of routines provided by anRNG.  However, for ease of readability and consistency, we suggest thatthe naming conventions used in this section be followed.The routines described in this section should be included in a single\code{.c} file.  A template for such a source file, called\file{newrng.c}, is included in the distribution and displayed in Figure\ref{fig:newrng.c}.Remember that all RNG state information must be included in the\code{RNGstate} field of the \code{RNGdata} structure.  In particular,do {\em not} use global or static variables to hold RNG stateinformation.  Doing so will make it impossible to run severalinstantiations of your RNG simulataneously.\begin{figure}\begin{example}/* newrng.c *//* RNG source file template *//* Robert Plotkin/* 5/3/93 */#include "newrng.h"/* Generating procedure *//* Only one of the following two procedures should be *//* defined, depending on the kind of value that *//* your RNG returns */long newrng_lgen(rng)RNGdata *rng;\{/* Your generating procedure goes here */\}double newrng_dgen(rng)RNGdata *rng;\{/* Your generating procedure goes here */\}/* Seeding procedure */void newrng_seed(rng,seed)RNGdata *rng;long *seed;\{/* Your seeding procedure goes here */\}/* Checking procedure */int newrng_check(rng)RNGdata *rng;\{/* Your checking procedure goes here */\}\end{example}\caption{RNG source file template}\label{fig:newrng.c}\end{figure}\subsubsection{Seeding Routine}\begin{example}	void myrng_seed(rng, seed)	RNGdata *rng;	long *seed;\\\end{example}This procedure is used for seeding the RNG.  The interpretation of the\code{seed} parameter is left entirely to the programmer.  It may, forexample, point to a single integer or to an array of 5,000 integers.One of the RNGs currently installed in the package interprets the\code{seed} parameter as pointing to three 16-bit integers.  Obviously,RNGs which are capable of being seeded with a variable number of seedsneed to be passed a seed pointer which contains adequate informationabout the number of seeds to which it points.Although the seeding procedure is passed an entire \code{RNGdata}structure as a parameter, it should only manipulate the \code{RNGstate}field of that structure.  (See Appendix \ref{app:rngdata} for informationon the \code{RNGdata} structure.)  Many RNG seeding procedures will simplycopy the seed parameter into \code{RNGstate}, as shown in Figure\ref{fig:sampleseed}.\begin{figure}\begin{example}	void myrng_seed(rng, seed)	RNGdata *rng;	long *seed;	\{	RNGstate[0]=seed[0];	RNGstate[1]=seed[1]; /* This RNG uses two long seeds */	\}\end{example}\caption{A sample seeding procedure}\label{fig:sampleseed}\end{figure}Other seeding procedures may fill \code{RNGstate} with the resultsof some complicated function performed on the initial seed table.\subsubsection{Pseudorandom Number Generating Procedure}\begin{example}long myrng_lgen(rng)RNGdata *rng;double myrng_dgen(rng)RNGdata *rng;\\\end{example}The programmer must provide {\em one} procedure, matching one of the twoprototypes given above, which returns asingle generate from the RNG.  The routine may return either:\begin{itemize}\item a double precision floating point number in the range [0,1), or\item a long (32-bit) integer in the range 0..\code{range_rng(rng)}-1\end{itemize}\noindentIt is pointless for the programmer to provide procedures of both types.If this is done, only one of them will be accessible by any user code,depending on the value given to \code{RNGreturns}, \code{RNGdgen}, and\code{RNGlgen} (see Section \ref{sec:rngheaders}).Although the generating procedure is passed an entire \code{RNGdata}structure, it should only manipulate the \code{RNGstate} field of thestructure.  A sample generating procedure is displayed in Figure\ref{fig:samplegen}.\begin{figure}\begin{example}long myrng_lgen(rng)RNGdata *rng;\{RNGstate[0]*=12345+6789;return(RNGstate[0]);\}\end{example}\caption{A sample generating procedure}\label{fig:samplegen}\end{figure}\subsubsection{RNG Checking Procedure}\begin{example}int myrng_check(rng)RNGdata *rng;\\\end{example}The programmer must provide a procedure to check theintegrity of the \code{RNGdata} structure.  The procedure returns a valueof 1 if the RNG is fit for use, and returns 0 otherwise.  Thecoding of the procedure is entirely RNG-specific, and may beextremely simple or extremely complicated, depending on the natureof the RNG and the extent of integrity desired.  On one extreme isthe procedure which always declares success, and on the otherextreme is the perfect (and slow) procedure which creates a newRNG, seeds it with the seeds of the RNG to be checked, cycles itthrough the number of generates which were produced by the RNG tobe checked, and compares the state tables of the two RNGs.Clearly, the procedure should not modify the RNG in any way.  Whenwriting a checking procedure it might be useful to examine thoseincluded in the existing package.\subsection{RNG Header Files}\label{sec:rngheaders}For each RNG included in the package, there must be acorresponding header file.  The header file contains informationabout the RNG which is used by the mrandom library routines.This section describes the information contained in RNG headerfiles, and describes how to use such header files to incorporatenew RNGs into the mrandom package.  A template for such a header file,called \file{newrng.h}, is included in the distribution and displayed inFigure \ref{fig:newrng.h}.\begin{figure}\begin{example}/* newrng.h *//* RNG header file template *//* Robert Plotkin/* 5/3/93 */#include "mrandom.h"/* Information for mrandom */#define RNGstatesize_n    #define RNGseedsize_2#define RNGrange_2#define RNGname_2#define RNGreturns_2#define RNGstatetype_2#define RNGdgen_2#define RNGlgen_2#define RNGseed_2#define RNGcheck_2/* mrandom interface routines */long newrng_gen(/* RNGdata * */);void newrng_seed(/* RNGdata *, long * */);int newrng_check(/* RNGdata * */);\end{example}\caption{RNG header file template}\label{fig:newrng.h}\end{figure}\subsubsection{Information in Header Files}\label{sec:headers}Each header file should begin with the following directives:\\\begin{example}#ifndef MRANDOM#include "mrandom.h"#endif\\\end{example}\pagebreak\noindent{\bf Definition of RNG parameters\\}The next set of lines in the file should contain \code{#define}statements which assign values to the RNG's parameters.  The names usedin the \code{#define} statements must contain the RNG's number.  Thereare currently ten RNGs included in the package, labeled 0 through 9.The next RNG included in the package should be labeled number 10, and soon.  The ``\code{n}'' in each parameter name in the following listshould be interpreted as the RNG's number.\begin{description}\item[\code{RNGname_n}] A string constant containing the name of the RNG,terminated with a newline character.\item[\code{RNGstatesize_n}] The number of entries in the RNG's statetable.  Each entry is a (32-bit) \code{long}.  If the RNG iscapable of using state tables of varying sizes, \code{RNGstatesize_n}should be defined as the maximum possible size.\item[\code{RNGseedsize_n}] The number of entries in the RNG's seed table.Each entry is a (32-bit) \code{long}.  If the RNG is capable ofusing seed tables of varying sizes, \code{RNGseedsize_n} should bedefined as the maximum possible size.\item[\code{RNGrange_n}]\begin{tex} The range of the RNG, expressed as a doubleprecision floating point number.  The range of the RNG is one morethan the maximum value the RNG is capable of generating.  For RNGswhich produce double precision generates with a precision of p(i.e. in the range $[0,(\code{RNGrange}-1.0)/(1<<p))$, \code{RNGrange}should be defined as $2^{p}$.  For example, an RNG which produces 8-byteIEEE floating-point generates using single-precision IEEE arithmetic(24-bit mantissas) has a range of 16777216.0.\end{tex}\item[\code{RNGreturns_n}] A number signifying the type of the generatereturned by the RNG.  An RNG can return a value of one of two types:\begin{itemize}\item a \code{long} in the range 0..\code{RNGrange}-1\item a \code{double} in the range [0,1)\end{itemize}RNGs which return values of type \code{long} and \code{double} returntypes \code{RET_LONG} and \code{RET_DOUBLE}, respectively, as defined in\file{mrandom.h}.\item[\code{RNGstatetype}] A number signifying the interpretation of thevalues stored in the RNG's state and seed vectors.  This value is usedby the routines that read and write the ASCII state files, therebyallowing portability of state files across machines with different byteorderings (see Section \ref{sec:saverestart}).  The following valuesare currently supported:\begin{tex}\begin{center}\begin{tabular}{l l}Value & Type\\\hline\\\code{STATE\_CHAR} & 8-bit character\\\code{STATE\_INT} & 16-bit integer\\\code{STATE\_LONG} & 32-bit long integer\\\end{tabular}\end{center}\end{tex}The values of \code{STATE\_FLOAT} (IEEE-standard 32-bit float) and\code{STATE\_DOUBLE} (IEEE-standard 64-bit float) are not currentlysupported and are reserved for future use.\item[\code{RNGdgen_n} and \code{RNGlgen_n}] The label of the procedure to beused for generating pseudorandom numbers.  If the RNG returns\code{double}s, then \code{RNG_dgen} should be defined as the label ofthe RNG generating procedure, and \code{RNG_lgen} should be defined as0.  If the RNG returns \code{long}s, then \code{RNG_lgen} should bedefined as the label of the RNG generating procedure, and\code{RNG_dgen} should be defined as 0.\item[\code{RNGseed_n}] The label of the procedure to be used for seedingthe RNG.\item[\code{RNGcheck_n}] The label of the procedure to be used forchecking the integrity of the RNG.\end{description}\noindent{\bf Procedure prototypes\\}Finally, the header file must contain function prototypes forthe three procedures provided by the RNG, so that the procedurescan be accessed by the main mrandom code.  For example:\\\begin{example}long myrng_gen();void myrng_seed();int myrng_check();\end{example}\subsection{Modifying the mrandom code}Only a few lines of \file{mrandom.h} and \file{mrandom.c} need to bemodified when adding a new RNG to the package.\begin{itemize}\item The number of RNGs currently installed in the package is defined as\code{NUM_RNGS} in \file{mrandom.h}.  The current value is 10.  Thisvalue should be incremented when a new RNG is added to the package.\item The header file for the new RNG needs to be \code{#include}d in\file{mrandom.c}.  The \code{#include} directive should be included in thesection marked by the comment ``\code{Header files for RNGs currently included in package.}''\item Several additions need to be made in \file{mrandom.c} in thesection marked by the comment ``\code{Arrays to hold information aboutRNGs.}''  This section of the code declares and initializes severalarrays which hold information about the RNGs included in thepackage.\pagebreakWhen installing a new RNG, the appropriate \code{#define}d values needto be inserted at the end of each initialization list.  For example, thedeclaration of \code{RNGname\_a} currently reads:\\\begin{example}char RNGname\_a[NUM\_RNGS][RNGIDSTRLEN]=\{RNGname\_0, RNGname\_1,      RNGname\_2, RNGname\_3, RNGname\_4, RNGname\_5, RNGname\_6,      RNGname\_7, RNGname\_8, RNGname\_9\};\\\end{example}After adding a new RNG to the package, this declaration would read:\\\begin{example}char RNGname\_a[NUM_RNGS][RNGIDSTRLEN]=\{RNGname\_0, RNGname\_1,      RNGname\_2, RNGname\_3, RNGname\_4, RNGname\_5, RNGname\_6,      RNGname\_7, RNGname\_8, RNGname\_9,      /* RNG #10 added -> */ RNGname\_10\};\\\end{example}The arrays \code{statesize\_a}, \code{seedsize\_a}, \code{range\_a},\code{returns\_a}, \code{statetype\_a}, \code{seed\_a}, \code{dgen\_a},\code{lgen\_a}, and \code{check\_a} need to be similarly modified.\end{itemize}\subsection{Remaking the mrandom Package}	Once you have added an RNG to the package as described in theprevious sections, you will need to remake the mrandom package.  To dothis:\begin{itemize}\item Make sure that all of the files for the mrandom package,include the source and header files for your new RNG, are in thesame directory.\item Include the names of your header, source, and object files in\file{makefile} on the lines labeled \code{INCS}, \code{SRCS}, and\code{OBJS}, respectively, as show in Figure \ref{fig:addmake}.\begin{figure}\begin{example}INCS = mrandom.h bentley.h pcrand.h ran0.h ran1.h ran2.h ultra.h xsq.h myrng.hSRCS = mrtest.c mrandom.c bentley.c pcrand.c ran0.c ran1.c ran2.c ultra.c xsq.c myrng.cOBJS = mrandom.o bentley.o pcrand.o ran0.o ran1.o ran2.o ultra.o xsq.o myrng.o\end{example}\caption{Addition of {\tt myrng} to {\tt makefile}}\label{fig:addmake}\end{figure}\item Follow the instructions for making the mrandom package, asdescribed in Section \ref{sec:install}.\end{itemize}Once the package has been remade it will be ready for use, with your newRNG, by other programs.\pagebreak\appendix\section{The RNGdata Structure}\label{app:rngdata}\subsection{Introduction}This section describes the representation in C of the \code{RNGdata}structure which is used by the mrandom package to represent RNGs.  Thisstructure need never be manipulated by the programmer, except asdescribed in Section \ref{sec:progroutines}.  This section, therefore,is intended for those who are interested in learning a little more aboutthe inner workings of the mrandom package.In order to generate random numbers, the user must first declare apointer to an \code{RNGdata} structure, and use \code{init_rng} toallocate space for the RNG and perform various initialization functions.The user uses the RNG entirely through calls provided by the interfacedescribed in Section \ref{sec:library}; i.e. the user should notdirectly manipulate the \code{RNGdata} structure.\subsection{Inside the Structure}	The definition of the \code{RNGdata} structure is displayed inFigure \ref{fig:rngdata}.\begin{figure}\begin{example}\begin{tabbing}struct \= rngdata \{ \+ \\long rngalg;\\long mrandom_alg;\\long *rngstate;\\long *rngseed;\\long rngcount1;\\long rngcount2;\\struct \{ \= \+ \\long size;\\long nleft;\\long nbleft;\\double *dbuf,*dbufp;\\long *lbuf,*lbufp;\\int *bbuf,*bbufp;\\\} buffer; \- \\long rngnextval;\\long rngsplit;\\char rngname[];\\long rngstatesize;\\long rngseedsize;\\long rngrangem1;\\double rngrange;\\signed int rngreturns; \- \\\}; \\typedef struct rngdata RNGdata;\end{tabbing}\end{example}\caption{The {\tt RNGdata} structure}\label{fig:rngdata}\end{figure}Descriptions of its fields are as follows:\begin{description}\item[\code{rngalg}] A number identifying the algorithm to be used bythe RNG to produce pseudorandom generates.  Algorithms in the packageare numbered sequentially starting with 0; currently there are 10algorithms installed, numbered 0 through 9.  A table of RNGs which arecurrently installed in the mrandom package, with their correspondingalgorithm numbers, is in Appendix \ref{app:installedrngs}.\item[\code{mrandom_alg}] The algorithm use by \code{mrandomrv} whencalled with this RNG.  See Section \ref{sec:mrandomrv} for more on\code{mrandomrv}.\item[\code{rngstate}] A pointer to the RNG's state vector, used tostore the current state of the RNG.  See Sections \ref{sec:saverestart},\ref{sec:progroutines}, and \ref{sec:headers} for more information on RNGstate vectors.\item[\code{rngseed}] A pointer to the RNG's seed vector.  See Section\ref{sec:seedproc} for more information on RNG seed vectors.\item[\code{rngcount1}, \code{rngcount2}] These two values represent thenumber of generates the RNG has produced since initialization, accordingto the formula:\\\begin{example}rngcount1+rngcount2*BILLION\\\end{example}where BILLION is defined in \file{mrandom.h}.  Please note that thevalue represented by \code{rngcount1} and \code{rngcount2} is the {\ittotal} number of generates produced by the RNG since initialization,including those discarded due to splitting of the RNG.  (See Section\ref{sec:examandmodify} for more information about splitting RNGs.)\item[\code{rngnextval}] The next value to be output from the RNG.  Thisvalue is used internally by the mrandom library and is not guaranteed tobe accurate.\item[\code{rngsplit}] Every (\code{split}+1)-th generate of theunderlying RNG will be returned by the RNG calling procedures.\code{rngsplit} is set to \code{DEF_SPLIT} upon initialization of theRNG, as defined in \file{mrandom.h}.  See Section \ref{sec:examandmodify}for more information about splitting RNGs.\item[\code{buffer}] This structure contains information about the RNG'sbuffer and its bit buffer.  (See Section \ref{sec:genproc} for moreinformation on RNG buffers.)  It contains several fields:\begin{description}\item[\code{size}] The number of entries in the RNG's buffer.\item[\code{nleft}] The number of values left in the RNG's buffer.\item[\code{nbleft}] The number of values left in the RNG's bit buffer.\item[\code{dbuf}, \code{dbufp}] A pointer to the first entry in the doublebuffer, and a pointer to the next entry to be retrieved from thedouble buffer.\item[\code{lbuf}, \code{lbufp}] Same for the long buffer.\item[\code{bbuf}, \code{bbufp}] Same for the bit buffer.\end{description}\end{description}The remaining values in the RNGdata structure are derivedfrom the RNG's header file upon initialization.  For more information onthe values of these fields, see Section \ref{sec:headers}.\section{RNGs Currently Installed in the Package}\label{app:installedrngs}There are currently ten RNGs installed in the mrandom package.  Thisappendix provides brief descriptions of each of them.  References areprovided for those who are interested in finding out about the RNGs inmore detail.\begin{description}\item[RNG algorithm 0: A trivial RNG] A trivial RNG is included in thepackage, primarily for testing purposes.  The generates it produces arenot ``random'' in virtually any sense of the word; it simply producesgenerates from an arithmetical progression determined by its initialseeds.  For example, if it is seeded with 5 and 7, respectively, it willproduce the sequence 5, 12, 19, 26, etc.This RNG takes two \code{long}s as seeds.  It returns generatesof type \code{long}.\item[RNG algorithm 1: 4.3bsd random]\begin{tex}This is UNIX 4.3bsd \code{random}.  It is a 31-bit nonlinear additivefeedback generator with a range of $2^{31}$ and a period ofapproximately $16*2^{31}-1$.  It is nominally able to save and restorestate, but its state-saving code is buggy.  Therefore, when using\code{random} with the mrandom package, no more than one RNG should use\code{random} at a time.\end{tex}This RNG takes a single \code{long} as a seed.  It returns generates oftype \code{long}.\item[RNG algorithm 2: the Knuth/Bentley prand]  Thislagged-Fibonacci RNG was introduced by Jon Bentley in his ``SoftwareExploratorium'' column in {\em Unix Review}, Vol. 10, No. 6, June 1992,and is based on one first presented in Donald E. Knuth's {\em The Art ofComputer Programming}, Vol. 2, Addison-Wesley, Reading, Mass., 1981.It has a range of 1,000,000,000.This RNG takes a single \code{long} as a seed.  It returns generates oftype \code{long}.\item[RNG algorithm 3: The Portable Combined RNG]  This combinedprime multiplicative congruential RNG was developed based on algorithmsand selections of prime numbers presented in ``Efficient and PortableCombined Random Number Generators,'' Pierre L'Ecuyer, {\emCommunications of the ACM}, Vol. 10, No. 6, June 1992, and ``RandomNumber Generators: Good Ones are Hard to Find,'' Stephen Park and KeithMiller, {\em Communications of the ACM}, Vol. 31, No. 10, October 1992.It has a range of 2147483561.This RNG takes two \code{long}s as seeds.  It returns generates of type\code{long}.\item[RNG algorithm 4: 4.3bsd nrand48]\begin{tex}This is UNIX 4.3bsd \code{nrand48}.  It produces generates using alinear congruential algorithm and 48-bit integer arithmetic.  It has arange of $2^{31}$.\end{tex}This RNG takes three \code{unsigned short}s as seeds.  They are passedto the seeding procedure as two \code{long}s, and are interpreted in thefollowing way:\begin{itemize}\item The 16 least significant bits of the second \code{long} is thefirst seed.\item The 16 least significant bits of the first \code{long} is thesecond seed.\item The 16 most significant bits of the first \code{long} is the thirdseed.\item The 16 most significant bits of the second \code{long} isignored.\end{itemize}This RNG returns generates of type \code{long}.\item[RNG algorithm 5: 4.3bsd rand]\begin{tex}This is UNIX 4.3bsd \code{rand}.  It uses a multiplicative congruentialalgorithm.  It has a period of $2^{32}$ and a range of $2^{31}$.\end{tex}This RNG takes a single \code{long} as a seed.  It returns generates oftype \code{long}.\item[RNG algorithm 6, 7, and 8: Press and Teukolsky's ran0, ran1, andran2]\begin{tex}These three multiplicative congruential RNGs are adapted from thosepresented in ``Portable Random Number Generators,'' William H.  Pressand Saul A. Teukolsky, {\em Computers in Physics}, Vol. 6, No. 5,Sep/Oct 1992.  They all have a period of $2^{31}-2$ and a range of$2^{31}-1$.\end{tex}These RNGs take a single \code{long} as a seed.  They return generatesof type \code{double}. \item[RNG algorithm 9: Marsaglia's Ultra RNG]\begin{tex}We obtained the source code for this generator by anonymous ftp from\code{nic.funit.fi} (take the file \code{fsultra.zip} from the directory\code{/pub/msdos/science/math/fsultra}).  A note in the \file{readme}file says: ``To obtain permission to incorporate this program into anycommercial product, please contact the authors at the e-mail addressgiven above [afir@stat.fsu.edu or geo@stat.fsu.edu] or at Department ofStatistics and Supercomputer Computations Research Institute, FloridaState University, Tallahassee, FL 32306.''  This RNG is one of thoseoriginally presented in ``A New Class of Random Number Generators,''George Marsaglia and Arif Zaman, {\em The Annals of AppliedProbability}, Vol. 1, No. 3, 1991.  It is a ``subtract-with-borrow''generator with a range of $2^{32}$ and a staggering period of$10^{354}$.\end{tex}This RNG takes two \code{unsigned long}s as seeds.  It returns generatesof type \code{double}.\end{description}\end{document}