; Copyright Е 1992 Peter Speck, speck@dat.ruc.dk. All rights reserved.; UThread.a; extern "C" MySwapStacks(Handle fromStackH, Handle toStackH);	Include	'Types.a'	Include	'Memory.a'	Case	On	Seg		'MyThread'	CurStackBase       EQU     $908	; Layout of StackHandle:kAllocSize			Equ		 0; Alloc size of HandlekStartAddr			Equ		 4; start address of saved stackkSize				Equ		 8; Size of saved stackkSP					Equ		12; Saved SPkDataOffset			Equ		16; StackDataMySwapStacks PROC	EXPORT; showup for MacsBug	link	a6, #0	unlk	a6	Import	gFromStackH:Data	Import	gToStackH:Data	Import	PanicExitToShell__FPCc:Code	move.l	4(a7), gFromStackH(A5)	move.l	8(a7), gToStackH(A5)		; save registers	movem.l	d0-d7/a0-a6, -(a7)	; save swap-out stack	tst.l	gFromStackH(A5)	beq.s	MySwapStacks_SwapIn			; skip if no from handle	move.l	CurStackBase, d7	move.l	a7,d5						; round SP (mod 16) into D5	move.l	#15, d0	not.l	d0							; clear to mod 16	and.l	d0, d5	sub.l	d5,d7						; d7 = stack size = (CurStackBase - D5)	move.l	gFromStackH(A5), a4	move.l	(a4), a4	move.l	d7, d6						; add a little to size for safety	add.l	#1024, d6	cmp.l	kAllocSize(a4), d6	blt.s	NoGrowNeeded	move.l	gFromStackH(A5), a0	move.l	d6,d0	_SetHandleSize	tst.w	d0	bne.s	SwapThreadOutOfMemory	move.l	gFromStackH(A5), a4	move.l	(a4), a4	move.l	d6, kAllocSize(a4)NoGrowNeeded	move.l	d7, kSize(a4)				; save stack size	move.l	d5, kStartAddr(a4)			; save stack start	move.l	a7, kSP(a4)					; save SP	move.l	d7,d0	move.l	a4, a1	add.l	#kDataOffset, a1	move.l	d5,a0	_BlockMove	; restore new stackMySwapStacks_SwapIn	tst.l	gToStackH(A5)	beq.s	MySwapStacks_Done			; skip if no dest handle	move.l	gToStackH(A5), a4	move.l	(a4), a4	move.l	kSP(a4), a7	sub.l	#256, a7					; keep rts addr safe	move.l	kStartAddr(a4), a1	move.l	a4, a0	add.l	#kDataOffset, a0	move.l	kSize(a4), d0	_BlockMove	add.l	#256, a7					; reset a7 to real valueMySwapStacks_Done	movem.l	(a7)+, d0-d7/a0-a6	rts; for MacsBug;	unlk	a6;	rts	string AsIs	dc.b	$8C	dc.b	'MySwapStacks'	dc.w	0SwapThreadOutOfMemory	pea		#'Could not resize handle for saving stack (swapping thread out)'	jsr		(PanicExitToShell__FPCc).L		; (does not return)	_Debugger	rts	dc.b	$95	dc.b	'SwapThreadOutOfMemory'	dc.w	0ENDP; Copied from {AIncludes}SysEqu.aHeapEnd            EQU     $114  ;[GLOBAL VAR] Address of end of application heap zone                   ;        end of heap [pointer]ApplLimit          EQU     $130  ;[GLOBAL VAR] Application heap limit                   ;        application limit [pointer]HiHeapMark         EQU     $BAE  ;[GLOBAL VAR]  (long) highest address used by a zone below sp<01Nov85 JTC>MySetJmp68000 PROC	EXPORT; showup for MacsBug	link	a6, #0	unlk	a6	movea.l	(a7)+, a1	movea.l	(a7),a0	movem.l	d2-d7/a1-a4/a6/a7, (a0)	move.l	$114,$30(a0)				;HeapEnd	move.l	$130,$34(a0)				;ApplLimit	move.l	$BAE,$38(a0)				;HiHeapMark	moveq	#0, d0	jmp		(a1); for MacsBug	rts	string AsIs	dc.b	$8D	dc.b	'MySetJmp68000'	dc.w	0ENDPMyLongJmp68000 PROC	EXPORT	Import	PanicExitToShell__FPCc:Code; showup for MacsBug	link	a6, #0	unlk	a6	move.l	8(a7),d0					; Ptr to dispose	move.l	4(a7),a0	movem.l	(a0), d2-d7/a1-a4/a6/a7	move.l	$30(a0),$114				; HeapEnd	move.l	$34(a0),$130				; ApplLimit	move.l	$38(a0),$BAE				; HiHeapMark	movea.l	d0,a0	move.l	d0,d1 ; say after me: addr moves doesn't set flags	beq.s	NoDispose	_DisposePtr	tst.w	$220						; MemError()	bne.s	BadDisposeNoDispose	moveq	#1, d0	jmp		(a1); for MacsBug	rts	string AsIs	dc.b	$8E	dc.b	'MyLongJmp68000'	dc.w	0BadDispose	pea		#'MemError after _Dispose of thread stack'	jsr		(PanicExitToShell__FPCc).L		; (does not return)	_Debugger	rts	dc.b	$95	dc.b	'SwapThreadOutOfMemory'	dc.w	0ENDP;	Include 'Socket.a'				ENDasm -model far UThread.a и {worksheet}dumpobj UThread.a.o ии {worksheet}link -m MySwapStacks UThread.a.o -o UThread.a.o.linkdumpcode UThread.a.o.link#