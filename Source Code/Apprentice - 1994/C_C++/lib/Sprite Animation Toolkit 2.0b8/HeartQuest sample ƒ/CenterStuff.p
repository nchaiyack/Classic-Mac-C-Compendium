unit CenterStuff;interface	procedure CenterDialog (id: integer);	procedure CenterPDialog (id: integer; var corner: Point);	procedure CenterRect (var r: Rect);	function DoAlert (kind, alertID: integer; filterProc: ProcPtr): integer;implementation{Based on code from the following post:}{From: Michael_Hecht@mac.sas.com (Michael Hecht)}{Newsgroups: comp.sys.mac.programmer}{Subject: Re: How to tell if a window has a title bar?}{Date: 26 Mar 92 20:03:05 GMT}{Here's how I compute the height of a window's title bar: É}	function GetTitleHeight (theWindow: WindowPtr): integer;		var			windRect: Rect;			bias: integer;	begin	{ Convert window's portRect to global coordinates }		windRect := theWindow^.portRect;		LocalToGlobal(windRect.topLeft);		LocalToGlobal(windRect.botRight);	{ Calculate the height of the window's title bar }		bias := windRect.top - 1 - WindowPeek(theWindow)^.strucRgn^^.rgnBBox.top;		windRect.top := windRect.top - bias;{ What is the result? windRect? [I HAVN'T PORTED THIS TO WORKING CONDITION! /Ingemar]}	end;{> (Or, just in case I've lost the woods for the trees, how do I accurately}{> center my windows?)}{Here's what I do:}{ CenterRect:	Center a rectangle on the main screen }	procedure CenterRect (var r: Rect);		var			delta, screenTop: integer;	begin	{ Center it horizontally }		delta := r.right - r.left;		r.left := BSR(screenBits.bounds.right - delta, 1);		r.right := r.left + delta;	{ Determine top of screen }		screenTop := 22; {GetMBarHeight ( ); { I'm cheating a bit here - GetMBarHeight would be better. /Ingemar }	{ Place it in upper third of screen }		delta := r.bottom - r.top;		r.top := (screenBits.bounds.bottom - screenTop - delta) div 3 + screenTop;		r.bottom := r.top + delta;	end;	procedure CenterDialog (id: integer);		var			theDLOG: DialogTHndl;			bounds: Rect;	begin	{ Get the DLOG resource }		theDLOG := DialogTHndl(GetResource('DLOG', id));		if (theDLOG = nil) then			exit(CenterDialog);	{ Center it within screenBits }		bounds := theDLOG^^.boundsRect;		CenterRect(bounds);		theDLOG^^.boundsRect := bounds;	end;	procedure CenterPDialog (id: integer; var corner: Point);		var			theDLOG: DialogTHndl;			bounds: Rect;	begin	{ Get the DLOG resource }		theDLOG := DialogTHndl(GetResource('DLOG', id));		if (theDLOG = nil) then			exit(CenterPDialog);	{ Center it within screenBits }		bounds := theDLOG^^.boundsRect;		CenterRect(bounds);		theDLOG^^.boundsRect := bounds;		if (longint(corner) <> 0) then			corner := bounds.topLeft;	end;	procedure CenterAlert (id: integer);		var			theALRT: AlertTHndl;			bounds: Rect;	begin	{ Get the ALRT resource }		theALRT := AlertTHndl(GetResource('ALRT', id));		if (theALRT = nil) then			exit(CenterAlert);	{ Center it within screenBits }		bounds := theALRT^^.boundsRect;		CenterRect(bounds);		theALRT^^.boundsRect := bounds;	end;	function DoAlert (kind, alertID: integer; filterProc: ProcPtr): integer;		var			item: integer;	begin		CenterAlert(alertID);		InitCursor;		{ Equivalent to SetCursor(&arrow);}		case kind of			stopIcon: 				item := StopAlert(alertID, filterProc);			noteIcon: 				item := NoteAlert(alertID, filterProc);			cautionIcon: 				item := CautionAlert(alertID, filterProc);			otherwise				item := Alert(alertID, filterProc);		end;		DoAlert := item;	end;{More from the original posting (but don't blame him for errors I've introduced!):}{For dialogs, I call CenterDialog. It will optionally hand me back the top,left}{coordinate (handy for calls to SFGetFile, etc.). For alerts, I just call}{DoAlert, which will center it for me. Note that it adjusts for the menu bar}{but not for the title bar. This is because my method is used BEFORE calling}{GetNewDialog, as it tweaks the in-memory copy of the DLOG resource. There's}{no structure region to peek at at that time. If you're centering the window}{after its created, you could use the bounding box of the window's structure}{region, rather than its portRect. That would take care of the title bar as}{well as anything else.}{Have fun!}{Michael P. Hecht                 | Internet:  Michael_Hecht@mac.sas.com}{SAS Institute Inc.; Cary, NC USA | AppleLink: SAS.HECHT}end.