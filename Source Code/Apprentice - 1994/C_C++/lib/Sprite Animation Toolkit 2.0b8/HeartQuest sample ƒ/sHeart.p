{===============================================}{================= Heart sprite unit ================}{===============================================}{ Example file for Ingemars Sprite Animation Toolkit. }{ © Ingemar Ragnemalm 1992 }{ See doc files for legal terms for using this code. }unit sHeart;{ Sprite unit. A sprite unit should include the following routines:}{ Init-procedure, that initializes private bitmaps}{ Setup-procedure, that sets variables other than the standard ones set by MakeSprite }{ Handle-procedure, to be called once per iteration until the sprite dies }{ Hittask-procedure (optional), for advanced collission handling. }interface	uses		SAT, scores, sBonus, SoundConst, GameGlobals;	var		batchcount: integer; { Number of hearts left on level }	procedure InitHeart;	procedure SetupHeart (mp: SpritePtr);	procedure HandleHeart (me: SpritePtr);implementation	var		HeartFace: array[1..4] of FacePtr;		sofar: integer;	procedure InitHeart;		var			ii: integer;	begin		for ii := 1 to 4 do				HeartFace[ii] := GetFace(135 + ii);	end;	procedure SetupHeart (mp: SpritePtr);	begin		mp^.face := HeartFace[1];		mp^.mode := rand(4) + 1; { ikonnummer }		SetRect(mp^.hotRect, -5 + 16, -15 + 32, 5 + 16, -5 + 32);		mp^.speed.h := Rand(7) - 4;		mp^.speed.v := Rand(7) - 4;		sofar := 0;	end;	procedure HandleHeart (me: SpritePtr);		var			mp: SpritePtr;	begin		if me^.kind <> -2 then			begin				me^.task := nil;				addscore(10);				SATSoundPlay(PlinkSndH, 1, false);				batchcount := batchcount - 1;				sofar := sofar + 1;				if sofar mod 5 = 0 then					if rand(10) < 5 then						mp := NewSprite(-4, -31, Rand(gSAT.offSizeV - 64) + 32, @HandleBonus, @SetupBonus, nil)					else						mp := NewSprite(-4, gSAT.offSizeH, Rand(gSAT.offSizeV - 64) + 32, @HandleBonus, @SetupBonus, nil);			end;		me^.mode := me^.mode + 1;		if me^.mode = 5 then			me^.mode := 1;		me^.face := HeartFace[me^.mode];		me^.position.h := me^.position.h + me^.speed.h;		me^.position.v := me^.position.v + me^.speed.v;		if me^.position.h < 0 then			begin				me^.position.h := 0;				me^.speed.h := -me^.speed.h;				me^.speed.v := me^.speed.v + Rand(3) - 2;			end;		if me^.position.h > gSAT.offSizeH - xsize then			begin				me^.position.h := gSAT.offSizeH - xsize;				me^.speed.h := -me^.speed.h;				me^.speed.v := me^.speed.v + Rand(3) - 2;			end;		if me^.position.v < 0 then			begin				me^.position.v := 0;				me^.speed.v := -me^.speed.v;				me^.speed.h := me^.speed.h + Rand(3) - 2;			end;		if me^.position.v > gSAT.offSizeV - 32 then			begin				me^.position.v := gSAT.offSizeV - 32;				me^.speed.v := -me^.speed.v;				me^.speed.h := me^.speed.h + Rand(3) - 2;			end;{ It shouldn't be totally still! }		if (me^.speed.v = 0) and (me^.speed.h = 0) then			begin				me^.speed.h := Rand(7) - 4;				me^.speed.v := Rand(7) - 4;			end;	end;end.