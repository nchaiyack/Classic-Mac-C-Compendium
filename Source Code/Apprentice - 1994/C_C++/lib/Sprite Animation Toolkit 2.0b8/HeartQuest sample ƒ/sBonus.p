{===============================================}{================= Bonus sprite unit ================}{===============================================}{ Example file for Ingemars Sprite Animation Toolkit. }{ © Ingemar Ragnemalm 1992 }{ See doc files for legal terms for using this code. }unit sBonus;{ Sprite unit. A sprite unit should include the following routines:}{ Init-procedure, that initializes private bitmaps}{ Setup-procedure, that sets variables other than the standard ones set by MakeSprite }{ Handle-procedure, to be called once per iteration until the sprite dies }{ Hittask-procedure (optional), for advanced collission handling. }interface	uses		SAT, sPoints, scores, SoundConst, GameGlobals;	procedure InitBonus;	procedure SetupBonus (mp: SpritePtr);	procedure HandleBonus (me: SpritePtr);implementation	var		BonusFace: array[1..3] of FacePtr;	procedure InitBonus;		var			ii: integer;			h: handle;	begin		for ii := 1 to 3 do			begin				BonusFace[ii] := GetFace(127 + ii);			end;	end;	procedure SetupBonus (mp: SpritePtr);		var			i: integer;	begin		i := rand(3) + 1;		mp^.face := BonusFace[i];{mp^.mask := Bonusmask[i];}		if mp^.position.h < 300 then			mp^.speed.h := 5		else			mp^.speed.h := -5;		SetRect(mp^.hotRect, -13 + 16, -28 + 32, 13 + 16, 0 + 32);	end;	procedure HandleBonus (me: SpritePtr);		var			mp: Spriteptr;	begin		if me^.kind <> -4 then			begin				me^.task := nil; { Caught by the player! }				addscore(50);				mp := NewSprite(0, me^.position.h, me^.position.v, @HandlePoints, @SetupPoints, nil);				SATSoundPlay(jaSndH, 5, true);			end;		me^.mode := me^.mode + 1;		me^.position.h := me^.position.h + me^.speed.h;		if me^.position.h > gSAT.offSizeH then			me^.task := nil;		if me^.position.h < -32 then			me^.task := nil;	end;end.