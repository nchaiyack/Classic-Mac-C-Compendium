unit FaceFromPICT;interface	uses		SAT; {SATGlobals, DisposeOffscreen, Offscreen;{SAT}	function GetFaceFromPICT (colorPICTid, bwPICTid, maskPICTid: integer): FacePtr;implementation{No error checking yet!}	function GetFaceFromPICT (colorPICTid, bwPICTid, maskPICTid: integer): FacePtr;		var			bounds: Rect;			thePICT, maskPICT: PicHandle;			theFace: FacePtr;			savePort: GrafPtr;			saveGD: GDhandle;	begin		GetPort(savePort);		if colorFlag then			saveGD := GetGDevice;{Get PICTs}{IDEA: It should really check if the PICT it loads was loaded already, and if it was, don't dispose it.}		if gSAT.initDepth > 1 then			thePICT := GetPicture(colorPICTid)		else			thePICT := GetPicture(bwPICTid);		maskPICT := GetPicture(maskPICTid);		bounds := thePICT^^.picFrame;		OffsetRect(bounds, -bounds.left, -bounds.top); {onšdigt fšr det gšr NewFace Œt oss.}		if (thePICT = nil) or (maskPICT = nil) then			begin				GetFaceFromPICT := nil;				exit(GetFaceFromPICT);			end;{Create face}		theFace := NewFace(bounds);{Draw in the face}		SetPortFace(theFace);		DrawPicture(thePICT, bounds);{FrameRect(bounds); {DEBUG-rektangel}		SetPortMask(theFace);		DrawPicture(maskPICT, bounds);{FrameRect(bounds); {DEBUG-rektangel}{Tell SAT that we are done}		ChangedFace(theFace);{Get rid of the PICTs}		ReleaseResource(Handle(thePICT));		ReleaseResource(Handle(maskPICT));{Return the face.}		GetFaceFromPICT := theFace;		if colorFlag then			SetGDevice(saveGD);		SetPort(savePort);	end;end.