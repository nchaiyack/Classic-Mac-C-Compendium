{ Platform sprite, horizontally moving version (not faceless) }unit sHMovPlatForm;interface	uses		SAT, sPlatForm, sMovPlatForm;	procedure InitHMovPlatForm;	procedure SetupHMovPlatForm (me: SpritePtr);	procedure HandleHMovPlatForm (me: SpritePtr);	procedure HitHMovPlatForm (me, him: SpritePtr);implementation	procedure InitHMovPlatForm;		var			i: integer;	begin{platFace := GetFace(138); same as vertically moving version, we use the same!}	end;	procedure SetupHMovPlatForm (me: SpritePtr);		var			r: Rect;			pol: PolyHandle;	begin		me^.speed.h := -1 + Rand(2) * 2;		me^.kind := -2; {Enemy kind}		me^.face := platFace;		SetRect(me^.hotRect, 0, 3, 60, 20);	end;	procedure HandleHMovPlatForm (me: SpritePtr);	begin		me^.position.h := me^.position.h + me^.speed.h;		if me^.position.h < 40 then			me^.speed.h := 1;		if me^.position.h > gSAT.offSizeH - 100 then			me^.speed.h := -1;{Move!}		if me^.speed.h = 0 then			if me^.position.h > gSAT.offSizeH div 2 then				me^.speed.h := -1			else				me^.speed.h := 1;		me^.layer := -me^.position.v;	end;	procedure HitHMovPlatForm;		var			mini, i, min: integer;			diff: array[1..4] of integer;	begin		if him^.Task <> @HandlePlatForm then  {check for HandleMovPlatForm too?}			begin				diff[1] := -me^.hotRect2.top + (him^.hotRect2.bottom);{TtoB}				diff[2] := -him^.hotRect2.top + (me^.hotRect2.bottom);{BtoT}				diff[3] := -me^.hotRect2.left + (him^.hotRect2.right);{LtoR}				diff[4] := -him^.hotRect2.left + (me^.hotRect2.right);{RtoL}				mini := 0;				min := 10000;				for i := 1 to 4 do					if min > diff[i] then						begin							min := diff[i];							mini := i;						end;				case mini of					1: {floor}						begin							him^.position.v := him^.position.v - diff[1] + 1;							him^.position.h := him^.position.h + me^.speed.h; {or perhaps him^speed?}							him^.kind := 10; {Signal to him, as if we used KindCollision}							if him^.speed.v > 0 then								him^.speed.v := 0;						end;					2: {cieling}						begin							him^.position.v := him^.position.v + diff[2] + 1;{me^.position.v + 17}{No signal here}							if him^.speed.v < 0 then								him^.speed.v := -him^.speed.v;						end;					3: {left}						begin							him^.position.h := him^.position.h - diff[3] - 1;							him^.kind := 10; {Signal to him, as if we used KindCollision}							if him^.speed.h > 0 then								him^.speed.h := -him^.speed.h;						end;					4: {right}						begin							him^.position.h := him^.position.h + diff[4] + 1;{me^.position.h + 100}							him^.kind := 10; {Signal to him, as if we used KindCollision}							if him^.speed.h < 0 then								him^.speed.h := -him^.speed.h;						end;				end;{case}			end; {if}	end; {HitHMovPlatForm}end.{of unit}