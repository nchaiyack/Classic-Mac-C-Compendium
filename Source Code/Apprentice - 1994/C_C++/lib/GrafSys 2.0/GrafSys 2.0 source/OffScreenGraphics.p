unit OffScreenGraphics;interface	uses		Matrix, OffScreenCore, GrafSysCore, GrafSysScreen;	const		cBitDepth = 8; (* Standard bit-depth for all offscreen devices GrafSys uses *)		cMaxBitDepth = 8;		cStdColorCLUT = 72;	var		currOSPixMap: PixMapHandle;	function AttachOffScreen (theWindow: WindowPtr; theColors: CTabHandle): integer; (* attach OS port to window *)(* pass CTabHandle(-1) to use window's CLUT or CTabHandle(-2) as parameter if you want standard color CLUT *)	function ChangeOffscreen (theWindow: WindowPtr; theColors: CTabHandle): integer; (* make OS port the same as the window *)(* pass CTabHandle(-1) as parameter if no change to CLUT *)	function CloseOffscreen (theWindow: WindowPtr): integer; (* dispose OS port *)	function BeginOSDraw (theWindow: WindowPtr): integer; (* begin drawing to Off-Screen *)	function EndOSDraw (theWindow: WindowPtr): integer; (* end drawing to Off-Screen *)	function CopyOS2Screen (theWindow: WindowPtr; theRect: Rect; copyMode: Integer): integer; (* copy offscreen to screen *)implementation	function AttachOffScreen (theWindow: WindowPtr; theColors: CTabHandle): integer; (* attach OS port to window *)		var			the3DWindow: TPort3DPtr;			theErr: Integer;	begin		if not is3DPort(theWindow) then			begin				AttachOffScreen := cNo3DWindow;				Exit(AttachOffScreen);			end;		the3DWindow := TPort3DPtr(theWindow); (* convert it to this pointer type *)     (* get color information *)		if theColors = CTabHandle(-2) then (* get standard 256 color CLUT *)			theColors := GetCTable(cStdColorCLUT)		else if theColors = CTabHandle(-1) then (* use window's curently active color table *)			begin				if CGrafPtr(theWindow)^.portPixMap^^.pixelSize > cMaxBitDepth then (* Can only use 1-8 bits/pixel CLUT. Check it *)					begin						AttachOffScreen := cCantUseWindowCLUT;						Exit(AttachOffScreen);					end;				theColors := CGrafPtr(theWindow)^.portPixMap^^.pmTable;			end;		the3DWindow^.theOffscreen.theColors := theColors;		theErr := CreateOffScreen(theWindow^.portRect, cBitDepth, theColors, the3DWindow^.theOffscreen.thePort, the3DWindow^.theOffscreen.theDevice);		if theErr <> noErr then			AttachOffscreen := cCantCreateOffscreen		else			AttachOffscreen := noErr;	end;	function ChangeOffscreen (theWindow: WindowPtr; theColors: CTabHandle): integer; (* make OS port the same as the window *)		var			the3DWindow: TPort3DPtr;			theErr: Integer;	begin		if not is3DPort(theWindow) then			begin				ChangeOffscreen := cNo3DWindow;				Exit(ChangeOffscreen);			end;		the3DWindow := TPort3DPtr(theWindow);		if theColors = CTabHandle(-1) then			theColors := the3DWindow^.theOffscreen.theColors;		the3DWindow^.theOffscreen.theColors := theColors; (* save for later references *)		theErr := UpdateOffScreen(theWindow^.portRect, cBitDepth, theColors, the3DWindow^.theOffscreen.thePort, the3DWindow^.theOffscreen.theDevice);		if theErr <> noErr then			ChangeOffscreen := cCantChangeOffscreen		else			ChangeOffscreen := noErr;	end;	function CloseOffscreen (theWindow: WindowPtr): integer; (* dispose OS port *)		var			the3DWindow: TPort3DPtr;	begin		if not is3DPort(theWindow) then			begin				CloseOffscreen := cNo3DWindow;				Exit(CloseOffscreen);			end;		the3DWindow := TPort3DPtr(theWindow);		if the3DWindow^.theOffscreen.thePort <> nil then			DisposeOffScreen(the3DWindow^.theOffscreen.thePort, the3DWindow^.theOffscreen.theDevice);		CloseOffscreen := noErr;	end;	function BeginOSDraw (theWindow: WindowPtr): integer; (* begin drawing to Off-Screen *)		var			the3DWindow: TPort3DPtr;	begin		if not is3DPort(theWindow) then			begin				BeginOSDraw := cNo3DWindow;				Exit(BeginOSDraw);			end;		the3DWindow := TPort3DPtr(theWindow);		if the3DWindow^.theOffscreen.thePort = nil then			begin				BeginOSDraw := cNoOSAttached;				Exit(BeginOSDraw);			end;		the3DWindow^.theOffscreen.mainDevice := GetGDevice;		SetPort(GrafPtr(the3DWindow^.theOffscreen.thePort));		SetGDevice(the3DWindow^.theOffscreen.theDevice);		currOSPixMap := the3DWindow^.theOffScreen.thePort^.portPixMap;		BeginOSDraw := noErr;	end;	function EndOSDraw (theWindow: WindowPtr): integer; (* end drawing to Off-Screen *)		var			the3DWindow: TPort3DPtr;	begin		if not is3DPort(theWindow) then			begin				EndOSDraw := cNo3DWindow;				Exit(EndOSDraw);			end;		the3DWindow := TPort3DPtr(theWindow);		SetPort(theWindow);		SetGDevice(the3DWindow^.theOffscreen.mainDevice);		currOSPixMap := nil;		EndOSDraw := noErr;	end;	function CopyOS2Screen (theWindow: WindowPtr; theRect: Rect; copyMode: Integer): integer; (* copy offscreen to screen *)		var			the3DWindow: TPort3DPtr;	begin		if not is3DPort(theWindow) then			begin				CopyOS2Screen := cNo3DWindow;				Exit(CopyOS2Screen);			end;		the3DWindow := TPort3DPtr(theWindow);		if the3DWindow^.theOffscreen.thePort = nil then			begin				CopyOS2Screen := cNoOSAttached;				Exit(CopyOS2Screen);			end;		CopyBits(GrafPtr(the3DWindow^.theOffscreen.thePort)^.portBits, theWindow^.portBits, theRect, theRect, copyMode, nil);		CopyOS2Screen := noErr;	end;end.