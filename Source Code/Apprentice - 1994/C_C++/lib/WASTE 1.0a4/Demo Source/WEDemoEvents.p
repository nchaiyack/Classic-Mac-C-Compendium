unit DemoEvents;{ WASTE DEMO PROJECT: }{ Events Handling }{ Copyright © 1993-1994 Merzwaren }{ All Rights Reserved }interface	uses		DemoIntf;	function InitializeEvents: OSErr;	procedure DoWindowEvent (var event: EventRecord);	procedure ProcessEvent;implementation	uses		AppleEvents, DemoMenus, DemoWindows;	const{ possible values for OPEN_DOC_HANDLER refCon parameter }		kDoOpen = 0;		kDoPrint = 1;	var		gSleepTime: LongInt;					{ sleep time for WaitNextEvent }		gMouseRgn: RgnHandle;				{ mouse region for WaitNextEvent }	procedure AdjustCursor (mouseLoc: Point;									mouseRgn: RgnHandle);		var			window: WindowPtr;	begin{ by default, set mouseRgn to the whole QuickDraw coordinate plane, }{ so that we never get mouse moved events }		SetRectRgn(mouseRgn, -maxint, -maxint, maxint, maxint);{ give text services a chance to set the cursor shape }		if (gHasTextServices) then			if (SetTSMCursor(mouseLoc)) then				Exit(AdjustCursor);{ if there is a window open, give WEAdjustCursor an opportunity to set the cursor }{ WEAdjustCursor intersects mouseRgn (if supplied) with a region within which }{ the cursor is to retain its shape. }{ (if the cursor is outside the view region, this is subtracted from mouseRgn) }		window := FrontWindow;		if (window <> nil) then			if (WEAdjustCursor(mouseLoc, mouseRgn, DocumentPeek(window)^.hWE)) then				Exit(AdjustCursor);{ set the cursor to the arrow cursor }		SetCursor(arrow);	end;  { AdjustCursor }	procedure WindowClick (var event: EventRecord;									window: WindowPtr;									partCode: Integer);	begin{ dispatch on part code }		case partCode of			inContent: 				if (FrontWindow <> window) then					SelectWindow(window)				else					DoContent(event.where, event, window);			inDrag: 				DoDrag(event.where, window);			inGrow: 				DoGrow(event.where, window);			inGoAway: 				if (TrackGoAway(window, event.where)) then					DestroyWindow(window);			inZoomIn, inZoomOut: 				if (TrackBox(window, event.where, partCode)) then					DoZoom(partCode, window);			otherwise				;		end;  { case partCode }	end;  { WindowClick }	procedure DoMouseDown (var event: EventRecord);		var			window: WindowPtr;			partCode: Integer;	begin		partCode := FindWindow(event.where, window);		case partCode of			inDesk: 				;			inMenuBar: 				begin					PrepareMenus;					DoMenuChoice(MenuSelect(event.where));				end;			inSysWindow: 				SystemClick(event, window);			otherwise				WindowClick(event, window, partCode);		end;  { case partCode }	end;  { DoMouseDown }	procedure DoKeyDown (var event: EventRecord);	begin		if (BitAnd(event.modifiers, cmdKey) <> 0) then			begin				PrepareMenus;				DoMenuChoice(MenuKey(Char(BAND(event.message, charCodeMask))));			end		else			DoKey(Char(BAND(event.message, charCodeMask)), event);	end;  { DoKeyDown }	procedure DoDiskEvent (var event: EventRecord);		var			dialogCorner: Point;			err: OSErr;	begin		if (BSR(event.message, 16) <> noErr) then			begin				SetPt(dialogCorner, 112, 80);				err := DIBadMount(dialogCorner, event.message);			end;	end;  { DoDiskEvent }	procedure DoOSEvent (var event: EventRecord);		var			osMessage: Integer;			window: WindowPtr;	begin{ extract the OS message field from the event record }		osMessage := BSR(BAND(event.message, osEvtMessageMask), 24);{ dispatch on osMessage }		case osMessage of			suspendResumeMessage: 				begin					window := FrontWindow;					if (window <> nil) then						DoActivate(BAND(event.message, resumeFlag) <> 0, window);				end;			mouseMovedMessage: 				;			otherwise				;		end;  { case }	end;  { DoOSEvent }	procedure DoHighLevelEvent (var event: EventRecord);		var			err: OSErr;	begin		err := AEProcessAppleEvent(event);	end;  { DoHighLevelEvent }	procedure DoNullEvent (var event: EventRecord);		var			window: WindowPtr;	begin		window := FrontWindow;		if (window <> nil) then			WEIdle(gSleepTime, DocumentPeek(window)^.hWE)		else			gSleepTime := maxLongInt;	end;  { DoNullEvent }	procedure DoWindowEvent (var event: EventRecord);		var			window: WindowPtr;	begin{ the message field of the event record contains the window pointer }		window := WindowPtr(event.message);{ make sure this window is an application window; check the windowKind field }		if (WindowPeek(window)^.windowKind <> userKind) then			Exit(DoWindowEvent);		case event.what of			updateEvt: 				DoUpdate(window);			activateEvt: 				DoActivate(BitAnd(event.modifiers, activeFlag) <> 0, window);		end;  { case }	end;  { DoWindowEvent }	procedure ProcessEvent;		var			event: EventRecord;			gotEvent: Boolean;	begin		gotEvent := WaitNextEvent(everyEvent, event, gSleepTime, gMouseRgn);{ give text services a chance to intercept this event }		if (gHasTextServices) then			if TSMEvent(event) then				;{ adjust cursor shape and set mouse region }{ (we assume event.where is the current mouse position in global coordinates }{ if event.what <= osEvt; high-level events store the event ID there) }		if (event.what <= osEvt) then			AdjustCursor(event.where, gMouseRgn);{ dispatch on event.what }		case event.what of			nullEvent: 				DoNullEvent(event);			mouseDown: 				DoMouseDown(event);			keyDown, autoKey: 				DoKeyDown(event);			updateEvt, activateEvt: 				DoWindowEvent(event);			diskEvt: 				DoDiskEvent(event);			osEvt: 				DoOSEvent(event);			kHighLevelEvent: 				DoHighLevelEvent(event);			otherwise				;											{ ignore other events }		end;  { case }		if (gotEvent) then			gSleepTime := 0;						{ force early idle after non-idle event }	end;  { ProcessEvent }	function GotRequiredParams (ae: AppleEvent): OSErr;		var			returnedType: DescType;			actualSize: Size;			err: OSErr;	begin		err := AEGetAttributePtr(ae, keyMissedKeywordAttr, typeWildCard, returnedType, nil, 0, actualSize);		if (err = errAEDescNotFound) then			GotRequiredParams := noErr		else if (err = noErr) then			GotRequiredParams := errAEEventNotHandled		else			GotRequiredParams := err;	end;  { GotRequiredParams }	function OPEN_DOC_HANDLER (ae, reply: AppleEvent;									refCon: LongInt): OSErr;		var			docList: AEDescList;			keyword: AEKeyword;			returnedType: DescType;			actualSize: Size;			numberOfDocuments, i: LongInt;			fileSpec: FSSpec;		procedure CheckErr (err: OSErr);		begin			if (err <> noErr) then				begin					OPEN_DOC_HANDLER := err;					err := AEDisposeDesc(docList);					Exit(OPEN_DOC_HANDLER);				end;		end;  { CheckErr }	begin		OPEN_DOC_HANDLER := noErr;{ extract direct parameter from the Apple Event }		CheckErr(AEGetParamDesc(ae, keyDirectObject, typeAEList, docList));{ perform the recommended check for additional required parameters }		CheckErr(GotRequiredParams(ae));{ count the items in the list of aliases }		CheckErr(AECountItems(docList, numberOfDocuments));		for i := 1 to numberOfDocuments do			begin{ coerce the nth alias to a file system specification record }				CheckErr(AEGetNthPtr(docList, i, typeFSS, keyword, returnedType, @fileSpec, SizeOf(fileSpec), actualSize));{ open the specified file }				CheckErr(CreateWindow(@fileSpec));			end;  { for }{ dispose of the alias list }		CheckErr(AEDisposeDesc(docList));	end;  { OPEN_DOC_HANDLER }	function OPEN_APP_HANDLER (ae, reply: AppleEvent;									refCon: LongInt): OSErr;		var			err: OSErr;	begin{ perform the recommended check for additional required parameters }		err := GotRequiredParams(ae);		if (err <> noErr) then			begin				OPEN_APP_HANDLER := err;				Exit(OPEN_APP_HANDLER);			end;{ create a new window from scratch }		OPEN_APP_HANDLER := CreateWindow(nil);	end;  { OPEN_APP_HANDLER }	function QUIT_APP_HANDLER (ae, reply: AppleEvent;									refCon: LongInt): OSErr;		var			err: OSErr;	begin{ perform the recommended check for additional required parameters }		err := GotRequiredParams(ae);		if (err <> noErr) then			begin				QUIT_APP_HANDLER := err;				Exit(QUIT_APP_HANDLER);			end;		gExiting := true;	end;  { QUIT_APP_HANDLER }	function InitializeEvents: OSErr;		procedure CheckErr (err: OSErr);		begin			if (err <> noErr) then				begin					InitializeEvents := err;					Exit(InitializeEvents);				end;		end;  { CheckErr }	begin		InitializeEvents := noErr;{ allocate space for the mouse region }		gMouseRgn := NewRgn;{ install Apple Event handlers for the Required Suite }		CheckErr(AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, @OPEN_APP_HANDLER, 0, false));		CheckErr(AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, @OPEN_DOC_HANDLER, kDoOpen, false));		CheckErr(AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, @OPEN_DOC_HANDLER, kDoPrint, false));		CheckErr(AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, @QUIT_APP_HANDLER, 0, false));{ install Apple Event handlers for Inline Input }		CheckErr(WEInstallTSMHandlers);	end;  { InitializeEvents }end.