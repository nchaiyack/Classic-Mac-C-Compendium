unit WASTEIntf;{ WASTE PROJECT: }{ Internal interface: constants, types and inline code }{ Copyright © 1993-1994 Marco Piovanelli }{ All Rights Reserved }interface	uses		LongCoords;	const{ alignment styles }		weFlushLeft = -2;		weFlushRight = -1;		weFlushDefault = 0;		weCenter = 1;		weJustify = 2;{ values for the edge parameter }		kLeadingEdge = -1;		kTrailingEdge = 0;{ control character codes }		kBackspace = 8;		kEOL = 13;		kArrowLeft = 28;		kArrowRight = 29;		kArrowUp = 30;		kArrowDown = 31;{ bit equates for QuickDraw styles }		tsBold = 0;		tsItalic = 1;		tsUnderline = 2;		tsOutline = 3;		tsShadow = 4;		tsCondense = 5;		tsExtend = 6;{ bit equates for the tsFlags field of the WETextStyle record }		tsTSMHilite = 4;							{ set if style run is part of active input area }		tsTSMSelected = 5;						{ set for selected raw/converted text }		tsTSMConverted = 6;						{ set for converted text, clear for raw text }		tsRightToLeft = 7;							{ reserved for future use }{ bit equates for the mode parameter in WESetStyle and WEContinuousStyle }		kModeFont = 0;		kModeFace = 1;		kModeSize = 2;		kModeColor = 3;		kModeAddSize = 4;		kModeToggleFace = 5;		kModeReplaceFace = 6;		kModeFlags = 15;{ values for the mode parameter in WESetStyle and WEContinuousStyle }		weDoFont = $0001;		weDoFace = $0002;		weDoSize = $0004;		weDoColor = $0008;		weDoAll = weDoFont + weDoFace + weDoSize + weDoColor;		weDoAddSize = $0010;		weDoToggleFace = $0020;		weDoReplaceFace = $0040;		weDoFlags = $8000;{ values for WEFeatureFlag action parameter }		weBitClear = 0;								{ disables the specified feature }		weBitSet = 1;								{ enables the specified feature }		weBitTest = -1;								{ returns the current setting of the specified feature }{ bit equates for the flags field in the WE record }{ bits 0..15 can be used to turn on and off specific features with WEFeatureFlag }{ bits 16..31 are used internally and should not be modified }{ private flags }		weFHasColorQD = 31;					{ Color QuickDraw is available }		weFHasTextServices = 30;				{ Text Services Manager is available }		weFNonRoman = 29;						{ at least one non-Roman script is enabled }		weFDoubleByte = 28;					{ a double-byte script is installed }		weFBidirectional = 27;					{ reserved for future use }		weFUseDualCaret = 26;					{ reserved for future use }		weFCaretVisible = 24;					{ the caret is currently visible }		weFMouseTracking = 23;				{ set internally during mouse tracking }		weFAnchorIsEnd = 22;					{ anchor offset is selEnd }		weFUseNullStyle = 21;					{ a null style is associated with the empty selection }		weFActive = 20;							{ we're active }{ public flags }		weFDrawOffscreen = 11;				{ draw text offscreen for smoother visual results }		weFUseTempMem = 10;				{ use temporary memory for main data structures }		weFInhibitRecal = 9;						{ if set, recals and redraws are inhibited }		weFDragAndDrop = 8;					{ reserved for future use }		weFIntCutAndPaste = 7;				{ reserved for future use }		weFOutlineHilite = 2;					{ frame selection range when text pane is inactive }		weFAutoScroll = 0;						{ automatically scroll text when cursor is outside pane }{ masks for setting the feature bits }		weDoAutoScroll = $0001;				{ 1 << weFAutoScroll }		weDoOutlineHilite = $0004;			{ 1 << weFOutlineHilite }		weDoIntCutAndPaste = $0080;		{ 1 << weFIntCutAndPaste }		weDoDragAndDrop = $0100;			{ 1 << weFDragAndDrop }		weDoInhibitRecal = $0200;			{ 1 << weFInhibitRecal }		weDoUseTempMem = $0400;		{ 1 << weFUseTempMem }		weDoDrawOffscreen = $0800;		{ 1 << weFDrawOffscreen }{ scrap types }		kTypeText = 'TEXT';		kTypeStyles = 'styl';{ selectors for WEGetInfo/WESetInfo }		weClickLoop = 'clik';		weLineArray = 'line';		wePort = 'port';		weRefCon = 'refc';		weRunArray = 'runa';		weScrollProc = 'scrl';		weStyleTable = 'styl';		weText = 'text';		weTSMDocumentID = 'tsmd';		weTSMPostUpdate = 'post';		weTSMPreUpdate = 'pre ';{ values for WEAllocate allocFlags parameter }		kAllocClear = $0001;						{ clear handle after allocation }		kAllocTemp = $0002;					{ use temporary memory if available }{ other miscellaneous constants }		kMinFontSize = 1;							{ minimum valid font size }		kMaxFontSize = maxint;				{ maximum valid font size }		kOneToOneScaling = $00010001;	{ 1:1 scaling ratio }	type		WEChars = packed array[0..999999] of Char;		WECharsPtr = ^WEChars;		WECharsHandle = ^WECharsPtr;{ WETextStyle is just a familiar TextStyle record as defined by TextEdit, where }{ tsFace is redefined as SignedByte (rather than Style) so that the filler byte }{ becomes "visible" from Pascal and can be used to store internal flags }		WETextStyle = record				tsFont: Integer;						{ font family ID }				tsFace: SignedByte;				{ QuickDraw style attributes }				tsFlags: SignedByte;				{ flags (for internal use only) }				tsSize: Integer;						{ point size }				tsColor: RGBColor;					{ absolute red-green-blue color }			end;  { WETextStyle }		WETextStylePtr = ^WETextStyle;		WERunAttributes = record				runHeight: Integer;				{ run height (ascent + descent + leading) }				runAscent: Integer;				{ font ascent }				case Integer of					0: (							tsFont: Integer;							tsFace: SignedByte;							tsFlags: SignedByte;							tsSize: Integer;							tsColor: RGBColor;					);					1: (							runStyle: WETextStyle;					);			end;  { WERunAttributes }		WERunAttributesPtr = ^WERunAttributes;		WERunInfo = record				runStart: LongInt;				runEnd: LongInt;				runAttrs: WERunAttributes;			end;  { WERunInfo }		WERunInfoPtr = ^WERunInfo;		WEStyleScrapElement = record				scrpStartChar: LongInt;				scrpAttrs: WERunAttributes;			end;  { WEStyleScrapElement }		WEStyleScrapElementPtr = ^WEStyleScrapElement;		WEStyleScrapElementHandle = ^WEStyleScrapElementPtr;{ another "view" for the familiar TextEdit 'styl' Clipboard type }		WEStyleScrap = record				scrpNStyles: Integer;				scrpStyleTab: array[0..0] of WEStyleScrapElement;			end;  { WEStyleScrap }		WEStyleScrapPtr = ^WEStyleScrap;		WEStyleScrapHandle = ^WEStyleScrapPtr;{ the purpose of the GrafPort1 declaration is to redefine the txFace field as SignedByte, }{ rather than Style ( = set of StyleItem), to avoid using THINK Pascal runtime routines }{ for set manipulation }		GrafPort1 = record				device: Integer;				portBits: BitMap;				portRect: Rect;				visRgn: RgnHandle;				clipRgn: RgnHandle;				bkPat: Pattern;				fillPat: Pattern;				pnLoc: Point;				pnSize: Point;				pnMode: Integer;				pnPat: Pattern;				pnVis: Integer;				txFont: Integer;				txFace: SignedByte;				filler: SignedByte;				txMode: Integer;				txSize: Integer;				spExtra: Fixed;				fgColor: LongInt;				bkColor: LongInt;				colrBit: Integer;				patStretch: Integer;				picSave: Handle;				rgnSave: Handle;				polySave: Handle;				grafProcs: QDProcsPtr;			end;  { GrafPort1 }		GrafPtr1 = ^GrafPort1;		QDEnvironment = record				envPort: GrafPtr;				envPen: PenState;				envStyle: WETextStyle;				envMode: Integer;			end;  { QDEnvironment }		WEStyleScrapPair = record				first: WEStyleScrapElement;				second: WEStyleScrapElement;			end;  { WEStyleScrapPair }		WEStyleScrapPeek = ^WEStyleScrapPair;		RunArrayElement = record				runStart: LongInt;						{ offset to first character in style run }				styleIndex: LongInt;					{ index into style table (high word currently unused) }			end;  { RunArrayElement }		RunArrayElementPtr = ^RunArrayElement;		RunArrayElementHandle = ^RunArrayElementPtr;		RunArrayPair = record				first: RunArrayElement;				second: RunArrayElement;			end;  { RunArrayPair }		RunArrayPeek = ^RunArrayPair;	{ useful to "peek" at a portion of the run array }	const		kRunArrayMaxIndex = (maxLongInt div SizeOf(RunArrayElement)) - 1;	type		RunArray = array[0..kRunArrayMaxIndex] of RunArrayElement;		RunArrayPtr = ^RunArray;		RunArrayHandle = ^RunArrayPtr;		StyleTableElement = record				refCount: LongInt;					{ reference count }				info: WERunAttributes;				{ style information }			end;  { StyleTableElement }		StyleTableElementPtr = ^StyleTableElement;		StyleTableElementHandle = ^StyleTableElementPtr;	const		kStyleTableMaxIndex = (maxint div SizeOf(StyleTableElement)) - 1;	type		StyleTable = array[0..kStyleTableMaxIndex] of StyleTableElement;		StyleTablePtr = ^StyleTable;		StyleTableHandle = ^StyleTablePtr;		LineRec = record				lineStart: LongInt;					{ offset to first character in line }				lineOrigin: LongInt;					{ distance from destRect.top, in pixels }				lineAscent: Integer;					{ maximum font ascent for this line, in pixels }				lineSlop: Integer;						{ extra pixels needed to fill up the line }				lineJustAmount: Fixed;				{ normalized slop value for justification }			end;  { LineRec }		LinePtr = ^LineRec;		LineHandle = ^LinePtr;		LinePair = record				first: LineRec;				second: LineRec;			end;  { LinePair }		LinePeek = ^LinePair;					{ useful to "peek" at a portion of the line array }	const		kLineArrayMaxIndex = (maxLongInt div SizeOf(LineRec)) - 1;	type		LineArray = array[0..kLineArrayMaxIndex] of LineRec;		LineArrayPtr = ^LineArray;		LineArrayHandle = ^LineArrayPtr;		WERec = record				port: GrafPtr;								{ graphics port }				hText: Handle;								{ handle to the raw text }				hLines: LineArrayHandle;				{ handle to the line array }				hStyles: StyleTableHandle;			{ handle to the style table }				hRuns: RunArrayHandle;				{ handle to the style run array }				textLength: LongInt;						{ length of raw text block }				nLines: LongInt;							{ number of lines }				nStyles: LongInt;							{ number of distinct styles in the style table }				nRuns: LongInt;							{ number of style runs in the style run array }				viewRect: LongRect;						{ view rectangle }				destRect: LongRect;						{ destination rectangle }				selStart: LongInt;							{ start of selection range }				selEnd: LongInt;							{ end of selection range }				flags: LongInt;								{ 32 bits of miscellaneous flags }				caretTime: LongInt;						{ time of most recent caret xoring }				clickTime: LongInt;						{ time of most recent click }				clickLoc: LongInt;							{ byte offset of most recent click }				anchorStart: LongInt;					{ anchor word start }				anchorEnd: LongInt;						{ anchor word end }				clickLoop: ProcPtr;						{ click loop callback }				unused1: SignedByte;					{ unused }				clickEdge: SignedByte;					{ edge of character hit by most recent click }				unused2: SignedByte;					{ unused }				firstByte: SignedByte;					{ first byte of a double-byte character }				offscreenPort: GrafPtr;					{ offscreen graphics world }				viewRgn: RgnHandle;					{ handle to the view region }				scrollProc: ProcPtr;						{ scroll callback }				clickCount: Integer;						{ multiple click count }				alignment: Integer;						{ alignment style }				refCon: LongInt;							{ reference value for client use }				tsmReference: Ptr;						{ Text Services Manager document ID }				tsmAreaStart: LongInt;					{ start of active inline input area }				tsmAreaEnd: LongInt;					{ end of active inline input area }				tsmPreUpdate: ProcPtr;				{ called before handling a TSM updt event }				tsmPostUpdate: ProcPtr;				{ called after handling a TSM updt event }				nullStyle: WERunAttributes;			{ style for null selection }			end;  { WERec }		WEPtr = ^WERec;		WEHandle = ^WEPtr;{ ****** ASSEMBLY ROUTINES DEFINED IN WASTEUTILS.LIB ****** }	procedure _WEForgetHandle (var h: univ Handle);	function _WESetHandleLock (h: univ Handle;									lock: Boolean): Boolean;	procedure _WEBlockClr (blockPtr: Ptr;									blockSize: LongInt);	function _WEBlockCmp (block1, block2: Ptr;									blockSize: LongInt): Boolean;	function _WEInsertSlot (h: univ Handle;									element: univ Ptr;									insertAt: LongInt;									slotSize: LongInt): OSErr;	function _WERemoveSlot (h: univ Handle;									removeAt: LongInt;									slotSize: LongInt): OSErr;	procedure _WEReorder (var a, b: LongInt);{ ****** USEFUL INLINE ASSEMBLY ****** }	function %_NewHandle (blockSize: Size;									var h: Handle): OSErr;	inline		$225F,								{ movea.l (sp)+, a1 }		$201F,								{ move.l (sp)+, d0 }		$A122,								{ _NewHandle }		$3E80, 								{ move.w d0, (sp) }		$2288;								{ move.l a0, (a1) }	function %_GetHandleSize (h: univ Handle): Size;	inline		$205F, 								{ movea.l (sp)+, a0 }		$A025, 							{ _GetHandleSize }		$2E80, 								{ move.l d0, (sp) }		$6A02, 							{ bpl.s *+4 }		$4297;								{ clr.l (sp) }	function %_SetHandleSize (h: univ Handle;									blockSize: Size): OSErr;	inline		$201F, 								{ move.l (sp)+, d0 }		$205F,								{ movea.l (sp)+, a0 }		$A024, 							{ _SetHandleSize }		$3E80;								{ move.w d0, (sp) }	procedure %_BlockMoveData (sourcePtr, destPtr: univ Ptr;									byteCount: LongInt);	inline		$201F, 								{ move.l (sp)+, d0 }		$225F, 								{ movea.l (sp)+, a1 }		$205F, 								{ movea.l (sp)+, d0 }		$A22E;								{ _BlockMove, IMMED }	procedure %_TextFace (face: Integer);	inline		$A888;								{ _TextFace }	function %_Gestalt (selector: OSType;									var response: LongInt): OSErr;	inline		$225F, 								{ movea.l (sp)+, a1 }		$201F, 								{ move.l (sp)+, d0 }		$A1AD, 							{ _Gestalt }		$3E80, 								{ move.w d0, (sp) }		$2288;								{ move.l a0, (a1) }	procedure IgnoreBoolean (b: Boolean);	inline		$544F;								{ addq.w #2, sp }	procedure IgnoreShort (w: Integer);	inline		$544F;								{ addq.w #2, sp }	procedure IgnoreLong (l: LongInt);	inline		$584F;								{ addq.w #4, sp }implementationend.