unit RequiredEventSupport;interface	uses		Types;	function InitAppleEvents (DoOApp, DoODoc, DoPrint, DoQuit: Ptr): OSErr;implementation	uses		AppleEvents;	function DoOApp (p: ptr): OSErr;	inline		$205F, (* movea.l	(a7)+,a0		; pop proc/func address	*)		$4E90; (* jsr			(a0)				; call proc/func				*)	function DoDocs (fs: FSSpec; p: ptr): OSErr;	inline		$205F, (* movea.l	(a7)+,a0		; pop proc/func address	*)		$4E90; (* jsr			(a0)				; call proc/func				*)	function DoQuit (p: ptr): OSErr;	inline		$205F, (* movea.l	(a7)+,a0		; pop proc/func address	*)		$4E90; (* jsr			(a0)				; call proc/func				*)	function GotRequiredParams (theAppleEvent: AppleEvent): OSErr;		var			typeCode: DescType;			actualSize: Size;			err: OSErr;	begin		err := AEGetAttributePtr(theAppleEvent, keyMissedKeywordAttr, typeWildCard, typeCode, nil, 0, actualSize);(* nil ok: need only function result *)		if err = errAEDescNotFound then		(* we got all the required params: all is ok *)			GotRequiredParams := noErr		else if err = noErr then			GotRequiredParams := errAEEventNotHandled		else			GotRequiredParams := err;	end; (* GotRequiredParams *)	function HandleOAPP (theAppleEvent, reply: AppleEvent; openappp: ptr): OSErr;(* <aevt> }{	kCoreEventClass kAEOpenApplication}{*)		var			oe: OSErr;	begin	(* We don't expect any params at all, but check in case the client requires any *)		oe := GotRequiredParams(theAppleEvent);		oe := DoOApp(openappp);		HandleOAPP := oe;	end;	function HandleDocs (theAppleEvent, reply: AppleEvent; dodocp: ptr): OSErr;(* <aevt>}{	kCoreEventClass kAEOpenDocuments}{	kCoreEventClass kAEPrintDocuments}{*)		var			myFSS: FSSpec;			docList: AEDescList;			index, itemsInList: longint;			actualSize: Size;			keywd: AEKeyword;			typeCode: descType;			ignoreWPtr: WindowPtr;			oe, ooe: OSErr;	begin		oe := AEGetParamDesc(theAppleEvent, keyDirectObject, typeAEList, docList);		if oe = noErr then begin			ooe := GotRequiredParams(theAppleEvent);(* now get each alias from the list (as an FSSSpec) and open the associated file. *)			oe := AECountItems(docList, itemsInList);			for index := 1 to itemsInList do begin				ooe := AEGetNthPtr(docList, index, typeFSS, keywd, typeCode, @myFSS, sizeof(myFSS), actualSize);(* coercion does alias->fsspec *)				if ooe = noErr then					ooe := DoDocs(myFSS, dodocp);			end;			ooe := AEDisposeDesc(docList);		end;		HandleDocs := oe;	end; (* HandleDocs *)	function HandleQUIT (theAppleEvent, reply: AppleEvent; quitp: ptr): OSErr;(* <aevt> }{	kCoreEventClass kAEQuitApplication}{*)		var			oe: OSErr;			errStr: Str255;			willQuit: Boolean;				(* did the user allow the quit or cancel *)	begin(* We don't expect any params at all, but check in case the client requires any *)		oe := GotRequiredParams(theAppleEvent);		oe := DoQuit(quitp);				(* set global boolean: app will exit at end of event loop *)		if reply.dataHandle <> nil then		(* a reply is sought *)			begin			if oe = noErr then				errStr := 'OK'			else				errStr := 'user cancelled quit';			oe := AEPutParamPtr(reply, keyErrorString, typeChar, Ptr(@errStr[1]), length(errStr));		end;		HandleQUIT := oe;	end;{$S Init}	function InitAppleEvents (DoOApp, DoODoc, DoPrint, DoQuit: Ptr): OSErr;		var			aevtErr: OSErr;	begin		aevtErr := noErr;		if (aevtErr = noErr) and (DoOApp <> nil) then			aevtErr := AEInstallEventHandler(kCoreEventClass, kAEOpenApplication, @HandleOAPP, longint(DoOApp), false);		if (aevtErr = noErr) and (DoODoc <> nil) then			aevtErr := AEInstallEventHandler(kCoreEventClass, kAEOpenDocuments, @HandleDocs, longint(DoODoc), false);		if (aevtErr = noErr) and (DoPrint <> nil) then			aevtErr := AEInstallEventHandler(kCoreEventClass, kAEPrintDocuments, @HandleDocs, longint(DoPrint), false);		if (aevtErr = noErr) and (DoQuit <> nil) then			aevtErr := AEInstallEventHandler(kCoreEventClass, kAEQuitApplication, @HandleQUIT, longint(DoQuit), false);		InitAppleEvents := aevtErr;	end;end. (* RequiredEventSupport *)