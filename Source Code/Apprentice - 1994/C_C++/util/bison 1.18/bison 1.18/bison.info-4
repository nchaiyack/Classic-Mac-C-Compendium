Info file bison.info, produced by Makeinfo, -*- Text -*- from inputfile bison.texinfo.   This file documents the Bison parser generator.   Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.   Permission is granted to make and distribute verbatim copies ofthis manual provided the copyright notice and this permission noticeare preserved on all copies.   Permission is granted to copy and distribute modified versions ofthis manual under the conditions for verbatim copying, provided alsothat the sections entitled "GNU General Public License" and"Conditions for Using Bison" are included exactly as in the original,and provided that the entire resulting derived work is distributedunder the terms of a permission notice identical to this one.   Permission is granted to copy and distribute translations of thismanual into another language, under the above conditions for modifiedversions, except that the sections entitled "GNU General PublicLicense", "Conditions for Using Bison" and this permission notice maybe included in translations approved by the Free Software Foundationinstead of in the original English.File: bison.info,  Node: Semantic Tokens,  Next: Lexical Tie-ins,  Prev: Context Dependency,  Up: Context DependencySemantic Info in Token Types============================   The C language has a context dependency: the way an identifier isused depends on what its current meaning is.  For example, considerthis:     foo (x);   This looks like a function call statement, but if `foo' is a typedefname, then this is actually a declaration of `x'.  How can a Bisonparser for C decide how to parse this input?   The method used in GNU C is to have two different token types,`IDENTIFIER' and `TYPENAME'.  When `yylex' finds an identifier, itlooks up the current declaration of the identifier in order to decidewhich token type to return: `TYPENAME' if the identifier is declaredas a typedef, `IDENTIFIER' otherwise.   The grammar rules can then express the context dependency by thechoice of token type to recognize.  `IDENTIFIER' is accepted as anexpression, but `TYPENAME' is not.  `TYPENAME' can start adeclaration, but `IDENTIFIER' cannot.  In contexts where the meaningof the identifier is *not* significant, such as in declarations thatcan shadow a typedef name, either `TYPENAME' or `IDENTIFIER' isaccepted--there is one rule for each of the two token types.   This technique is simple to use if the decision of which kinds ofidentifiers to allow is made at a place close to where the identifieris parsed.  But in C this is not always so: C allows a declaration toredeclare a typedef name provided an explicit type has been specifiedearlier:     typedef int foo, bar, lose;     static foo (bar);        /* redeclare `bar' as static variable */     static int foo (lose);   /* redeclare `foo' as function */   Unfortunately, the name being declared is separated from thedeclaration construct itself by a complicated syntactic structure--the"declarator".   As a result, the part of Bison parser for C needs to be duplicated,with all the nonterminal names changed: once for parsing a declarationin which a typedef name can be redefined, and once for parsing adeclaration in which that can't be done.  Here is a part of theduplication, with actions omitted for brevity:     initdcl:               declarator maybeasm '='               init             | declarator maybeasm             ;          notype_initdcl:               notype_declarator maybeasm '='               init             | notype_declarator maybeasm             ;Here `initdcl' can redeclare a typedef name, but `notype_initdcl'cannot.  The distinction between `declarator' and `notype_declarator'is the same sort of thing.   There is some similarity between this technique and a lexical tie-in(described next), in that information which alters the lexicalanalysis is changed during parsing by other parts of the program.  Thedifference is here the information is global, and is used for otherpurposes in the program.  A true lexical tie-in has a special-purposeflag controlled by the syntactic context.File: bison.info,  Node: Lexical Tie-ins,  Next: Tie-in Recovery,  Prev: Semantic Tokens,  Up: Context DependencyLexical Tie-ins===============   One way to handle context-dependency is the "lexical tie-in": a flagwhich is set by Bison actions, whose purpose is to alter the waytokens are parsed.   For example, suppose we have a language vaguely like C, but with aspecial construct `hex (HEX-EXPR)'.  After the keyword `hex' comes anexpression in parentheses in which all integers are hexadecimal.  Inparticular, the token `a1b' must be treated as an integer rather thanas an identifier if it appears in that context.  Here is how you cando it:     %{     int hexflag;     %}     %%     ...     expr:   IDENTIFIER             | constant             | HEX '('                     { hexflag = 1; }               expr ')'                     { hexflag = 0;                        $$ = $4; }             | expr '+' expr                     { $$ = make_sum ($1, $3); }             ...             ;          constant:               INTEGER             | STRING             ;Here we assume that `yylex' looks at the value of `hexflag'; when itis nonzero, all integers are parsed in hexadecimal, and tokens startingwith letters are parsed as integers if possible.   The declaration of `hexflag' shown in the C declarations section ofthe parser file is needed to make it accessible to the actions (*noteC Declarations::.).  You must also write the code in `yylex' to obeythe flag.File: bison.info,  Node: Tie-in Recovery,  Prev: Lexical Tie-ins,  Up: Context DependencyLexical Tie-ins and Error Recovery==================================   Lexical tie-ins make strict demands on any error recovery rules youhave.  *Note Error Recovery::.   The reason for this is that the purpose of an error recovery ruleis to abort the parsing of one construct and resume in some largerconstruct.  For example, in C-like languages, a typical error recoveryrule is to skip tokens until the next semicolon, and then start a newstatement, like this:     stmt:   expr ';'             | IF '(' expr ')' stmt { ... }             ...             error ';'                     { hexflag = 0; }             ;   If there is a syntax error in the middle of a `hex (EXPR)'construct, this error rule will apply, and then the action for thecompleted `hex (EXPR)' will never run.  So `hexflag' would remain setfor the entire rest of the input, or until the next `hex' keyword,causing identifiers to be misinterpreted as integers.   To avoid this problem the error recovery rule itself clears`hexflag'.   There may also be an error recovery rule that works withinexpressions.  For example, there could be a rule which applies withinparentheses and skips to the close-parenthesis:     expr:   ...             | '(' expr ')'                     { $$ = $2; }             | '(' error ')'             ...   If this rule acts within the `hex' construct, it is not going toabort that construct (since it applies to an inner level ofparentheses within the construct).  Therefore, it should not clear theflag: the rest of the `hex' construct should be parsed with the flagstill in effect.   What if there is an error recovery rule which might abort out of the`hex' construct or might not, depending on circumstances?  There is noway you can write the action to determine whether a `hex' construct isbeing aborted or not.  So if you are using a lexical tie-in, you hadbetter make sure your error recovery rules are not of this kind.  Eachrule must be such that you can be sure that it always will, or alwayswon't, have to clear the flag.File: bison.info,  Node: Debugging,  Next: Invocation,  Prev: Context Dependency,  Up: TopDebugging Your Parser*********************   If a Bison grammar compiles properly but doesn't do what you wantwhen it runs, the `yydebug' parser-trace feature can help you figureout why.   To enable compilation of trace facilities, you must define the macro`YYDEBUG' when you compile the parser.  You could use `-DYYDEBUG=1' asa compiler option or you could put `#define YYDEBUG 1' in the Cdeclarations section of the grammar file (*note C Declarations::.). Alternatively, use the `-t' option when you run Bison (*noteInvocation::.).  We always define `YYDEBUG' so that debugging isalways possible.   The trace facility uses `stderr', so you must add`#include <stdio.h>' to the C declarations section unless it isalready there.   Once you have compiled the program with trace facilities, the way torequest a trace is to store a nonzero value in the variable `yydebug'. You can do this by making the C code do it (in `main', perhaps), oryou can alter the value with a C debugger.   Each step taken by the parser when `yydebug' is nonzero produces aline or two of trace information, written on `stderr'.  The tracemessages tell you these things:   * Each time the parser calls `yylex', what kind of token was read.   * Each time a token is shifted, the depth and complete contents of     the state stack (*note Parser States::.).   * Each time a rule is reduced, which rule it is, and the complete     contents of the state stack afterward.   To make sense of this information, it helps to refer to the listingfile produced by the Bison `-v' option (*note Invocation::.).  Thisfile shows the meaning of each state in terms of positions in variousrules, and also what each state will do with each possible inputtoken.  As you read the successive trace messages, you can see thatthe parser is functioning according to its specification in thelisting file.  Eventually you will arrive at the place where somethingundesirable happens, and you will see which parts of the grammar areto blame.   The parser file is a C program and you can use C debuggers on it,but it's not easy to interpret what it is doing.  The parser functionis a finite-state machine interpreter, and aside from the actions itexecutes the same code over and over.  Only the values of variablesshow where in the grammar it is working.   The debugging information normally gives the token type of eachtoken read, but not its semantic value.  You can optionally define amacro named `YYPRINT' to provide a way to print the value.  If youdefine `YYPRINT', it should take three arguments.  The parser willpass a standard I/O stream, the numeric code for the token type, andthe token value (from `yylval').   Here is an example of `YYPRINT' suitable for the multi-functioncalculator (*note Mfcalc Decl::.):     #define YYPRINT(file, type, value)   yyprint (file, type, value)          static void     yyprint (file, type, value)          FILE *file;          int type;          YYSTYPE value;     {       if (type == VAR)         fprintf (file, " %s", value.tptr->name);       else if (type == NUM)         fprintf (file, " %d", value.val);     }File: bison.info,  Node: Invocation,  Next: Table of Symbols,  Prev: Debugging,  Up: TopInvoking Bison**************   The usual way to invoke Bison is as follows:     bison INFILE   Here INFILE is the grammar file name, which usually ends in `.y'. The parser file's name is made by replacing the `.y' with `.tab.c'. Thus, the `bison foo.y' filename yields `foo.tab.c', and the `bisonhack/foo.y' filename yields `hack/foo.tab.c'.   Bison supports both traditional single-letter options and mnemoniclong option names.  Long option names are indicated with `--' insteadof `-'.  Abbreviations for option names are allowed as long as theyare unique.  When a long option takes an argument, like`--file-prefix', connect the option name and the argument with `='.   Here is a list of options that can be used with Bison, alphabetizedby short option.  It is followed by a cross key alphabetized by longoption.`-b FILE-PREFIX'`--file-prefix=PREFIX'     Specify a prefix to use for all Bison output file names.  The     names are chosen as if the input file were named `PREFIX.c'.`-d'`--defines'     Write an extra output file containing macro definitions for the     token type names defined in the grammar and the semantic value     type `YYSTYPE', as well as a few `extern' variable declarations.     If the parser output file is named `NAME.c' then this file is     named `NAME.h'.     This output file is essential if you wish to put the definition of     `yylex' in a separate source file, because `yylex' needs to be     able to refer to token type codes and the variable `yylval'.      *Note Token Values::.`-l'`--no-lines'     Don't put any `#line' preprocessor commands in the parser file.      Ordinarily Bison puts them in the parser file so that the C     compiler and debuggers will associate errors with your source     file, the grammar file.  This option causes them to associate     errors with the parser file, treating it an independent source     file in its own right.`-o OUTFILE'`--output-file=OUTFILE'     Specify the name OUTFILE for the parser file.     The other output files' names are constructed from OUTFILE as     described under the `-v' and `-d' switches.`-p PREFIX'`--name-prefix=PREFIX'     Rename the external symbols used in the parser so that they start     with PREFIX instead of `yy'.  The precise list of symbols renamed     is `yyparse', `yylex', `yyerror', `yylval', `yychar' and     `yydebug'.     For example, if you use `-p c', the names become `cparse',     `clex', and so on.     *Note Multiple Parsers::.`-t'`--debug'     Output a definition of the macro `YYDEBUG' into the parser file,     so that the debugging facilities are compiled.  *Note Debugging::.`-v'`--verbose'     Write an extra output file containing verbose descriptions of the     parser states and what is done for each type of look-ahead token     in that state.     This file also describes all the conflicts, both those resolved by     operator precedence and the unresolved ones.     The file's name is made by removing `.tab.c' or `.c' from the     parser output file name, and adding `.output' instead.     Therefore, if the input file is `foo.y', then the parser file is     called `foo.tab.c' by default.  As a consequence, the verbose     output file is called `foo.output'.`-V'`--version'     Print the version number of Bison.`-y'`--yacc'`--fixed-output-files'     Equivalent to `-o y.tab.c'; the parser output file is called     `y.tab.c', and the other outputs are called `y.output' and     `y.tab.h'.  The purpose of this switch is to imitate Yacc's output     file name conventions.  Thus, the following shell script can     substitute for Yacc:          bison -y $*Options' Cross Key==================   Here is a list of options, alphabetized by long option, to help youfind the corresponding short option.     --debug                               -t     --defines                             -d     --file-prefix=PREFIX                  -b FILE-PREFIX     --fixed-output-files --yacc           -y     --name-prefix                         -p     --no-lines                            -l     --output-file=OUTFILE                 -o OUTFILE     --verbose                             -v     --version                             -VFile: bison.info,  Node: Table of Symbols,  Next: Glossary,  Prev: Invocation,  Up: TopBison Symbols*************`error'     A token name reserved for error recovery.  This token may be used     in grammar rules so as to allow the Bison parser to recognize an     error in the grammar without halting the process.  In effect, a     sentence containing an error may be recognized as valid.  On a     parse error, the token `error' becomes the current look-ahead     token.  Actions corresponding to `error' are then executed, and     the look-ahead token is reset to the token that originally caused     the violation.  *Note Error Recovery::.`YYABORT'     Macro to pretend that an unrecoverable syntax error has occurred,     by making `yyparse' return 1 immediately.  The error reporting     function `yyerror' is not called.  *Note Parser Function::.`YYACCEPT'     Macro to pretend that a complete utterance of the language has     been read, by making `yyparse' return 0 immediately.  *Note     Parser Function::.`YYBACKUP'     Macro to discard a value from the parser stack and fake a     look-ahead token.  *Note Action Features::.`YYERROR'     Macro to pretend that a syntax error has just been detected: call     `yyerror' and then perform normal error recovery if possible     (*note Error Recovery::.), or (if recovery is impossible) make     `yyparse' return 1.  *Note Error Recovery::.`YYINITDEPTH'     Macro for specifying the initial size of the parser stack.  *Note     Stack Overflow::.`YYLTYPE'     Macro for the data type of `yylloc'; a structure with four     members.  *Note Token Positions::.`YYMAXDEPTH'     Macro for specifying the maximum size of the parser stack.  *Note     Stack Overflow::.`YYRECOVERING'     Macro whose value indicates whether the parser is recovering from     a syntax error.  *Note Action Features::.`YYSTYPE'     Macro for the data type of semantic values; `int' by default.      *Note Value Type::.`yychar'     External integer variable that contains the integer value of the     current look-ahead token.  (In a pure parser, it is a local     variable within `yyparse'.)  Error-recovery rule actions may     examine this variable.  *Note Action Features::.`yyclearin'     Macro used in error-recovery rule actions.  It clears the previous     look-ahead token.  *Note Error Recovery::.`yydebug'     External integer variable set to zero by default.  If `yydebug'     is given a nonzero value, the parser will output information on     input symbols and parser action.  *Note Debugging::.`yyerrok'     Macro to cause parser to recover immediately to its normal mode     after a parse error.  *Note Error Recovery::.`yyerror'     User-supplied function to be called by `yyparse' on error.  The     function receives one argument, a pointer to a character string     containing an error message.  *Note Error Reporting::.`yylex'     User-supplied lexical analyzer function, called with no arguments     to get the next token.  *Note Lexical::.`yylval'     External variable in which `yylex' should place the semantic     value associated with a token.  (In a pure parser, it is a local     variable within `yyparse', and its address is passed to `yylex'.)      *Note Token Values::.`yylloc'     External variable in which `yylex' should place the line and     column numbers associated with a token.  (In a pure parser, it is     a local variable within `yyparse', and its address is passed to     `yylex'.)  You can ignore this variable if you don't use the `@'     feature in the grammar actions.  *Note Token Positions::.`yynerrs'     Global variable which Bison increments each time there is a parse     error.  (In a pure parser, it is a local variable within     `yyparse'.)  *Note Error Reporting::.`yyparse'     The parser function produced by Bison; call this function to start     parsing.  *Note Parser Function::.`%left'     Bison declaration to assign left associativity to token(s).      *Note Precedence Decl::.`%nonassoc'     Bison declaration to assign nonassociativity to token(s).  *Note     Precedence Decl::.`%prec'     Bison declaration to assign a precedence to a specific rule.      *Note Contextual Precedence::.`%pure_parser'     Bison declaration to request a pure (reentrant) parser.  *Note     Pure Decl::.`%right'     Bison declaration to assign right associativity to token(s).      *Note Precedence Decl::.`%start'     Bison declaration to specify the start symbol.  *Note Start     Decl::.`%token'     Bison declaration to declare token(s) without specifying     precedence.  *Note Token Decl::.`%type'     Bison declaration to declare nonterminals.  *Note Type Decl::.`%union'     Bison declaration to specify several possible data types for     semantic values.  *Note Union Decl::.   These are the punctuation and delimiters used in Bison input:`%%'     Delimiter used to separate the grammar rule section from the     Bison declarations section or the additional C code section.      *Note Grammar Layout::.`%{ %}'     All code listed between `%{' and `%}' is copied directly to the     output file uninterpreted.  Such code forms the "C declarations"     section of the input file.  *Note Grammar Outline::.`/*...*/'     Comment delimiters, as in C.`:'     Separates a rule's result from its components.  *Note Rules::.`;'     Terminates a rule.  *Note Rules::.`|'     Separates alternate rules for the same result nonterminal.  *Note     Rules::.File: bison.info,  Node: Glossary,  Next: Index,  Prev: Table of Symbols,  Up: topGlossary********Backus-Naur Form (BNF)     Formal method of specifying context-free grammars.  BNF was first     used in the `ALGOL-60' report, 1963.  *Note Language and     Grammar::.Context-free grammars     Grammars specified as rules that can be applied regardless of     context.  Thus, if there is a rule which says that an integer can     be used as an expression, integers are allowed *anywhere* an     expression is permitted.  *Note Language and Grammar::.Dynamic allocation     Allocation of memory that occurs during execution, rather than at     compile time or on entry to a function.Empty string     Analogous to the empty set in set theory, the empty string is a     character string of length zero.Finite-state stack machine     A "machine" that has discrete states in which it is said to exist     at each instant in time.  As input to the machine is processed,     the machine moves from state to state as specified by the logic     of the machine.  In the case of the parser, the input is the     language being parsed, and the states correspond to various     stages in the grammar rules.  *Note Algorithm::.Grouping     A language construct that is (in general) grammatically divisible;     for example, `expression' or `declaration' in C.  *Note Language     and Grammar::.Infix operator     An arithmetic operator that is placed between the operands on     which it performs some operation.Input stream     A continuous flow of data between devices or programs.Language construct     One of the typical usage schemas of the language.  For example,     one of the constructs of the C language is the `if' statement.      *Note Language and Grammar::.Left associativity     Operators having left associativity are analyzed from left to     right: `a+b+c' first computes `a+b' and then combines with `c'.      *Note Precedence::.Left recursion     A rule whose result symbol is also its first component symbol;     for example, `expseq1 : expseq1 ',' exp;'.  *Note Recursion::.Left-to-right parsing     Parsing a sentence of a language by analyzing it token by token     from left to right.  *Note Algorithm::.Lexical analyzer (scanner)     A function that reads an input stream and returns tokens one by     one.  *Note Lexical::.Lexical tie-in     A flag, set by actions in the grammar rules, which alters the way     tokens are parsed.  *Note Lexical Tie-ins::.Look-ahead token     A token already read but not yet shifted.  *Note Look-Ahead::.LALR(1)     The class of context-free grammars that Bison (like most other     parser generators) can handle; a subset of LR(1).  *Note      Mysterious Reduce/Reduce Conflicts: Mystery Conflicts.LR(1)     The class of context-free grammars in which at most one token of     look-ahead is needed to disambiguate the parsing of any piece of     input.Nonterminal symbol     A grammar symbol standing for a grammatical construct that can be     expressed through rules in terms of smaller constructs; in other     words, a construct that is not a token.  *Note Symbols::.Parse error     An error encountered during parsing of an input stream due to     invalid syntax.  *Note Error Recovery::.Parser     A function that recognizes valid sentences of a language by     analyzing the syntax structure of a set of tokens passed to it     from a lexical analyzer.Postfix operator     An arithmetic operator that is placed after the operands upon     which it performs some operation.Reduction     Replacing a string of nonterminals and/or terminals with a single     nonterminal, according to a grammar rule.  *Note Algorithm::.Reentrant     A reentrant subprogram is a subprogram which can be in invoked any     number of times in parallel, without interference between the     various invocations.  *Note Pure Decl::.Reverse polish notation     A language in which all operators are postfix operators.Right recursion     A rule whose result symbol is also its last component symbol; for     example, `expseq1: exp ',' expseq1;'.  *Note Recursion::.Semantics     In computer languages, the semantics are specified by the actions     taken for each instance of the language, i.e., the meaning of     each statement.  *Note Semantics::.Shift     A parser is said to shift when it makes the choice of analyzing     further input from the stream rather than reducing immediately     some already-recognized rule.  *Note Algorithm::.Single-character literal     A single character that is recognized and interpreted as is.      *Note Grammar in Bison::.Start symbol     The nonterminal symbol that stands for a complete valid utterance     in the language being parsed.  The start symbol is usually listed     as the first nonterminal symbol in a language specification.      *Note Start Decl::.Symbol table     A data structure where symbol names and associated data are stored     during parsing to allow for recognition and use of existing     information in repeated uses of a symbol.  *Note Multi-function     Calc::.Token     A basic, grammatically indivisible unit of a language.  The symbol     that describes a token in the grammar is a terminal symbol.  The     input of the Bison parser is a stream of tokens which comes from     the lexical analyzer.  *Note Symbols::.Terminal symbol     A grammar symbol that has no rules in the grammar and therefore     is grammatically indivisible.  The piece of text it represents is     a token.  *Note Language and Grammar::.File: bison.info,  Node: Index,  Prev: Glossary,  Up: topIndex****** Menu:* $$:                                   Actions.* $N:                                   Actions.* %expect:                              Expect Decl.* %left:                                Using Precedence.* %nonassoc:                            Using Precedence.* %prec:                                Contextual Precedence.* %pure_parser:                         Pure Decl.* %right:                               Using Precedence.* %start:                               Start Decl.* %token:                               Token Decl.* %type:                                Type Decl.* %union:                               Union Decl.* @N:                                   Action Features.* calc:                                 Infix Calc.* else, dangling:                       Shift/Reduce.* mfcalc:                               Multi-function Calc.* rpcalc:                               RPN Calc.* BNF:                                  Language and Grammar.* Backus-Naur form:                     Language and Grammar.* Bison declaration summary:            Decl Summary.* Bison declarations:                   Declarations.* Bison declarations (introduction):    Bison Declarations.* Bison grammar:                        Grammar in Bison.* Bison invocation:                     Invocation.* Bison parser:                         Bison Parser.* Bison parser algorithm:               Algorithm.* Bison symbols, table of:              Table of Symbols.* Bison utility:                        Bison Parser.* C code, section for additional:       C Code.* C declarations section:               C Declarations.* C-language interface:                 Interface.* LALR(1):                              Mystery Conflicts.* LR(1):                                Mystery Conflicts.* YYABORT:                              Parser Function.* YYACCEPT:                             Parser Function.* YYBACKUP:                             Action Features.* YYDEBUG:                              Debugging.* YYEMPTY:                              Action Features.* YYERROR:                              Action Features.* YYINITDEPTH:                          Stack Overflow.* YYLTYPE:                              Token Positions.* YYMAXDEPTH:                           Stack Overflow.* YYPRINT:                              Debugging.* YYRECOVERING:                         Error Recovery.* action:                               Actions.* action data types:                    Action Types.* action features summary:              Action Features.* actions in mid-rule:                  Mid-Rule Actions.* actions, semantic:                    Semantic Actions.* additional C code section:            C Code.* algorithm of parser:                  Algorithm.* associativity:                        Why Precedence.* calculator, infix notation:           Infix Calc.* calculator, multi-function:           Multi-function Calc.* calculator, simple:                   RPN Calc.* character token:                      Symbols.* compiling the parser:                 Rpcalc Compile.* conflicts:                            Shift/Reduce.* conflicts, reduce/reduce:             Reduce/Reduce.* conflicts, suppressing warnings of:   Expect Decl.* context-dependent precedence:         Contextual Precedence.* context-free grammar:                 Language and Grammar.* controlling function:                 Rpcalc Main.* dangling else:                        Shift/Reduce.* data types in actions:                Action Types.* data types of semantic values:        Value Type.* debugging:                            Debugging.* declaration summary:                  Decl Summary.* declarations, Bison:                  Declarations.* declarations, Bison (introduction):   Bison Declarations.* declarations, C:                      C Declarations.* declaring operator precedence:        Precedence Decl.* declaring the start symbol:           Start Decl.* declaring token type names:           Token Decl.* declaring value types:                Union Decl.* declaring value types, nonterminals:  Type Decl.* defining language semantics:          Semantics.* error:                                Error Recovery.* error recovery:                       Error Recovery.* error recovery, simple:               Simple Error Recovery.* error reporting function:             Error Reporting.* error reporting routine:              Rpcalc Error.* examples, simple:                     Examples.* exercises:                            Exercises.* file format:                          Grammar Layout.* finite-state machine:                 Parser States.* formal grammar:                       Grammar in Bison.* format of grammar file:               Grammar Layout.* glossary:                             Glossary.* grammar file:                         Grammar Layout.* grammar rule syntax:                  Rules.* grammar rules section:                Grammar Rules.* grammar, Bison:                       Grammar in Bison.* grammar, context-free:                Language and Grammar.* grouping, syntactic:                  Language and Grammar.* infix notation calculator:            Infix Calc.* interface:                            Interface.* introduction:                         Introduction.* invoking Bison:                       Invocation.* language semantics, defining:         Semantics.* layout of Bison grammar:              Grammar Layout.* left recursion:                       Recursion.* lexical analyzer:                     Lexical.* lexical analyzer, purpose:            Bison Parser.* lexical analyzer, writing:            Rpcalc Lexer.* lexical tie-in:                       Lexical Tie-ins.* literal token:                        Symbols.* look-ahead token:                     Look-Ahead.* main function in simple example:      Rpcalc Main.* mid-rule actions:                     Mid-Rule Actions.* multi-function calculator:            Multi-function Calc.* mutual recursion:                     Recursion.* nonterminal symbol:                   Symbols.* operator precedence:                  Precedence.* operator precedence, declaring:       Precedence Decl.* options for invoking Bison:           Invocation.* overflow of parser stack:             Stack Overflow.* parse error:                          Error Reporting.* parser:                               Bison Parser.* parser stack:                         Algorithm.* parser stack overflow:                Stack Overflow.* parser state:                         Parser States.* polish notation calculator:           RPN Calc.* precedence declarations:              Precedence Decl.* precedence of operators:              Precedence.* precedence, context-dependent:        Contextual Precedence.* precedence, unary operator:           Contextual Precedence.* preventing warnings about conflicts:  Expect Decl.* pure parser:                          Pure Decl.* recovery from errors:                 Error Recovery.* recursive rule:                       Recursion.* reduce/reduce conflict:               Reduce/Reduce.* reduction:                            Algorithm.* reentrant parser:                     Pure Decl.* reverse polish notation:              RPN Calc.* right recursion:                      Recursion.* rule syntax:                          Rules.* rules section for grammar:            Grammar Rules.* running Bison (introduction):         Rpcalc Gen.* semantic actions:                     Semantic Actions.* semantic value:                       Semantic Values.* semantic value type:                  Value Type.* shift/reduce conflicts:               Shift/Reduce.* shifting:                             Algorithm.* simple examples:                      Examples.* single-character literal:             Symbols.* stack overflow:                       Stack Overflow.* stack, parser:                        Algorithm.* stages in using Bison:                Stages.* start symbol:                         Language and Grammar.* start symbol, declaring:              Start Decl.* state (of parser):                    Parser States.* summary, Bison declaration:           Decl Summary.* summary, action features:             Action Features.* suppressing conflict warnings:        Expect Decl.* symbol:                               Symbols.* symbol table example:                 Mfcalc Symtab.* symbols (abstract):                   Language and Grammar.* symbols in Bison, table of:           Table of Symbols.* syntactic grouping:                   Language and Grammar.* syntax error:                         Error Reporting.* syntax of grammar rules:              Rules.* terminal symbol:                      Symbols.* token:                                Language and Grammar.* token type:                           Symbols.* token type names, declaring:          Token Decl.* tracing the parser:                   Debugging.* unary operator precedence:            Contextual Precedence.* using Bison:                          Stages.* value type, semantic:                 Value Type.* value types, declaring:               Union Decl.* value types, nonterminals, declaring: Type Decl.* value, semantic:                      Semantic Values.* warnings, preventing:                 Expect Decl.* writing a lexical analyzer:           Rpcalc Lexer.* yychar:                               Look-Ahead.* yyclearin:                            Error Recovery.* yydebug:                              Debugging.* yyerrok:                              Error Recovery.* yyerror:                              Error Reporting.* yylex:                                Lexical.* yylloc:                               Token Positions.* yylval:                               Token Values.* yynerrs:                              Error Reporting.* yyparse:                              Parser Function.* |:                                    Rules.